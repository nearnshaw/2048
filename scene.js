(function(e, a) { for(var i in a) e[i] = a[i]; }(this, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "../../../../../private/var/folders/dl/bpdwhdg504j8z_t2tdcnt1n00000gp/T/0.40865999307976186.WebWorker.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../../../../private/var/folders/dl/bpdwhdg504j8z_t2tdcnt1n00000gp/T/0.40865999307976186.WebWorker.js":
/*!*************************************************************************************************!*\
  !*** /private/var/folders/dl/bpdwhdg504j8z_t2tdcnt1n00000gp/T/0.40865999307976186.WebWorker.js ***!
  \*************************************************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Users_Nico_Documents_github_2048_node_modules_decentraland_rpc_lib_common_transports_WebWorker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/decentraland-rpc/lib/common/transports/WebWorker */ \"./node_modules/decentraland-rpc/lib/common/transports/WebWorker.js\");\n\n\nconst imported = __webpack_require__(/*! ./scene.tsx */ \"./scene.tsx\")\n\nif (imported && imported.__esModule && imported['default']) {\n  new imported['default'](Object(_Users_Nico_Documents_github_2048_node_modules_decentraland_rpc_lib_common_transports_WebWorker__WEBPACK_IMPORTED_MODULE_0__[\"WebWorkerTransport\"])(self))\n}\n\n\n//# sourceURL=webpack:////private/var/folders/dl/bpdwhdg504j8z_t2tdcnt1n00000gp/T/0.40865999307976186.WebWorker.js?");

/***/ }),

/***/ "./components/tile.tsx":
/*!*****************************!*\
  !*** ./components/tile.tsx ***!
  \*****************************/
/*! exports provided: Tile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Tile\", function() { return Tile; });\n/* harmony import */ var decentraland_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! decentraland-api */ \"./node_modules/decentraland-api/lib/index.js\");\n/* harmony import */ var decentraland_api__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(decentraland_api__WEBPACK_IMPORTED_MODULE_0__);\n\nconst Tile = (props) => {\n    let srcPath = \"/models/\" + props.value.toString() + \".gltf\";\n    return (decentraland_api__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"](\"gltf-model\", { key: props.id, position: props.position, transition: { position: { duration: props.speed, timing: 'linear' } }, src: srcPath }));\n};\n\n\n//# sourceURL=webpack:///./components/tile.tsx?");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack:///./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/decentraland-api/lib/MessageBus.js":
/*!*********************************************************!*\
  !*** ./node_modules/decentraland-api/lib/MessageBus.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst EventDispatcher_1 = __webpack_require__(/*! decentraland-rpc/lib/common/core/EventDispatcher */ \"./node_modules/decentraland-rpc/lib/common/core/EventDispatcher.js\");\n/**\n * MessageBusClient provides an easy way to send and reveive peer to peer\n * messages thru the communications interface of Decentraland.\n *\n * The usage is simple, it implements a pub-sub pattern that shares messages\n * using the connection that already exists between peers.\n *\n * @example inside your ScriptableScene\n * ```ts\n *   let messageBusClient = await MessageBusClient.acquireEstateChannel(this)\n *   messageBusClient.on('a message name', (message) => {...})\n *   messageBusClient.emit('a message name', message)\n * ```\n */\nclass MessageBusClient extends EventDispatcher_1.EventDispatcher {\n    constructor(api, id, busClientId) {\n        super();\n        this.api = api;\n        this.id = id;\n        this.busClientId = busClientId;\n        api[`on${this.id}`]((message) => {\n            if (this.busClientId !== message.sender) {\n                super.emit(message.event, ...message.args);\n            }\n        });\n    }\n    static async acquireEstateChannel(system) {\n        const busId = Math.random().toString(36);\n        const { MessageBus } = await system.loadAPIs(['MessageBus']);\n        const bus = await MessageBus.getEstateChannel();\n        return new MessageBusClient(MessageBus, bus.id, busId);\n    }\n    emit(event, ...args) {\n        this.api[this.id]({\n            event,\n            args,\n            sender: this.busClientId\n        });\n        super.emit(event, ...args);\n    }\n}\nexports.MessageBusClient = MessageBusClient;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWVzc2FnZUJ1cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9NZXNzYWdlQnVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsc0ZBQWtGO0FBU2xGOzs7Ozs7Ozs7Ozs7O0dBYUc7QUFDSCxNQUFhLGdCQUEwQixTQUFRLGlDQUFrQjtJQUMvRCxZQUE4QixHQUFRLEVBQVksRUFBVSxFQUFZLFdBQW1CO1FBQ3pGLEtBQUssRUFBRSxDQUFBO1FBRHFCLFFBQUcsR0FBSCxHQUFHLENBQUs7UUFBWSxPQUFFLEdBQUYsRUFBRSxDQUFRO1FBQVksZ0JBQVcsR0FBWCxXQUFXLENBQVE7UUFFekYsR0FBRyxDQUFDLEtBQUssSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxPQUFpQixFQUFFLEVBQUU7WUFDeEMsSUFBSSxJQUFJLENBQUMsV0FBVyxLQUFLLE9BQU8sQ0FBQyxNQUFNLEVBQUU7Z0JBQ3ZDLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQTthQUMzQztRQUNILENBQUMsQ0FBQyxDQUFBO0lBQ0osQ0FBQztJQUVELE1BQU0sQ0FBQyxLQUFLLENBQUMsb0JBQW9CLENBQUMsTUFBdUI7UUFDdkQsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQTtRQUN4QyxNQUFNLEVBQUUsVUFBVSxFQUFFLEdBQUcsTUFBTSxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQTtRQUU1RCxNQUFNLEdBQUcsR0FBRyxNQUFNLFVBQVUsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFBO1FBRS9DLE9BQU8sSUFBSSxnQkFBZ0IsQ0FBQyxVQUFVLEVBQUUsR0FBRyxDQUFDLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQTtJQUN4RCxDQUFDO0lBRUQsSUFBSSxDQUFDLEtBQWEsRUFBRSxHQUFHLElBQVc7UUFDaEMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDaEIsS0FBSztZQUNMLElBQUk7WUFDSixNQUFNLEVBQUUsSUFBSSxDQUFDLFdBQVc7U0FDYixDQUFDLENBQUE7UUFDZCxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFBO0lBQzVCLENBQUM7Q0FDRjtBQTNCRCw0Q0EyQkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudERpc3BhdGNoZXIgfSBmcm9tICdkZWNlbnRyYWxhbmQtcnBjL2xpYi9jb21tb24vY29yZS9FdmVudERpc3BhdGNoZXInXG5pbXBvcnQgeyBTY3JpcHRhYmxlU2NlbmUgfSBmcm9tICcuJ1xuXG5leHBvcnQgaW50ZXJmYWNlIElNZXNzYWdlIHtcbiAgZXZlbnQ6IHN0cmluZ1xuICBhcmdzOiBhbnlbXVxuICBzZW5kZXI6IHN0cmluZ1xufVxuXG4vKipcbiAqIE1lc3NhZ2VCdXNDbGllbnQgcHJvdmlkZXMgYW4gZWFzeSB3YXkgdG8gc2VuZCBhbmQgcmV2ZWl2ZSBwZWVyIHRvIHBlZXJcbiAqIG1lc3NhZ2VzIHRocnUgdGhlIGNvbW11bmljYXRpb25zIGludGVyZmFjZSBvZiBEZWNlbnRyYWxhbmQuXG4gKlxuICogVGhlIHVzYWdlIGlzIHNpbXBsZSwgaXQgaW1wbGVtZW50cyBhIHB1Yi1zdWIgcGF0dGVybiB0aGF0IHNoYXJlcyBtZXNzYWdlc1xuICogdXNpbmcgdGhlIGNvbm5lY3Rpb24gdGhhdCBhbHJlYWR5IGV4aXN0cyBiZXR3ZWVuIHBlZXJzLlxuICpcbiAqIEBleGFtcGxlIGluc2lkZSB5b3VyIFNjcmlwdGFibGVTY2VuZVxuICogYGBgdHNcbiAqICAgbGV0IG1lc3NhZ2VCdXNDbGllbnQgPSBhd2FpdCBNZXNzYWdlQnVzQ2xpZW50LmFjcXVpcmVFc3RhdGVDaGFubmVsKHRoaXMpXG4gKiAgIG1lc3NhZ2VCdXNDbGllbnQub24oJ2EgbWVzc2FnZSBuYW1lJywgKG1lc3NhZ2UpID0+IHsuLi59KVxuICogICBtZXNzYWdlQnVzQ2xpZW50LmVtaXQoJ2EgbWVzc2FnZSBuYW1lJywgbWVzc2FnZSlcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgTWVzc2FnZUJ1c0NsaWVudDxUID0gYW55PiBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlcjxUPiB7XG4gIHByaXZhdGUgY29uc3RydWN0b3IocHJvdGVjdGVkIGFwaTogYW55LCBwcm90ZWN0ZWQgaWQ6IHN0cmluZywgcHJvdGVjdGVkIGJ1c0NsaWVudElkOiBzdHJpbmcpIHtcbiAgICBzdXBlcigpXG4gICAgYXBpW2BvbiR7dGhpcy5pZH1gXSgobWVzc2FnZTogSU1lc3NhZ2UpID0+IHtcbiAgICAgIGlmICh0aGlzLmJ1c0NsaWVudElkICE9PSBtZXNzYWdlLnNlbmRlcikge1xuICAgICAgICBzdXBlci5lbWl0KG1lc3NhZ2UuZXZlbnQsIC4uLm1lc3NhZ2UuYXJncylcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGFjcXVpcmVFc3RhdGVDaGFubmVsKHN5c3RlbTogU2NyaXB0YWJsZVNjZW5lKSB7XG4gICAgY29uc3QgYnVzSWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KVxuICAgIGNvbnN0IHsgTWVzc2FnZUJ1cyB9ID0gYXdhaXQgc3lzdGVtLmxvYWRBUElzKFsnTWVzc2FnZUJ1cyddKVxuXG4gICAgY29uc3QgYnVzID0gYXdhaXQgTWVzc2FnZUJ1cy5nZXRFc3RhdGVDaGFubmVsKClcblxuICAgIHJldHVybiBuZXcgTWVzc2FnZUJ1c0NsaWVudChNZXNzYWdlQnVzLCBidXMuaWQsIGJ1c0lkKVxuICB9XG5cbiAgZW1pdChldmVudDogc3RyaW5nLCAuLi5hcmdzOiBhbnlbXSkge1xuICAgIHRoaXMuYXBpW3RoaXMuaWRdKHtcbiAgICAgIGV2ZW50LFxuICAgICAgYXJncyxcbiAgICAgIHNlbmRlcjogdGhpcy5idXNDbGllbnRJZFxuICAgIH0gYXMgSU1lc3NhZ2UpXG4gICAgc3VwZXIuZW1pdChldmVudCwgLi4uYXJncylcbiAgfVxufVxuIl19\n\n//# sourceURL=webpack:///./node_modules/decentraland-api/lib/MessageBus.js?");

/***/ }),

/***/ "./node_modules/decentraland-api/lib/ScriptableScene.js":
/*!**************************************************************!*\
  !*** ./node_modules/decentraland-api/lib/ScriptableScene.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst decentraland_rpc_1 = __webpack_require__(/*! decentraland-rpc */ \"./node_modules/decentraland-rpc/lib/client/index.js\");\nconst future_1 = __webpack_require__(/*! ./utils/future */ \"./node_modules/decentraland-api/lib/utils/future.js\");\nconst handlers_1 = __webpack_require__(/*! ./handlers */ \"./node_modules/decentraland-api/lib/handlers.js\");\nconst interfaces_1 = __webpack_require__(/*! ./interfaces */ \"./node_modules/decentraland-api/lib/interfaces.js\");\nexports.defer = Promise.resolve().then.bind(Promise.resolve());\n/** Managed queue of dirty components to be re-rendered */\nlet items = [];\nfunction enqueueRender(scene) {\n    if (!scene._dirty) {\n        scene._dirty = true;\n        if (items.push(scene) === 1) {\n            exports.defer(rerender);\n        }\n    }\n}\nfunction rerender() {\n    let p;\n    const list = items;\n    items = [];\n    // tslint:disable-next-line:no-conditional-assignment\n    while ((p = list.pop())) {\n        if (p._dirty)\n            renderScriptableScene(p);\n    }\n}\nfunction filterNonFalsy($) {\n    return !!$;\n}\nlet currentFunctionMap;\nconst attrRegularExpression = /^on[A-Z]/;\n/**\n * This function finds recursively all the /on[A-Z]./ attributes that are also a\n * function, then it replaces the function by a UUID. It stores the reference in\n * the currentFunctionMap\n */\nfunction fixCallbacks(scene) {\n    currentFunctionMap = scene._functionMap;\n    if (!currentFunctionMap) {\n        currentFunctionMap = scene._functionMap = new Map();\n    }\n    else {\n        currentFunctionMap.clear();\n    }\n    if (scene._component) {\n        fixAttributes(scene._component);\n    }\n}\nfunction fixAttributes(node) {\n    if (node.attrs) {\n        for (let i in node.attrs) {\n            if (attrRegularExpression.test(i)) {\n                if (typeof node.attrs[i] === 'function') {\n                    const fn = node.attrs[i];\n                    const id = handlers_1.putHandler(fn);\n                    currentFunctionMap.set(id, fn);\n                    node.attrs[i] = id;\n                }\n            }\n        }\n    }\n    if (node.children) {\n        for (let i = 0; i < node.children.length; i++) {\n            fixAttributes(node.children[i]);\n        }\n    }\n}\nfunction recursiveRender(tree) {\n    if (typeof tree === 'string') {\n        // tslint:disable-next-line:no-console\n        console.error('Warning, you are trying to render a text');\n        return null;\n    }\n    if (typeof tree.tag === 'function') {\n        const hoc = tree.tag;\n        if (hoc.prototype && hoc.prototype.render) {\n            throw new Error('Only function components are allowed');\n        }\n        return hoc(Object.assign({}, tree.attrs, { children: tree.children }));\n    }\n    if (!tree || !tree.tag)\n        return null;\n    return {\n        tag: tree.tag,\n        attrs: tree.attrs,\n        children: tree.children.map(recursiveRender).filter(filterNonFalsy)\n    };\n}\nexports.recursiveRender = recursiveRender;\n/**\n * Render a ScriptableScene, triggering necessary lifecycle events and taking High-Order ScriptableScenes into account.\n * @param {ScriptableScene} scene\n * @internal\n */\nfunction renderScriptableScene(scene, force) {\n    let props = scene.props;\n    let state = scene.state;\n    let previousProps = scene.prevProps || props;\n    let previousState = scene.prevState || state;\n    let skip = false;\n    const isUpdate = !!scene._component;\n    // if updating\n    if (isUpdate) {\n        scene.props = previousProps;\n        scene.state = previousState;\n        if (!force && scene.shouldSceneUpdate && scene.shouldSceneUpdate(props, state) === false) {\n            skip = true;\n        }\n        scene.props = props;\n        scene.state = state;\n    }\n    scene.prevProps = scene.prevState = null;\n    scene._dirty = false;\n    if (!skip) {\n        let rendererResult = scene.render(props, state);\n        if (!('then' in rendererResult && 'catch' in rendererResult)) {\n            rendererResult = Promise.resolve(rendererResult);\n        }\n        rendererResult\n            .then(recursiveRender)\n            .then(async (rendered) => {\n            if (!rendered) {\n                throw new Error('the async render() method yielded an empty result');\n            }\n            scene._component = rendered;\n            // replace functions by uuids\n            fixCallbacks(scene);\n            if (scene.sceneDidUpdate) {\n                await scene.sceneDidUpdate(previousProps, previousState);\n            }\n            await scene.connectionFuture;\n            try {\n                // TODO(agus): diff/patch\n                await scene.entityController.render(rendered);\n            }\n            catch (e) {\n                if (e.message === interfaces_1.Constants.ReplaceWholeTreeException) {\n                    await scene.entityController.render(rendered);\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .catch(err => {\n            // tslint:disable-next-line:no-console\n            console.error(err);\n        });\n    }\n}\nexports.renderScriptableScene = renderScriptableScene;\n/**\n * Base Scene class.\n * Provides `setState()` and `forceUpdate()`, which trigger rendering.\n * @public\n *\n * @example\n * class MyFoo extends ScriptableScene {\n *   async render() {\n *     return <sphere />;\n *   }\n * }\n */\nclass ScriptableScene extends decentraland_rpc_1.Script {\n    constructor() {\n        super(...arguments);\n        // @internal\n        this._dirty = true;\n        // @internal\n        this._functionMap = new Map();\n        // @internal\n        this.prevProps = null;\n        // @internal\n        this.prevState = null;\n        // @internal\n        this._component = null;\n        this.state = {};\n        // @internal\n        this.connectionFuture = future_1.future();\n        // @internal\n        this.receiveClickEvent = (event) => {\n            const map = this._functionMap;\n            if (map) {\n                const fn = map.get(event.data.uuid);\n                if (fn) {\n                    fn(event.data.payload);\n                }\n            }\n        };\n    }\n    /**\n     * Update scene state by copying properties from `state` to `this.state`.\n     * @param {object} state A hash of state properties to update with new values\n     */\n    setState(state) {\n        let s = this.state;\n        if (!this.prevState)\n            this.prevState = Object.assign({}, s);\n        Object.assign(s, typeof state === 'function' ? state(s, this.props) : state);\n        enqueueRender(this);\n    }\n    /**\n     * Immediately perform a synchronous re-render of the component.\n     */\n    forceUpdate() {\n        renderScriptableScene(this, true);\n    }\n    /**\n     * It makes a subscription to remote events, those events occur in the context of the game and are sent thru the wire\n     * protocol.\n     *\n     * @param event name of the remote event to listen\n     * @param handler an async\n     */\n    subscribeTo(event, handler) {\n        // tslint:disable-next-line:no-floating-promises\n        this.connectionFuture.then(() => {\n            this.eventSubscriber.on(event, x => {\n                const ret = handler(x.data);\n                if (ret && 'catch' in ret && typeof ret.catch === 'function') {\n                    ret.catch(err => this.emit('error', err));\n                }\n            });\n        });\n    }\n    /**\n     * Get a standard ethereum provider\n     * Please notice this is highly experimental and might change in the future.\n     *\n     * method whitelist = [\n     *   'eth_sendTransaction',\n     *   'eth_getTransactionReceipt',\n     *   'eth_estimateGas',\n     *   'eth_call',\n     *   'eth_getBalance',\n     *   'eth_getStorageAt',\n     *   'eth_blockNumber',\n     *   'eth_getBlockByNumber',\n     *   'eth_gasPrice',\n     *   'eth_protocolVersion',\n     *   'net_version',\n     *   'web3_sha3',\n     *   'web3_clientVersion',\n     *   'eth_getTransactionCount'\n     * ]\n     */\n    async getEthereumProvider() {\n        const { EthereumController } = await this.loadAPIs(['EthereumController']);\n        return {\n            // @internal\n            send(message, callback) {\n                if (message && callback && callback instanceof Function) {\n                    EthereumController.sendAsync(message)\n                        .then((x) => callback(null, x))\n                        .catch(callback);\n                }\n                else {\n                    throw new Error('Decentraland provider only allows async calls');\n                }\n            },\n            sendAsync(message, callback) {\n                EthereumController.sendAsync(message)\n                    .then((x) => callback(null, x))\n                    .catch(callback);\n            }\n        };\n    }\n    // @internal\n    async systemDidEnable() {\n        this.props = (await this.entityController.getOwnAttributes());\n        // we create an event subscriber\n        this.eventSubscriber = new decentraland_rpc_1.EventSubscriber(this.entityController);\n        this.on('SIGKILL', () => {\n            if (this.sceneWillUnmount) {\n                this.sceneWillUnmount();\n            }\n        });\n        this.subscribeTo('setAttributes', newProps => {\n            this.prevProps = this.props;\n            this.props = newProps;\n            enqueueRender(this);\n        });\n        this.connectionFuture.resolve(this);\n        renderScriptableScene(this, true);\n        this.eventSubscriber.on('uuidEvent', this.receiveClickEvent);\n        if (this.sceneDidMount) {\n            await this.sceneDidMount();\n        }\n    }\n}\n__decorate([\n    decentraland_rpc_1.inject('EntityController'),\n    __metadata(\"design:type\", Object)\n], ScriptableScene.prototype, \"entityController\", void 0);\nexports.ScriptableScene = ScriptableScene;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2NyaXB0YWJsZVNjZW5lLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL1NjcmlwdGFibGVTY2VuZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLHVEQUFrRTtBQUNsRSwyQ0FBdUM7QUFDdkMseUNBQXVDO0FBQ3ZDLDZDQUF5RDtBQUk1QyxRQUFBLEtBQUssR0FBRyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQTtBQUVuRSwwREFBMEQ7QUFFMUQsSUFBSSxLQUFLLEdBQWdDLEVBQUUsQ0FBQTtBQUUzQyxTQUFTLGFBQWEsQ0FBTyxLQUE0QjtJQUN2RCxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRTtRQUNqQixLQUFLLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQTtRQUNuQixJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQzNCLGFBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQTtTQUNoQjtLQUNGO0FBQ0gsQ0FBQztBQUVELFNBQVMsUUFBUTtJQUNmLElBQUksQ0FBOEIsQ0FBQTtJQUNsQyxNQUFNLElBQUksR0FBc0IsS0FBSyxDQUFBO0lBQ3JDLEtBQUssR0FBRyxFQUFFLENBQUE7SUFDVixxREFBcUQ7SUFDckQsT0FBTyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRTtRQUN2QixJQUFJLENBQUMsQ0FBQyxNQUFNO1lBQUUscUJBQXFCLENBQUMsQ0FBQyxDQUFDLENBQUE7S0FDdkM7QUFDSCxDQUFDO0FBRUQsU0FBUyxjQUFjLENBQUMsQ0FBTTtJQUM1QixPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUE7QUFDWixDQUFDO0FBRUQsSUFBSSxrQkFBeUMsQ0FBQTtBQUM3QyxNQUFNLHFCQUFxQixHQUFHLFVBQVUsQ0FBQTtBQUV4Qzs7OztHQUlH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Ozt5REFDUTtBQUhyQywwQ0E0SkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTY3JpcHQsIGluamVjdCwgRXZlbnRTdWJzY3JpYmVyIH0gZnJvbSAnZGVjZW50cmFsYW5kLXJwYydcbmltcG9ydCB7IGZ1dHVyZSB9IGZyb20gJy4vdXRpbHMvZnV0dXJlJ1xuaW1wb3J0IHsgcHV0SGFuZGxlciB9IGZyb20gJy4vaGFuZGxlcnMnXG5pbXBvcnQgeyBJU2ltcGxpZmllZE5vZGUsIENvbnN0YW50cyB9IGZyb20gJy4vaW50ZXJmYWNlcydcbmltcG9ydCB7IEVudGl0eUNvbnRyb2xsZXIsIFJQQ1NlbmRhYmxlTWVzc2FnZSB9IGZyb20gJy4vYXBpcydcbmltcG9ydCB7IElFdmVudE5hbWVzLCBJRXZlbnRzIH0gZnJvbSAnLi9ldmVudHMnXG5cbmV4cG9ydCBjb25zdCBkZWZlciA9IFByb21pc2UucmVzb2x2ZSgpLnRoZW4uYmluZChQcm9taXNlLnJlc29sdmUoKSlcblxuLyoqIE1hbmFnZWQgcXVldWUgb2YgZGlydHkgY29tcG9uZW50cyB0byBiZSByZS1yZW5kZXJlZCAqL1xuXG5sZXQgaXRlbXM6IFNjcmlwdGFibGVTY2VuZTxhbnksIGFueT5bXSA9IFtdXG5cbmZ1bmN0aW9uIGVucXVldWVSZW5kZXI8RCwgVD4oc2NlbmU6IFNjcmlwdGFibGVTY2VuZTxELCBUPikge1xuICBpZiAoIXNjZW5lLl9kaXJ0eSkge1xuICAgIHNjZW5lLl9kaXJ0eSA9IHRydWVcbiAgICBpZiAoaXRlbXMucHVzaChzY2VuZSkgPT09IDEpIHtcbiAgICAgIGRlZmVyKHJlcmVuZGVyKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXJlbmRlcigpIHtcbiAgbGV0IHA6IFNjcmlwdGFibGVTY2VuZSB8IHVuZGVmaW5lZFxuICBjb25zdCBsaXN0OiBTY3JpcHRhYmxlU2NlbmVbXSA9IGl0ZW1zXG4gIGl0ZW1zID0gW11cbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbmRpdGlvbmFsLWFzc2lnbm1lbnRcbiAgd2hpbGUgKChwID0gbGlzdC5wb3AoKSkpIHtcbiAgICBpZiAocC5fZGlydHkpIHJlbmRlclNjcmlwdGFibGVTY2VuZShwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbHRlck5vbkZhbHN5KCQ6IGFueSk6ICQgaXMgdHJ1ZSB7XG4gIHJldHVybiAhISRcbn1cblxubGV0IGN1cnJlbnRGdW5jdGlvbk1hcDogTWFwPHN0cmluZywgRnVuY3Rpb24+XG5jb25zdCBhdHRyUmVndWxhckV4cHJlc3Npb24gPSAvXm9uW0EtWl0vXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBmaW5kcyByZWN1cnNpdmVseSBhbGwgdGhlIC9vbltBLVpdLi8gYXR0cmlidXRlcyB0aGF0IGFyZSBhbHNvIGFcbiAqIGZ1bmN0aW9uLCB0aGVuIGl0IHJlcGxhY2VzIHRoZSBmdW5jdGlvbiBieSBhIFVVSUQuIEl0IHN0b3JlcyB0aGUgcmVmZXJlbmNlIGluXG4gKiB0aGUgY3VycmVudEZ1bmN0aW9uTWFwXG4gKi9cbmZ1bmN0aW9uIGZpeENhbGxiYWNrcyhzY2VuZTogU2NyaXB0YWJsZVNjZW5lPGFueSwgYW55Pikge1xuICBjdXJyZW50RnVuY3Rpb25NYXAgPSBzY2VuZS5fZnVuY3Rpb25NYXBcblxuICBpZiAoIWN1cnJlbnRGdW5jdGlvbk1hcCkge1xuICAgIGN1cnJlbnRGdW5jdGlvbk1hcCA9IHNjZW5lLl9mdW5jdGlvbk1hcCA9IG5ldyBNYXAoKVxuICB9IGVsc2Uge1xuICAgIGN1cnJlbnRGdW5jdGlvbk1hcC5jbGVhcigpXG4gIH1cblxuICBpZiAoc2NlbmUuX2NvbXBvbmVudCkge1xuICAgIGZpeEF0dHJpYnV0ZXMoc2NlbmUuX2NvbXBvbmVudClcbiAgfVxufVxuXG5mdW5jdGlvbiBmaXhBdHRyaWJ1dGVzKG5vZGU6IElTaW1wbGlmaWVkTm9kZSkge1xuICBpZiAobm9kZS5hdHRycykge1xuICAgIGZvciAobGV0IGkgaW4gbm9kZS5hdHRycykge1xuICAgICAgaWYgKGF0dHJSZWd1bGFyRXhwcmVzc2lvbi50ZXN0KGkpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZS5hdHRyc1tpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNvbnN0IGZuOiBhbnkgPSBub2RlLmF0dHJzW2ldXG4gICAgICAgICAgY29uc3QgaWQgPSBwdXRIYW5kbGVyKGZuKVxuICAgICAgICAgIGN1cnJlbnRGdW5jdGlvbk1hcC5zZXQoaWQsIGZuKVxuICAgICAgICAgIG5vZGUuYXR0cnNbaV0gPSBpZFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZpeEF0dHJpYnV0ZXMobm9kZS5jaGlsZHJlbltpXSlcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlY3Vyc2l2ZVJlbmRlcih0cmVlOiBJU2ltcGxpZmllZE5vZGUpOiBJU2ltcGxpZmllZE5vZGUgfCBudWxsIHtcbiAgaWYgKHR5cGVvZiB0cmVlID09PSAnc3RyaW5nJykge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgY29uc29sZS5lcnJvcignV2FybmluZywgeW91IGFyZSB0cnlpbmcgdG8gcmVuZGVyIGEgdGV4dCcpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGlmICh0eXBlb2YgKHRyZWUudGFnIGFzIGFueSkgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCBob2MgPSAodHJlZS50YWcgYXMgYW55KSBhcyBGdW5jdGlvblxuICAgIGlmIChob2MucHJvdG90eXBlICYmIGhvYy5wcm90b3R5cGUucmVuZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgZnVuY3Rpb24gY29tcG9uZW50cyBhcmUgYWxsb3dlZCcpXG4gICAgfVxuICAgIHJldHVybiBob2MoeyAuLi50cmVlLmF0dHJzLCBjaGlsZHJlbjogdHJlZS5jaGlsZHJlbiB9KVxuICB9XG5cbiAgaWYgKCF0cmVlIHx8ICF0cmVlLnRhZykgcmV0dXJuIG51bGxcblxuICByZXR1cm4ge1xuICAgIHRhZzogdHJlZS50YWcsXG4gICAgYXR0cnM6IHRyZWUuYXR0cnMsXG4gICAgY2hpbGRyZW46ICh0cmVlLmNoaWxkcmVuLm1hcChyZWN1cnNpdmVSZW5kZXIpLmZpbHRlcihmaWx0ZXJOb25GYWxzeSkgYXMgYW55KSBhcyBJU2ltcGxpZmllZE5vZGVbXVxuICB9XG59XG5cbi8qKlxuICogUmVuZGVyIGEgU2NyaXB0YWJsZVNjZW5lLCB0cmlnZ2VyaW5nIG5lY2Vzc2FyeSBsaWZlY3ljbGUgZXZlbnRzIGFuZCB0YWtpbmcgSGlnaC1PcmRlciBTY3JpcHRhYmxlU2NlbmVzIGludG8gYWNjb3VudC5cbiAqIEBwYXJhbSB7U2NyaXB0YWJsZVNjZW5lfSBzY2VuZVxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJTY3JpcHRhYmxlU2NlbmU8UHJvcHMsIFN0YXRlPihzY2VuZTogU2NyaXB0YWJsZVNjZW5lPFByb3BzLCBTdGF0ZT4sIGZvcmNlPzogYm9vbGVhbikge1xuICBsZXQgcHJvcHMgPSBzY2VuZS5wcm9wc1xuICBsZXQgc3RhdGUgPSBzY2VuZS5zdGF0ZVxuICBsZXQgcHJldmlvdXNQcm9wcyA9IHNjZW5lLnByZXZQcm9wcyB8fCBwcm9wc1xuICBsZXQgcHJldmlvdXNTdGF0ZSA9IHNjZW5lLnByZXZTdGF0ZSB8fCBzdGF0ZVxuICBsZXQgc2tpcCA9IGZhbHNlXG4gIGNvbnN0IGlzVXBkYXRlID0gISFzY2VuZS5fY29tcG9uZW50XG5cbiAgLy8gaWYgdXBkYXRpbmdcbiAgaWYgKGlzVXBkYXRlKSB7XG4gICAgc2NlbmUucHJvcHMgPSBwcmV2aW91c1Byb3BzXG4gICAgc2NlbmUuc3RhdGUgPSBwcmV2aW91c1N0YXRlXG4gICAgaWYgKCFmb3JjZSAmJiBzY2VuZS5zaG91bGRTY2VuZVVwZGF0ZSAmJiBzY2VuZS5zaG91bGRTY2VuZVVwZGF0ZShwcm9wcywgc3RhdGUpID09PSBmYWxzZSkge1xuICAgICAgc2tpcCA9IHRydWVcbiAgICB9XG4gICAgc2NlbmUucHJvcHMgPSBwcm9wc1xuICAgIHNjZW5lLnN0YXRlID0gc3RhdGVcbiAgfVxuXG4gIHNjZW5lLnByZXZQcm9wcyA9IHNjZW5lLnByZXZTdGF0ZSA9IG51bGxcbiAgc2NlbmUuX2RpcnR5ID0gZmFsc2VcblxuICBpZiAoIXNraXApIHtcbiAgICBsZXQgcmVuZGVyZXJSZXN1bHQgPSBzY2VuZS5yZW5kZXIocHJvcHMsIHN0YXRlKVxuXG4gICAgaWYgKCEoJ3RoZW4nIGluIHJlbmRlcmVyUmVzdWx0ICYmICdjYXRjaCcgaW4gcmVuZGVyZXJSZXN1bHQpKSB7XG4gICAgICByZW5kZXJlclJlc3VsdCA9IFByb21pc2UucmVzb2x2ZShyZW5kZXJlclJlc3VsdClcbiAgICB9XG5cbiAgICByZW5kZXJlclJlc3VsdFxuICAgICAgLnRoZW4ocmVjdXJzaXZlUmVuZGVyKVxuICAgICAgLnRoZW4oYXN5bmMgcmVuZGVyZWQgPT4ge1xuICAgICAgICBpZiAoIXJlbmRlcmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgYXN5bmMgcmVuZGVyKCkgbWV0aG9kIHlpZWxkZWQgYW4gZW1wdHkgcmVzdWx0JylcbiAgICAgICAgfVxuXG4gICAgICAgIHNjZW5lLl9jb21wb25lbnQgPSByZW5kZXJlZFxuXG4gICAgICAgIC8vIHJlcGxhY2UgZnVuY3Rpb25zIGJ5IHV1aWRzXG4gICAgICAgIGZpeENhbGxiYWNrcyhzY2VuZSlcblxuICAgICAgICBpZiAoc2NlbmUuc2NlbmVEaWRVcGRhdGUpIHtcbiAgICAgICAgICBhd2FpdCBzY2VuZS5zY2VuZURpZFVwZGF0ZShwcmV2aW91c1Byb3BzLCBwcmV2aW91c1N0YXRlKVxuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgc2NlbmUuY29ubmVjdGlvbkZ1dHVyZVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVE9ETyhhZ3VzKTogZGlmZi9wYXRjaFxuICAgICAgICAgIGF3YWl0IHNjZW5lLmVudGl0eUNvbnRyb2xsZXIucmVuZGVyKHJlbmRlcmVkKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGUubWVzc2FnZSA9PT0gQ29uc3RhbnRzLlJlcGxhY2VXaG9sZVRyZWVFeGNlcHRpb24pIHtcbiAgICAgICAgICAgIGF3YWl0IHNjZW5lLmVudGl0eUNvbnRyb2xsZXIucmVuZGVyKHJlbmRlcmVkKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKVxuICAgICAgfSlcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNjcmlwdGFibGVTY2VuZTxQcm9wcywgU3RhdGU+IHtcbiAgcHJvcHM6IFByb3BzXG4gIHN0YXRlOiBTdGF0ZVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGNoYW5nZSBpbiBwcm9wcyBhbmQgc3RhdGUgc2hvdWxkIHRyaWdnZXIgYSByZS1yZW5kZXIuXG4gICAqXG4gICAqIElmIGZhbHNlIGlzIHJldHVybmVkLCBgU2NyaXB0YWJsZVNjZW5lI3JlbmRlcmAsIGFuZCBgc2NlbmVEaWRVcGRhdGVgIHdpbGwgbm90IGJlIGNhbGxlZC5cbiAgICovXG4gIHNob3VsZFNjZW5lVXBkYXRlPyhuZXh0UHJvcHM6IFByb3BzLCBuZXh0U3RhdGU6IFN0YXRlKTogUHJvbWlzZTxib29sZWFuPiB8IGJvb2xlYW5cblxuICAvKipcbiAgICogQ2FsbGVkIGltbWVkaWF0ZWx5IGJlZm9yZSBhIHNjZW5lIGlzIGRlc3Ryb3llZC4gUGVyZm9ybSBhbnkgbmVjZXNzYXJ5IGNsZWFudXAgaW4gdGhpcyBtZXRob2QsIHN1Y2ggYXNcbiAgICogY2FuY2VsbGVkIG5ldHdvcmsgcmVxdWVzdHMsIG9yIGNsZWFuaW5nIHVwIGFueSBlbGVtZW50cyBjcmVhdGVkIGluIGBzY2VuZURpZE1vdW50YC5cbiAgICovXG4gIHNjZW5lV2lsbFVubW91bnQ/KCk6IFByb21pc2U8dm9pZD4gfCB2b2lkXG5cbiAgLyoqXG4gICAqIENhbGxlZCBpbW1lZGlhdGVseSBhZnRlciBhIGNvbXBvbWVudCBpcyBtb3VudGVkLiBTZXR0aW5nIHN0YXRlIGhlcmUgd2lsbCB0cmlnZ2VyIHJlLXJlbmRlcmluZy5cbiAgICovXG4gIHNjZW5lRGlkTW91bnQ/KCk6IFByb21pc2U8dm9pZD4gfCB2b2lkXG5cbiAgLyoqXG4gICAqIENhbGxlZCBpbW1lZGlhdGVseSBhZnRlciB1cGRhdGluZyBvY2N1cnMuIE5vdCBjYWxsZWQgZm9yIHRoZSBpbml0aWFsIHJlbmRlci5cbiAgICovXG4gIHNjZW5lRGlkVXBkYXRlPyhwcmV2UHJvcHM6IFJlYWRvbmx5PFByb3BzPiwgcHJldlN0YXRlOiBSZWFkb25seTxTdGF0ZT4pOiBQcm9taXNlPHZvaWQ+IHwgdm9pZFxufVxuXG4vKipcbiAqIEJhc2UgU2NlbmUgY2xhc3MuXG4gKiBQcm92aWRlcyBgc2V0U3RhdGUoKWAgYW5kIGBmb3JjZVVwZGF0ZSgpYCwgd2hpY2ggdHJpZ2dlciByZW5kZXJpbmcuXG4gKiBAcHVibGljXG4gKlxuICogQGV4YW1wbGVcbiAqIGNsYXNzIE15Rm9vIGV4dGVuZHMgU2NyaXB0YWJsZVNjZW5lIHtcbiAqICAgYXN5bmMgcmVuZGVyKCkge1xuICogICAgIHJldHVybiA8c3BoZXJlIC8+O1xuICogICB9XG4gKiB9XG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTY3JpcHRhYmxlU2NlbmU8UHJvcHMgPSB7fSwgU3RhdGUgPSB7fT4gZXh0ZW5kcyBTY3JpcHQge1xuICAvLyBAaW50ZXJuYWxcbiAgQGluamVjdCgnRW50aXR5Q29udHJvbGxlcicpXG4gIGVudGl0eUNvbnRyb2xsZXIhOiBFbnRpdHlDb250cm9sbGVyXG5cbiAgZXZlbnRTdWJzY3JpYmVyITogRXZlbnRTdWJzY3JpYmVyXG5cbiAgLy8gQGludGVybmFsXG4gIF9kaXJ0eSA9IHRydWVcbiAgLy8gQGludGVybmFsXG4gIF9mdW5jdGlvbk1hcCA9IG5ldyBNYXA8c3RyaW5nLCBGdW5jdGlvbj4oKVxuICAvLyBAaW50ZXJuYWxcbiAgcHJldlByb3BzOiBQcm9wcyB8IG51bGwgPSBudWxsXG4gIC8vIEBpbnRlcm5hbFxuICBwcmV2U3RhdGU6IFN0YXRlIHwgbnVsbCA9IG51bGxcbiAgLy8gQGludGVybmFsXG4gIF9jb21wb25lbnQ6IElTaW1wbGlmaWVkTm9kZSB8IG51bGwgPSBudWxsXG5cbiAgc3RhdGU6IFN0YXRlID0ge30gYXMgU3RhdGVcblxuICAvLyBAaW50ZXJuYWxcbiAgY29ubmVjdGlvbkZ1dHVyZSA9IGZ1dHVyZTxTY3JpcHQ+KClcblxuICBwcm9wcyE6IFByb3BzXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBzY2VuZSBzdGF0ZSBieSBjb3B5aW5nIHByb3BlcnRpZXMgZnJvbSBgc3RhdGVgIHRvIGB0aGlzLnN0YXRlYC5cbiAgICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIEEgaGFzaCBvZiBzdGF0ZSBwcm9wZXJ0aWVzIHRvIHVwZGF0ZSB3aXRoIG5ldyB2YWx1ZXNcbiAgICovXG4gIHNldFN0YXRlKHN0YXRlOiBQYXJ0aWFsPFN0YXRlPiB8ICgoc3RhdGU6IFN0YXRlLCBwcm9wczogUHJvcHMpID0+IFBhcnRpYWw8U3RhdGU+KSk6IHZvaWQge1xuICAgIGxldCBzID0gdGhpcy5zdGF0ZVxuICAgIGlmICghdGhpcy5wcmV2U3RhdGUpIHRoaXMucHJldlN0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgcylcbiAgICBPYmplY3QuYXNzaWduKHMsIHR5cGVvZiBzdGF0ZSA9PT0gJ2Z1bmN0aW9uJyA/IHN0YXRlKHMsIHRoaXMucHJvcHMpIDogc3RhdGUpXG4gICAgZW5xdWV1ZVJlbmRlcih0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIEltbWVkaWF0ZWx5IHBlcmZvcm0gYSBzeW5jaHJvbm91cyByZS1yZW5kZXIgb2YgdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIGZvcmNlVXBkYXRlKCkge1xuICAgIHJlbmRlclNjcmlwdGFibGVTY2VuZSh0aGlzLCB0cnVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdHMgYHByb3BzYCBhbmQgYHN0YXRlYCwgYW5kIHJldHVybnMgYSBuZXcgVmlydHVhbCBET00gdHJlZSB0byBidWlsZC5cbiAgICogVmlydHVhbCBET00gaXMgZ2VuZXJhbGx5IGNvbnN0cnVjdGVkIHZpYSBbSlNYXShodHRwOi8vamFzb25mb3JtYXQuY29tL3d0Zi1pcy1qc3gpLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgICAgUHJvcHMgKGVnOiBKU1ggYXR0cmlidXRlcykgcmVjZWl2ZWQgZnJvbSBwYXJlbnQgZWxlbWVudC9jb21wb25lbnRcbiAgICogQHBhcmFtIHtvYmplY3R9IHN0YXRlICAgIFRoZSBjb21wb25lbnQncyBjdXJyZW50IHN0YXRlXG4gICAqL1xuICBhYnN0cmFjdCBhc3luYyByZW5kZXIocHJvcHM6IFByb3BzLCBzdGF0ZTogU3RhdGUpOiBQcm9taXNlPElTaW1wbGlmaWVkTm9kZT5cblxuICAvKipcbiAgICogSXQgbWFrZXMgYSBzdWJzY3JpcHRpb24gdG8gcmVtb3RlIGV2ZW50cywgdGhvc2UgZXZlbnRzIG9jY3VyIGluIHRoZSBjb250ZXh0IG9mIHRoZSBnYW1lIGFuZCBhcmUgc2VudCB0aHJ1IHRoZSB3aXJlXG4gICAqIHByb3RvY29sLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgbmFtZSBvZiB0aGUgcmVtb3RlIGV2ZW50IHRvIGxpc3RlblxuICAgKiBAcGFyYW0gaGFuZGxlciBhbiBhc3luY1xuICAgKi9cbiAgc3Vic2NyaWJlVG88VCBleHRlbmRzIElFdmVudE5hbWVzPihldmVudDogVCwgaGFuZGxlcjogKGRhdGE6IElFdmVudHNbVF0pID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+KSB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgdGhpcy5jb25uZWN0aW9uRnV0dXJlLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5ldmVudFN1YnNjcmliZXIub24oZXZlbnQsIHggPT4ge1xuICAgICAgICBjb25zdCByZXQgPSBoYW5kbGVyKHguZGF0YSlcbiAgICAgICAgaWYgKHJldCAmJiAnY2F0Y2gnIGluIHJldCAmJiB0eXBlb2YgcmV0LmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0LmNhdGNoKGVyciA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHN0YW5kYXJkIGV0aGVyZXVtIHByb3ZpZGVyXG4gICAqIFBsZWFzZSBub3RpY2UgdGhpcyBpcyBoaWdobHkgZXhwZXJpbWVudGFsIGFuZCBtaWdodCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cbiAgICpcbiAgICogbWV0aG9kIHdoaXRlbGlzdCA9IFtcbiAgICogICAnZXRoX3NlbmRUcmFuc2FjdGlvbicsXG4gICAqICAgJ2V0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHQnLFxuICAgKiAgICdldGhfZXN0aW1hdGVHYXMnLFxuICAgKiAgICdldGhfY2FsbCcsXG4gICAqICAgJ2V0aF9nZXRCYWxhbmNlJyxcbiAgICogICAnZXRoX2dldFN0b3JhZ2VBdCcsXG4gICAqICAgJ2V0aF9ibG9ja051bWJlcicsXG4gICAqICAgJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJyxcbiAgICogICAnZXRoX2dhc1ByaWNlJyxcbiAgICogICAnZXRoX3Byb3RvY29sVmVyc2lvbicsXG4gICAqICAgJ25ldF92ZXJzaW9uJyxcbiAgICogICAnd2ViM19zaGEzJyxcbiAgICogICAnd2ViM19jbGllbnRWZXJzaW9uJyxcbiAgICogICAnZXRoX2dldFRyYW5zYWN0aW9uQ291bnQnXG4gICAqIF1cbiAgICovXG4gIGFzeW5jIGdldEV0aGVyZXVtUHJvdmlkZXIoKSB7XG4gICAgY29uc3QgeyBFdGhlcmV1bUNvbnRyb2xsZXIgfSA9IGF3YWl0IHRoaXMubG9hZEFQSXMoWydFdGhlcmV1bUNvbnRyb2xsZXInXSlcblxuICAgIHJldHVybiB7XG4gICAgICAvLyBAaW50ZXJuYWxcbiAgICAgIHNlbmQobWVzc2FnZTogUlBDU2VuZGFibGVNZXNzYWdlLCBjYWxsYmFjaz86IChlcnJvcjogRXJyb3IgfCBudWxsLCByZXN1bHQ/OiBhbnkpID0+IHZvaWQpOiB2b2lkIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UgJiYgY2FsbGJhY2sgJiYgY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgIEV0aGVyZXVtQ29udHJvbGxlci5zZW5kQXN5bmMobWVzc2FnZSlcbiAgICAgICAgICAgIC50aGVuKCh4OiBhbnkpID0+IGNhbGxiYWNrKG51bGwsIHgpKVxuICAgICAgICAgICAgLmNhdGNoKGNhbGxiYWNrKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjZW50cmFsYW5kIHByb3ZpZGVyIG9ubHkgYWxsb3dzIGFzeW5jIGNhbGxzJylcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNlbmRBc3luYyhtZXNzYWdlOiBSUENTZW5kYWJsZU1lc3NhZ2UsIGNhbGxiYWNrOiAoZXJyb3I6IEVycm9yIHwgbnVsbCwgcmVzdWx0PzogYW55KSA9PiB2b2lkKTogdm9pZCB7XG4gICAgICAgIEV0aGVyZXVtQ29udHJvbGxlci5zZW5kQXN5bmMobWVzc2FnZSlcbiAgICAgICAgICAudGhlbigoeDogYW55KSA9PiBjYWxsYmFjayhudWxsLCB4KSlcbiAgICAgICAgICAuY2F0Y2goY2FsbGJhY2spXG4gICAgICB9XG4gICAgfSBhcyB7XG4gICAgICBzZW5kOiBGdW5jdGlvblxuICAgICAgc2VuZEFzeW5jOiBGdW5jdGlvblxuICAgIH1cbiAgfVxuXG4gIC8vIEBpbnRlcm5hbFxuICByZWNlaXZlQ2xpY2tFdmVudCA9IChldmVudDogYW55KSA9PiB7XG4gICAgY29uc3QgbWFwOiBNYXA8c3RyaW5nLCBGdW5jdGlvbj4gPSB0aGlzLl9mdW5jdGlvbk1hcFxuICAgIGlmIChtYXApIHtcbiAgICAgIGNvbnN0IGZuID0gbWFwLmdldChldmVudC5kYXRhLnV1aWQpXG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgZm4oZXZlbnQuZGF0YS5wYXlsb2FkKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEBpbnRlcm5hbFxuICBhc3luYyBzeXN0ZW1EaWRFbmFibGUoKSB7XG4gICAgdGhpcy5wcm9wcyA9IChhd2FpdCB0aGlzLmVudGl0eUNvbnRyb2xsZXIuZ2V0T3duQXR0cmlidXRlcygpKSBhcyBQcm9wc1xuXG4gICAgLy8gd2UgY3JlYXRlIGFuIGV2ZW50IHN1YnNjcmliZXJcbiAgICB0aGlzLmV2ZW50U3Vic2NyaWJlciA9IG5ldyBFdmVudFN1YnNjcmliZXIodGhpcy5lbnRpdHlDb250cm9sbGVyKVxuXG4gICAgdGhpcy5vbignU0lHS0lMTCcsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnNjZW5lV2lsbFVubW91bnQpIHtcbiAgICAgICAgdGhpcy5zY2VuZVdpbGxVbm1vdW50KClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5zdWJzY3JpYmVUbygnc2V0QXR0cmlidXRlcycsIG5ld1Byb3BzID0+IHtcbiAgICAgIHRoaXMucHJldlByb3BzID0gdGhpcy5wcm9wc1xuICAgICAgdGhpcy5wcm9wcyA9IG5ld1Byb3BzIGFzIFByb3BzXG4gICAgICBlbnF1ZXVlUmVuZGVyKHRoaXMpXG4gICAgfSlcblxuICAgIHRoaXMuY29ubmVjdGlvbkZ1dHVyZS5yZXNvbHZlKHRoaXMpXG5cbiAgICByZW5kZXJTY3JpcHRhYmxlU2NlbmUodGhpcywgdHJ1ZSlcblxuICAgIHRoaXMuZXZlbnRTdWJzY3JpYmVyLm9uKCd1dWlkRXZlbnQnLCB0aGlzLnJlY2VpdmVDbGlja0V2ZW50KVxuXG4gICAgaWYgKHRoaXMuc2NlbmVEaWRNb3VudCkge1xuICAgICAgYXdhaXQgdGhpcy5zY2VuZURpZE1vdW50KClcbiAgICB9XG4gIH1cbn1cbiJdfQ==\n\n//# sourceURL=webpack:///./node_modules/decentraland-api/lib/ScriptableScene.js?");

/***/ }),

/***/ "./node_modules/decentraland-api/lib/events.js":
/*!*****************************************************!*\
  !*** ./node_modules/decentraland-api/lib/events.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction createEvent(event, data) {\n    return { event, data };\n}\nexports.createEvent = createEvent;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXZlbnRzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2V2ZW50cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQXdGQSxTQUFnQixXQUFXLENBQXdCLEtBQVEsRUFBRSxJQUFnQjtJQUMzRSxPQUFPLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxDQUFBO0FBQ3hCLENBQUM7QUFGRCxrQ0FFQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZlY3RvcjNDb21wb25lbnQsIFF1YXRlcm5pb24gfSBmcm9tICcuL2ludGVyZmFjZXMnXG5cbmV4cG9ydCB0eXBlIFBvaW50ZXJFdmVudCA9IHtcbiAgLyoqIE9yaWdpbiBvZiB0aGUgcmF5ICovXG4gIGZyb206IFZlY3RvcjNDb21wb25lbnRcbiAgLyoqIERpcmVjdGlvbiB2ZWN0b3Igb2YgdGhlIHJheSAobm9ybWFsaXplZCkgKi9cbiAgZGlyZWN0aW9uOiBWZWN0b3IzQ29tcG9uZW50XG4gIC8qKiBMZW5ndGggb2YgdGhlIHJheSAqL1xuICBsZW5ndGg6IG51bWJlclxuICAvKiogSUQgb2YgdGhlIHBvaW50ZXIgdGhhdCB0cmlnZ2VyZWQgdGhlIGV2ZW50ICovXG4gIHBvaW50ZXJJZDogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUV2ZW50cyB7XG4gIC8qKlxuICAgKiBgcG9zaXRpb25DaGFuZ2VkYCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgcG9zaXRpb24gb2YgdGhlIGNhbWVyYSBjaGFuZ2VzXG4gICAqIFRoaXMgZXZlbnQgaXMgdGhyb3R0bGVkIHRvIDEwIHRpbWVzIHBlciBzZWNvbmQuXG4gICAqL1xuICBwb3NpdGlvbkNoYW5nZWQ6IHtcbiAgICAvKiogUG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIGJhc2UgcGFyY2VsIG9mIHRoZSBzY2VuZSAqL1xuICAgIHBvc2l0aW9uOiBWZWN0b3IzQ29tcG9uZW50XG5cbiAgICAvKiogQ2FtZXJhIHBvc2l0aW9uLCB0aGlzIGlzIGEgYWJzb2x1dGUgd29ybGQgcG9zaXRpb24gKi9cbiAgICBjYW1lcmFQb3NpdGlvbjogVmVjdG9yM0NvbXBvbmVudFxuXG4gICAgLyoqIEV5ZSBoZWlnaHQsIGluIG1ldGVycy4gKi9cbiAgICBwbGF5ZXJIZWlnaHQ6IG51bWJlclxuICB9XG5cbiAgLyoqXG4gICAqIGByb3RhdGlvbkNoYW5nZWRgIGlzIHRyaWdnZXJlZCB3aGVuIHRoZSByb3RhdGlvbiBvZiB0aGUgY2FtZXJhIGNoYW5nZXMuXG4gICAqIFRoaXMgZXZlbnQgaXMgdGhyb3R0bGVkIHRvIDEwIHRpbWVzIHBlciBzZWNvbmQuXG4gICAqL1xuICByb3RhdGlvbkNoYW5nZWQ6IHtcbiAgICAvKioge1gsWSxafSBEZWdyZWUgdmVjdG9yLiBTYW1lIGFzIGVudGl0aWVzICovXG4gICAgcm90YXRpb246IFZlY3RvcjNDb21wb25lbnRcbiAgICAvKiogUm90YXRpb24gcXVhdGVybmlvbiwgdXNlZnVsIGluIHNvbWUgc2NlbmFyaW9zLiAqL1xuICAgIHF1YXRlcm5pb246IFF1YXRlcm5pb25cbiAgfVxuXG4gIC8qKlxuICAgKiBgc2V0QXR0cmlidXRlc2AgaXMgdHJpZ2dlcmVkIGFmdGVyIHRoZSBzeXN0ZW0gcmVjZWl2ZXMgbmV3IHByb3BlcnRpZXMuXG4gICAqL1xuICBzZXRBdHRyaWJ1dGVzOiB7XG4gICAgW2tleTogc3RyaW5nXTogYW55XG4gIH1cblxuICAvKipcbiAgICogYGNsaWNrYCBpcyB0cmlnZ2VyZWQgd2hlbiBhIHVzZXIgcG9pbnRzIGFuZCB0aGUgcmF5IChmcm9tIG1vdXNlIG9yIGNvbnRyb2xsZXIpIGhpdHMgdGhlIGVudGl0eS5cbiAgICogTm90aWNlOiBPbmx5IGVudGl0aWVzIHdpdGggSUQgd2lsbCBiZSBsaXN0ZW5pbmcgZm9yIGNsaWNrIGV2ZW50cy5cbiAgICovXG4gIGNsaWNrOiB7XG4gICAgLyoqIElEIG9mIHRoZSBlbnRpdGl5IG9mIHRoZSBldmVudCAqL1xuICAgIGVsZW1lbnRJZDogc3RyaW5nXG5cbiAgICAvKiogSUQgb2YgdGhlIHBvaW50ZXIgdGhhdCB0cmlnZ2VyZWQgdGhlIGV2ZW50ICovXG4gICAgcG9pbnRlcklkOiBudW1iZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBgcG9pbnRlclVwYCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgdXNlciByZWxlYXNlcyBhbiBpbnB1dCBwb2ludGVyLlxuICAgKiBJdCBjb3VsZCBiZSBhIFZSIGNvbnRyb2xsZXIsIGEgdG91Y2ggc2NyZWVuIG9yIHRoZSBtb3VzZS5cbiAgICovXG4gIHBvaW50ZXJVcDogUG9pbnRlckV2ZW50XG5cbiAgLyoqXG4gICAqIGBwb2ludGVyRG93bmAgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgcHJlc3MgYW4gaW5wdXQgcG9pbnRlci5cbiAgICogSXQgY291bGQgYmUgYSBWUiBjb250cm9sbGVyLCBhIHRvdWNoIHNjcmVlbiBvciB0aGUgbW91c2UuXG4gICAqL1xuICBwb2ludGVyRG93bjogUG9pbnRlckV2ZW50XG5cbiAgLyoqXG4gICAqIGBjaGFuZ2VkYCBpcyB0cmlnZ2VyZWQgd2hlbiBhbiBlbnRpdHkgY2hhbmdlcyBpdHMgb3duIGludGVybmFsIHN0YXRlLlxuICAgKiBEaXNwYXRjaGVkIGJ5IHRoZSBgaW5wdXQtdGV4dGAgZW50aXR5IHdoZW4gdGhlIHZhbHVlIGlzIGNoYW5nZWQuXG4gICAqL1xuICBjaGFuZ2VkOiB7XG4gICAgZWxlbWVudElkOiBzdHJpbmdcbiAgICB2YWx1ZTogYW55XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgSUV2ZW50TmFtZXMgPSBrZXlvZiBJRXZlbnRzXG5cbmV4cG9ydCB0eXBlIFJQQ0V2ZW50PEsgZXh0ZW5kcyBJRXZlbnROYW1lcywgRCA9IGFueT4gPSB7XG4gIGV2ZW50OiBLXG4gIGRhdGE6IERcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUV2ZW50PFQgZXh0ZW5kcyBJRXZlbnROYW1lcz4oZXZlbnQ6IFQsIGRhdGE6IElFdmVudHNbVF0pOiBSUENFdmVudDxULCBJRXZlbnRzW1RdPiB7XG4gIHJldHVybiB7IGV2ZW50LCBkYXRhIH1cbn1cbiJdfQ==\n\n//# sourceURL=webpack:///./node_modules/decentraland-api/lib/events.js?");

/***/ }),

/***/ "./node_modules/decentraland-api/lib/handlers.js":
/*!*******************************************************!*\
  !*** ./node_modules/decentraland-api/lib/handlers.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction createUUID() {\n    const s = [];\n    const hexDigits = '0123456789abcdef';\n    for (let i = 0; i < 36; i++) {\n        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);\n    }\n    s[14] = '4';\n    s[19] = hexDigits.substr((parseInt(s[19], 10) & 0x3) | 0x8, 1);\n    s[8] = s[13] = s[18] = s[23] = '-';\n    let uuid = s.join('');\n    return uuid;\n}\n// This symbol is used to store an ID in the function\nconst idSymbol = Symbol('id');\nfunction putHandler(fn) {\n    if (fn[idSymbol]) {\n        const id = fn[idSymbol];\n        if (id) {\n            return id;\n        }\n    }\n    const id = createUUID();\n    fn[idSymbol] = id;\n    return id;\n}\nexports.putHandler = putHandler;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGFuZGxlcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaGFuZGxlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxTQUFTLFVBQVU7SUFDakIsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFBO0lBQ1osTUFBTSxTQUFTLEdBQUcsa0JBQWtCLENBQUE7SUFDcEMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUMzQixDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQTtLQUM3RDtJQUNELENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUE7SUFDWCxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFBO0lBQzlELENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUE7SUFFbEMsSUFBSSxJQUFJLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQTtJQUNyQixPQUFPLElBQUksQ0FBQTtBQUNiLENBQUM7QUFFRCxxREFBcUQ7QUFDckQsTUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFBO0FBRTdCLFNBQWdCLFVBQVUsQ0FBQyxFQUFPO0lBQ2hDLElBQUksRUFBRSxDQUFDLFFBQVEsQ0FBQyxFQUFFO1FBQ2hCLE1BQU0sRUFBRSxHQUFXLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQTtRQUMvQixJQUFJLEVBQUUsRUFBRTtZQUNOLE9BQU8sRUFBRSxDQUFBO1NBQ1Y7S0FDRjtJQUVELE1BQU0sRUFBRSxHQUFHLFVBQVUsRUFBRSxDQUFBO0lBRXZCLEVBQUUsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUE7SUFFakIsT0FBTyxFQUFFLENBQUE7QUFDWCxDQUFDO0FBYkQsZ0NBYUMiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBjcmVhdGVVVUlEKCk6IHN0cmluZyB7XG4gIGNvbnN0IHMgPSBbXVxuICBjb25zdCBoZXhEaWdpdHMgPSAnMDEyMzQ1Njc4OWFiY2RlZidcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAzNjsgaSsrKSB7XG4gICAgc1tpXSA9IGhleERpZ2l0cy5zdWJzdHIoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHgxMCksIDEpXG4gIH1cbiAgc1sxNF0gPSAnNCdcbiAgc1sxOV0gPSBoZXhEaWdpdHMuc3Vic3RyKChwYXJzZUludChzWzE5XSwgMTApICYgMHgzKSB8IDB4OCwgMSlcbiAgc1s4XSA9IHNbMTNdID0gc1sxOF0gPSBzWzIzXSA9ICctJ1xuXG4gIGxldCB1dWlkID0gcy5qb2luKCcnKVxuICByZXR1cm4gdXVpZFxufVxuXG4vLyBUaGlzIHN5bWJvbCBpcyB1c2VkIHRvIHN0b3JlIGFuIElEIGluIHRoZSBmdW5jdGlvblxuY29uc3QgaWRTeW1ib2wgPSBTeW1ib2woJ2lkJylcblxuZXhwb3J0IGZ1bmN0aW9uIHB1dEhhbmRsZXIoZm46IGFueSk6IHN0cmluZyB7XG4gIGlmIChmbltpZFN5bWJvbF0pIHtcbiAgICBjb25zdCBpZDogc3RyaW5nID0gZm5baWRTeW1ib2xdXG4gICAgaWYgKGlkKSB7XG4gICAgICByZXR1cm4gaWRcbiAgICB9XG4gIH1cblxuICBjb25zdCBpZCA9IGNyZWF0ZVVVSUQoKVxuXG4gIGZuW2lkU3ltYm9sXSA9IGlkXG5cbiAgcmV0dXJuIGlkXG59XG4iXX0=\n\n//# sourceURL=webpack:///./node_modules/decentraland-api/lib/handlers.js?");

/***/ }),

/***/ "./node_modules/decentraland-api/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/decentraland-api/lib/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! decentraland-rpc */ \"./node_modules/decentraland-rpc/lib/client/index.js\"));\n__export(__webpack_require__(/*! decentraland-rpc/lib/common/transports/WebWorker */ \"./node_modules/decentraland-rpc/lib/common/transports/WebWorker.js\"));\n__export(__webpack_require__(/*! decentraland-rpc/lib/common/transports/WebSocket */ \"./node_modules/decentraland-rpc/lib/common/transports/WebSocket.js\"));\n__export(__webpack_require__(/*! decentraland-rpc/lib/common/core/EventDispatcher */ \"./node_modules/decentraland-rpc/lib/common/core/EventDispatcher.js\"));\n__export(__webpack_require__(/*! ./interfaces */ \"./node_modules/decentraland-api/lib/interfaces.js\"));\n__export(__webpack_require__(/*! ./events */ \"./node_modules/decentraland-api/lib/events.js\"));\n__export(__webpack_require__(/*! ./MessageBus */ \"./node_modules/decentraland-api/lib/MessageBus.js\"));\nconst ScriptableScene_1 = __webpack_require__(/*! ./ScriptableScene */ \"./node_modules/decentraland-api/lib/ScriptableScene.js\");\nexports.ScriptableScene = ScriptableScene_1.ScriptableScene;\nconst createElement_1 = __webpack_require__(/*! ./internal/createElement */ \"./node_modules/decentraland-api/lib/internal/createElement.js\");\nexports.createElement = createElement_1.createElement;\nif (typeof global !== 'undefined') {\n    global['createElement'] = global['createElement'] || createElement_1.createElement;\n}\nelse if (typeof window !== 'undefined') {\n    // tslint:disable-next-line:semicolon\n    window['createElement'] = window['createElement'] || createElement_1.createElement;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxzQ0FBZ0M7QUFDaEMsc0VBQWdFO0FBQ2hFLHNFQUFnRTtBQUNoRSxzRUFBZ0U7QUFDaEUsa0NBQTRCO0FBQzVCLDhCQUF3QjtBQUd4QixrQ0FBNEI7QUFFNUIsdURBQW1EO0FBRzNCLDBCQUhmLGlDQUFlLENBR2U7QUFGdkMsNERBQXdEO0FBRS9DLHdCQUZBLDZCQUFhLENBRUE7QUFLdEIsSUFBSSxPQUFPLE1BQU0sS0FBSyxXQUFXLEVBQUU7SUFDakMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxlQUFlLENBQUMsSUFBSSw2QkFBYSxDQUFBO0NBQ25FO0tBQU0sSUFBSSxPQUFPLE1BQU0sS0FBSyxXQUFXLEVBQUU7SUFDeEMscUNBQXFDO0lBQ3JDLE1BQU0sQ0FBQyxlQUFlLENBQUMsR0FBRyxNQUFNLENBQUMsZUFBZSxDQUFDLElBQUksNkJBQWEsQ0FBQTtDQUNuRSIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJ2RlY2VudHJhbGFuZC1ycGMnXG5leHBvcnQgKiBmcm9tICdkZWNlbnRyYWxhbmQtcnBjL2xpYi9jb21tb24vdHJhbnNwb3J0cy9XZWJXb3JrZXInXG5leHBvcnQgKiBmcm9tICdkZWNlbnRyYWxhbmQtcnBjL2xpYi9jb21tb24vdHJhbnNwb3J0cy9XZWJTb2NrZXQnXG5leHBvcnQgKiBmcm9tICdkZWNlbnRyYWxhbmQtcnBjL2xpYi9jb21tb24vY29yZS9FdmVudERpc3BhdGNoZXInXG5leHBvcnQgKiBmcm9tICcuL2ludGVyZmFjZXMnXG5leHBvcnQgKiBmcm9tICcuL2V2ZW50cydcbmV4cG9ydCAqIGZyb20gJy4vSlNYJ1xuZXhwb3J0ICogZnJvbSAnLi9hcGlzJ1xuZXhwb3J0ICogZnJvbSAnLi9NZXNzYWdlQnVzJ1xuXG5pbXBvcnQgeyBTY3JpcHRhYmxlU2NlbmUgfSBmcm9tICcuL1NjcmlwdGFibGVTY2VuZSdcbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQgfSBmcm9tICcuL2ludGVybmFsL2NyZWF0ZUVsZW1lbnQnXG5cbmV4cG9ydCB7IGNyZWF0ZUVsZW1lbnQsIFNjcmlwdGFibGVTY2VuZSB9XG5cbmRlY2xhcmUgdmFyIGdsb2JhbDogYW55XG5kZWNsYXJlIHZhciB3aW5kb3c6IGFueVxuXG5pZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZ2xvYmFsWydjcmVhdGVFbGVtZW50J10gPSBnbG9iYWxbJ2NyZWF0ZUVsZW1lbnQnXSB8fCBjcmVhdGVFbGVtZW50XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpzZW1pY29sb25cbiAgd2luZG93WydjcmVhdGVFbGVtZW50J10gPSB3aW5kb3dbJ2NyZWF0ZUVsZW1lbnQnXSB8fCBjcmVhdGVFbGVtZW50XG59XG4iXX0=\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/decentraland-api/lib/index.js?");

/***/ }),

/***/ "./node_modules/decentraland-api/lib/interfaces.js":
/*!*********************************************************!*\
  !*** ./node_modules/decentraland-api/lib/interfaces.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BillboardModes = {\n    BILLBOARDMODE_NONE: 0,\n    BILLBOARDMODE_X: 1,\n    BILLBOARDMODE_Y: 2,\n    BILLBOARDMODE_Z: 4,\n    BILLBOARDMODE_ALL: 7\n};\nexports.TextureSamplingMode = {\n    NEAREST: 1,\n    BILINEAR: 2,\n    TRILINEAR: 3\n};\nexports.TextureWrapping = {\n    CLAMP: 0,\n    WRAP: 1,\n    MIRROR: 2\n};\nexports.TransparencyModes = {\n    OPAQUE: 0,\n    ALPHATEST: 1,\n    ALPHABLEND: 2,\n    ALPHATESTANDBLEND: 3\n};\nvar Constants;\n(function (Constants) {\n    // DO NOT EVER CHANGE THESE VALUES\n    Constants.ReplaceWholeTreeException = 'ReplaceWholeTreeException';\n})(Constants = exports.Constants || (exports.Constants = {}));\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJmYWNlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9pbnRlcmZhY2VzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBcUJhLFFBQUEsY0FBYyxHQUFHO0lBQzVCLGtCQUFrQixFQUFFLENBQUM7SUFDckIsZUFBZSxFQUFFLENBQUM7SUFDbEIsZUFBZSxFQUFFLENBQUM7SUFDbEIsZUFBZSxFQUFFLENBQUM7SUFDbEIsaUJBQWlCLEVBQUUsQ0FBQztDQUNyQixDQUFBO0FBRVksUUFBQSxtQkFBbUIsR0FBRztJQUNqQyxPQUFPLEVBQUUsQ0FBQztJQUNWLFFBQVEsRUFBRSxDQUFDO0lBQ1gsU0FBUyxFQUFFLENBQUM7Q0FDYixDQUFBO0FBRVksUUFBQSxlQUFlLEdBQUc7SUFDN0IsS0FBSyxFQUFFLENBQUM7SUFDUixJQUFJLEVBQUUsQ0FBQztJQUNQLE1BQU0sRUFBRSxDQUFDO0NBQ1YsQ0FBQTtBQUlZLFFBQUEsaUJBQWlCLEdBQUc7SUFDL0IsTUFBTSxFQUFFLENBQUM7SUFDVCxTQUFTLEVBQUUsQ0FBQztJQUNaLFVBQVUsRUFBRSxDQUFDO0lBQ2IsaUJBQWlCLEVBQUUsQ0FBQztDQUNyQixDQUFBO0FBbUpELElBQWlCLFNBQVMsQ0FJekI7QUFKRCxXQUFpQixTQUFTO0lBQ3hCLGtDQUFrQztJQUVyQixtQ0FBeUIsR0FBRywyQkFBMkIsQ0FBQTtBQUN0RSxDQUFDLEVBSmdCLFNBQVMsR0FBVCxpQkFBUyxLQUFULGlCQUFTLFFBSXpCIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgSUVudGl0eSB9IGZyb20gJy4vaW50ZXJuYWwvYXBwbHlQYXRjaCdcblxuZXhwb3J0IGludGVyZmFjZSBJU2ltcGxpZmllZE5vZGUge1xuICB0YWc6IHN0cmluZ1xuICBjaGlsZHJlbjogSVNpbXBsaWZpZWROb2RlW11cbiAgYXR0cnM6IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB8IG51bWJlcltdIHwgb2JqZWN0IHwgYm9vbGVhbiB8IG51bWJlciB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSWRlbnRpdHkge1xuICBnZXRVc2VyUHVibGljS2V5KCk6IFByb21pc2U8c3RyaW5nPlxufVxuXG5leHBvcnQgdHlwZSBMYW5kRGF0YVZlcnNpb24wID0ge1xuICB2ZXJzaW9uOiAwXG4gIG5hbWU6IHN0cmluZ1xuICBkZXNjcmlwdGlvbjogc3RyaW5nXG4gIGlwbnM6IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBMYW5kRGF0YSA9IExhbmREYXRhVmVyc2lvbjBcblxuZXhwb3J0IGNvbnN0IEJpbGxib2FyZE1vZGVzID0ge1xuICBCSUxMQk9BUkRNT0RFX05PTkU6IDAsXG4gIEJJTExCT0FSRE1PREVfWDogMSxcbiAgQklMTEJPQVJETU9ERV9ZOiAyLFxuICBCSUxMQk9BUkRNT0RFX1o6IDQsXG4gIEJJTExCT0FSRE1PREVfQUxMOiA3XG59XG5cbmV4cG9ydCBjb25zdCBUZXh0dXJlU2FtcGxpbmdNb2RlID0ge1xuICBORUFSRVNUOiAxLFxuICBCSUxJTkVBUjogMixcbiAgVFJJTElORUFSOiAzXG59XG5cbmV4cG9ydCBjb25zdCBUZXh0dXJlV3JhcHBpbmcgPSB7XG4gIENMQU1QOiAwLFxuICBXUkFQOiAxLFxuICBNSVJST1I6IDJcbn1cblxuZXhwb3J0IHR5cGUgSUJpbGxib2FyZE1vZGVzID0gMCB8IDEgfCAyIHwgMyB8IDQgfCA1IHwgNiB8IDdcblxuZXhwb3J0IGNvbnN0IFRyYW5zcGFyZW5jeU1vZGVzID0ge1xuICBPUEFRVUU6IDAsXG4gIEFMUEhBVEVTVDogMSxcbiAgQUxQSEFCTEVORDogMixcbiAgQUxQSEFURVNUQU5EQkxFTkQ6IDNcbn1cblxuZXhwb3J0IHR5cGUgSVRyYW5zcGFyZW5jeU1vZGVzID0gMCB8IDEgfCAyIHwgM1xuXG5leHBvcnQgaW50ZXJmYWNlIEFQSUxhbmQge1xuICB4OiBudW1iZXJcbiAgeTogbnVtYmVyXG4gIGRpc3RyaWN0X2lkPzogc3RyaW5nXG4gIG93bmVyOiBzdHJpbmdcbiAgZGF0YTogTGFuZERhdGFcbiAgaW5fZXN0YXRlPzogYm9vbGVhblxuICBsYXN0X3RyYW5zZmVycmVkX2F0Pzogc3RyaW5nXG59XG5cbi8vLyBodHRwczovL2dpdGh1Yi5jb20vZGVjZW50cmFsYW5kL3Byb3Bvc2Fscy9ibG9iL21hc3Rlci9kc3AvMDAyMC5tZWRpYXdpa2lcbmV4cG9ydCBpbnRlcmZhY2UgSVNjZW5lIHtcbiAgYXNzZXRzPzogUmVjb3JkPGFueSwgc3RyaW5nPlxuICBvd25lcjogc3RyaW5nXG4gIG1haW46IHN0cmluZ1xuICBzY2VuZToge1xuICAgIGJhc2U6IHN0cmluZ1xuICAgIHBhcmNlbHM6IHN0cmluZ1tdXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBJTGFuZCBleHRlbmRzIEFQSUxhbmQge1xuICBzY2VuZTogSVNjZW5lXG4gIGJhc2VVcmw6IHN0cmluZ1xuICAvLyBIVE1MIGlzIHVzZWQgYnkgdGhlIHByZXZpZXcgbG9hZGVyIHRvIHBhcnNlIHNjZW5lIGRhdGEgZGlyZWN0bHlcbiAgLy8gdG8gc3RhdGljUGFyY2VsLlxuICBodG1sPzogc3RyaW5nXG4gIHR5cGU/OiAncm9hZCcgfCAnbGFuZCcgfCAncGxhemEnXG59XG5cbi8qKlxuICogVGhpcyBkYXRhIHR5cGUgZGVmaW5lcyBhIHR3byBjb21wb25lbnQgdmVjdG9yLlxuICovXG5leHBvcnQgdHlwZSBWZWN0b3IyQ29tcG9uZW50ID0ge1xuICB4OiBudW1iZXJcbiAgeTogbnVtYmVyXG59XG5cbi8qKlxuICogVGhpcyBkYXRhIHR5cGUgZGVmaW5lcyBhIHRocmVlIGNvbXBvbmVudCB2ZWN0b3IuIEl0IGlzIHVzZWQgZm9yIHNjYWxpbmcsIHBvc2l0aW9uaW5nIGFuZCByb3RhdGlvbnNcbiAqL1xuZXhwb3J0IHR5cGUgVmVjdG9yM0NvbXBvbmVudCA9IHtcbiAgeDogbnVtYmVyXG4gIHk6IG51bWJlclxuICB6OiBudW1iZXJcbn1cblxuZXhwb3J0IHR5cGUgUXVhdGVybmlvbiA9IHtcbiAgeDogbnVtYmVyXG4gIHk6IG51bWJlclxuICB6OiBudW1iZXJcbiAgdzogbnVtYmVyXG59XG5cbmV4cG9ydCB0eXBlIFNvdW5kQ29tcG9uZW50ID0ge1xuICAvKiogRGlzdGFuY2UgZmFkaW5nIG1vZGVsLCBkZWZhdWx0OiAnbGluZWFyJyAqL1xuICBkaXN0YW5jZU1vZGVsPzogJ2xpbmVhcicgfCAnaW52ZXJzZScgfCAnZXhwb25lbnRpYWwnXG4gIC8qKiBEb2VzIHRoZSBzb3VuZCBsb29wPyBkZWZhdWx0OiBmYWxzZSAqL1xuICBsb29wPzogYm9vbGVhblxuICAvKiogVGhlIHNyYyBvZiB0aGUgc291bmQgdG8gYmUgcGxheWVkICovXG4gIHNyYzogc3RyaW5nXG4gIC8qKiBWb2x1bWUgb2YgdGhlIHNvdW5kLCB2YWx1ZXMgMCB0byAxLCBkZWZhdWx0OiAxICovXG4gIHZvbHVtZT86IG51bWJlclxuICAvKiogVXNlZCBpbiBpbnZlcnNlIGFuZCBleHBvbmVudGlhbCBkaXN0YW5jZSBtb2RlbHMsIGRlZmF1bHQ6IDEgKi9cbiAgcm9sbG9mZkZhY3Rvcj86IG51bWJlclxuICAvKiogSXMgdGhlIHNvdW5kIHBsYXlpbmc/LCBkZWZhdWx0OiB0cnVlICovXG4gIHBsYXlpbmc/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIFRyYW5zaXRpb25WYWx1ZSA9IHtcbiAgZHVyYXRpb246IG51bWJlclxuICB0aW1pbmc/OiBUaW1pbmdGdW5jdGlvblxuICBkZWxheT86IG51bWJlclxufVxuXG5leHBvcnQgdHlwZSBUaW1pbmdGdW5jdGlvbiA9XG4gIHwgJ2xpbmVhcidcbiAgfCAnZWFzZS1pbidcbiAgfCAnZWFzZS1vdXQnXG4gIHwgJ2Vhc2UtaW4tb3V0J1xuICB8ICdxdWFkcmF0aWMtaW4nXG4gIHwgJ3F1YWRyYXRpYy1vdXQnXG4gIHwgJ3F1YWRyYXRpYy1pbm91dCdcbiAgfCAnY3ViaWMtaW4nXG4gIHwgJ2N1YmljLW91dCdcbiAgfCAnY3ViaWMtaW5vdXQnXG4gIHwgJ3F1YXJ0aWMtaW4nXG4gIHwgJ3F1YXJ0aWMtb3V0J1xuICB8ICdxdWFydGljLWlub3V0J1xuICB8ICdxdWludGljLWluJ1xuICB8ICdxdWludGljLW91dCdcbiAgfCAncXVpbnRpYy1pbm91dCdcbiAgfCAnc2luLWluJ1xuICB8ICdzaW4tb3V0J1xuICB8ICdzaW4taW5vdXQnXG4gIHwgJ2V4cG9uZW50aWFsLWluJ1xuICB8ICdleHBvbmVudGlhbC1vdXQnXG4gIHwgJ2V4cG9uZW50aWFsLWlub3V0J1xuICB8ICdib3VuY2UtaW4nXG4gIHwgJ2JvdW5jZS1vdXQnXG4gIHwgJ2JvdW5jZS1pbm91dCdcbiAgfCAnZWxhc3RpYy1pbidcbiAgfCAnZWxhc3RpYy1vdXQnXG4gIHwgJ2VsYXN0aWMtaW5vdXQnXG4gIHwgJ2NpcmN1bGFyLWluJ1xuICB8ICdjaXJjdWxhci1vdXQnXG4gIHwgJ2NpcmN1bGFyLWlub3V0J1xuICB8ICdiYWNrLWluJ1xuICB8ICdiYWNrLW91dCdcbiAgfCAnYmFjay1pbm91dCdcblxuZXhwb3J0IHR5cGUgVHJhbnNpdGlvbkNvbXBvbmVudCA9IHtcbiAgcG9zaXRpb24/OiBUcmFuc2l0aW9uVmFsdWVcbiAgcm90YXRpb24/OiBUcmFuc2l0aW9uVmFsdWVcbiAgc2NhbGU/OiBUcmFuc2l0aW9uVmFsdWVcbiAgY29sb3I/OiBUcmFuc2l0aW9uVmFsdWVcbiAgbG9va0F0PzogVHJhbnNpdGlvblZhbHVlXG59XG5cbmV4cG9ydCB0eXBlIFNrZWxldGFsQW5pbWF0aW9uVmFsdWUgPSB7XG4gIC8qKlxuICAgKiBOYW1lIG9yIGluZGV4IG9mIHRoZSBhbmltYXRpb24gaW4gdGhlIG1vZGVsXG4gICAqL1xuICBjbGlwOiBzdHJpbmcgfCBudW1iZXJcblxuICAvKipcbiAgICogRG9lcyB0aGUgYW5pbWF0aW9uIGxvb3A/LCBkZWZhdWx0OiB0cnVlXG4gICAqL1xuICBsb29wPzogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBXZWlnaHQgb2YgdGhlIGFuaW1hdGlvbiwgdmFsdWVzIGZyb20gMCB0byAxLCB1c2VkIHRvIGJsZW5kIHNldmVyYWwgYW5pbWF0aW9ucy4gZGVmYXVsdDogMVxuICAgKi9cbiAgd2VpZ2h0PzogbnVtYmVyXG5cbiAgLyoqXG4gICAqIElzIHRoZSBhbmltYXRpb24gcGxheWluZz8gZGVmYXVsdDogdHJ1ZVxuICAgKi9cbiAgcGxheWluZz86IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgU2tlbGV0YWxBbmltYXRpb25Db21wb25lbnQgPSBTa2VsZXRhbEFuaW1hdGlvblZhbHVlW11cblxuZXhwb3J0IG5hbWVzcGFjZSBDb25zdGFudHMge1xuICAvLyBETyBOT1QgRVZFUiBDSEFOR0UgVEhFU0UgVkFMVUVTXG5cbiAgZXhwb3J0IGNvbnN0IFJlcGxhY2VXaG9sZVRyZWVFeGNlcHRpb24gPSAnUmVwbGFjZVdob2xlVHJlZUV4Y2VwdGlvbidcbn1cbiJdfQ==\n\n//# sourceURL=webpack:///./node_modules/decentraland-api/lib/interfaces.js?");

/***/ }),

/***/ "./node_modules/decentraland-api/lib/internal/createElement.js":
/*!*********************************************************************!*\
  !*** ./node_modules/decentraland-api/lib/internal/createElement.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst stack = [];\nfunction createElement(nodeName, attributes) {\n    let children = [];\n    let lastSimple = false;\n    let child;\n    let simple = false;\n    let i;\n    let nodeType;\n    // tslint:disable-next-line:space-within-parens\n    for (i = arguments.length; i-- > 2;) {\n        if (arguments[i] && typeof arguments[i] !== 'string')\n            stack.push(arguments[i]);\n    }\n    if (attributes) {\n        if (attributes.children != null) {\n            if (!stack.length)\n                stack.push(attributes.children);\n            delete attributes.children;\n        }\n    }\n    while (stack.length) {\n        // tslint:disable-next-line:no-conditional-assignment\n        if ((child = stack.pop()) && child.pop !== undefined) {\n            // tslint:disable-next-line:space-within-parens\n            for (i = child.length; i--;)\n                stack.push(child[i]);\n        }\n        else {\n            if (typeof child === 'boolean')\n                child = null;\n            nodeType = typeof nodeName;\n            // tslint:disable-next-line:no-conditional-assignment\n            if ((simple = nodeType !== 'function')) {\n                if (child == null)\n                    child = null;\n                else if (typeof child !== 'string')\n                    simple = false;\n            }\n            if (simple && lastSimple) {\n                children[children.length - 1] += child;\n            }\n            else if (child) {\n                children.push(child);\n            }\n            lastSimple = simple;\n        }\n    }\n    return {\n        tag: nodeName,\n        attrs: attributes || {},\n        children: children || []\n    };\n}\nexports.createElement = createElement;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3JlYXRlRWxlbWVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9pbnRlcm5hbC9jcmVhdGVFbGVtZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBR0EsTUFBTSxLQUFLLEdBQVUsRUFBRSxDQUFBO0FBMER2QixTQUFnQixhQUFhLENBQUMsUUFBMkIsRUFBRSxVQUFlO0lBQ3hFLElBQUksUUFBUSxHQUFzQixFQUFFLENBQUE7SUFDcEMsSUFBSSxVQUFVLEdBQVksS0FBSyxDQUFBO0lBQy9CLElBQUksS0FBSyxDQUFBO0lBQ1QsSUFBSSxNQUFNLEdBQVksS0FBSyxDQUFBO0lBQzNCLElBQUksQ0FBQyxDQUFBO0lBQ0wsSUFBSSxRQUFnQixDQUFBO0lBRXBCLCtDQUErQztJQUMvQyxLQUFLLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsR0FBSTtRQUNwQyxJQUFJLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxPQUFPLFNBQVMsQ0FBQyxDQUFDLENBQUMsS0FBSyxRQUFRO1lBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtLQUMvRTtJQUNELElBQUksVUFBVSxFQUFFO1FBQ2QsSUFBSSxVQUFVLENBQUMsUUFBUSxJQUFJLElBQUksRUFBRTtZQUMvQixJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU07Z0JBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUE7WUFDbEQsT0FBTyxVQUFVLENBQUMsUUFBUSxDQUFBO1NBQzNCO0tBQ0Y7SUFDRCxPQUFPLEtBQUssQ0FBQyxNQUFNLEVBQUU7UUFDbkIscURBQXFEO1FBQ3JELElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksS0FBSyxDQUFDLEdBQUcsS0FBSyxTQUFTLEVBQUU7WUFDcEQsK0NBQStDO1lBQy9DLEtBQUssQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFO2dCQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7U0FDbkQ7YUFBTTtZQUNMLElBQUksT0FBTyxLQUFLLEtBQUssU0FBUztnQkFBRSxLQUFLLEdBQUcsSUFBSSxDQUFBO1lBRTVDLFFBQVEsR0FBRyxPQUFPLFFBQVEsQ0FBQTtZQUUxQixxREFBcUQ7WUFDckQsSUFBSSxDQUFDLE1BQU0sR0FBRyxRQUFRLEtBQUssVUFBVSxDQUFDLEVBQUU7Z0JBQ3RDLElBQUksS0FBSyxJQUFJLElBQUk7b0JBQUUsS0FBSyxHQUFHLElBQUksQ0FBQTtxQkFDMUIsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRO29CQUFFLE1BQU0sR0FBRyxLQUFLLENBQUE7YUFDbkQ7WUFFRCxJQUFJLE1BQU0sSUFBSSxVQUFVLEVBQUU7Z0JBQ3hCLFFBQVEsQ0FBQyxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQTthQUN2QztpQkFBTSxJQUFJLEtBQUssRUFBRTtnQkFDaEIsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQTthQUNyQjtZQUVELFVBQVUsR0FBRyxNQUFNLENBQUE7U0FDcEI7S0FDRjtJQUVELE9BQU87UUFDTCxHQUFHLEVBQUUsUUFBUTtRQUNiLEtBQUssRUFBRSxVQUFVLElBQUksRUFBRTtRQUN2QixRQUFRLEVBQUUsUUFBUSxJQUFJLEVBQUU7S0FDekIsQ0FBQTtBQUNILENBQUM7QUFqREQsc0NBaURDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2NyaXB0YWJsZVNjZW5lIH0gZnJvbSAnLi4vU2NyaXB0YWJsZVNjZW5lJ1xuaW1wb3J0IHsgSVNpbXBsaWZpZWROb2RlIH0gZnJvbSAnLi4vaW50ZXJmYWNlcydcblxuY29uc3Qgc3RhY2s6IGFueVtdID0gW11cblxuZXhwb3J0IHR5cGUgQ29tcG9uZW50Q2hpbGQgPSBKU1guRWxlbWVudFxuZXhwb3J0IHR5cGUgQ29tcG9uZW50Q2hpbGRyZW4gPSBDb21wb25lbnRDaGlsZFtdXG5cbmV4cG9ydCB0eXBlIENvbXBvbmVudEZhY3Rvcnk8UD4gPSBDb21wb25lbnRDb25zdHJ1Y3RvcjxQPiB8IEZ1bmN0aW9uYWxDb21wb25lbnQ8UD5cblxuZXhwb3J0IHR5cGUgUmVuZGVyYWJsZVByb3BzPFA+ID0gUmVhZG9ubHk8UD4gJiBSZWFkb25seTx7IGNoaWxkcmVuPzogQ29tcG9uZW50Q2hpbGRyZW4gfT5cblxuZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbmFsQ29tcG9uZW50PFByb3BzID0ge30+IHtcbiAgKHByb3BzOiBSZW5kZXJhYmxlUHJvcHM8UHJvcHM+LCBjb250ZXh0PzogYW55KTogSVNpbXBsaWZpZWROb2RlIHwgbnVsbFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBvbmVudENvbnN0cnVjdG9yPFByb3BzID0ge30sIFN0YXRlID0ge30+IHtcbiAgbmV3IChwcm9wczogUHJvcHMsIGNvbnRleHQ/OiBhbnkpOiBTY3JpcHRhYmxlU2NlbmU8UHJvcHMsIFN0YXRlPlxufVxuXG4vKipcbiAqIEpTWC9oeXBlcnNjcmlwdCByZXZpdmVyLlxuICogQHNlZSBodHRwOi8vamFzb25mb3JtYXQuY29tL3d0Zi1pcy1qc3hcbiAqXG4gKiBDcmVhdGVzIGEgSVNpbXBsaWZpZWROb2RlICh2aXJ0dWFsIGVudGl0eSkuIEEgdHJlZSBvZiBJU2ltcGxpZmllZE5vZGUgY2FuIGJlIHVzZWQgYXMgYSBsaWdodHdlaWdodCByZXByZXNlbnRhdGlvblxuICogb2YgdGhlIHN0cnVjdHVyZSBvZiBhIGVudGl0eSB0cmVlLiBUaGlzIHN0cnVjdHVyZSBjYW4gYmUgcmVhbGl6ZWQgYnkgcmVjdXJzaXZlbHkgY29tcGFyaW5nIGl0IGFnYWluc3RcbiAqIHRoZSBjdXJyZW50IF9hY3R1YWxfIGVudGl0eSBzdHJ1Y3R1cmUsIGFuZCBhcHBseWluZyBvbmx5IHRoZSBkaWZmZXJlbmNlcy5cbiAqXG4gKiBgY3JlYXRlRWxlbWVudCgpYCBhY2NlcHRzIGFuIGVsZW1lbnQgbmFtZSwgYSBsaXN0IG9mIGF0dHJpYnV0ZXMvcHJvcHMsXG4gKiBhbmQgb3B0aW9uYWxseSBjaGlsZHJlbiB0byBhcHBlbmQgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogQGV4YW1wbGUgVGhlIGZvbGxvd2luZyBlbnRpdHkgdHJlZVxuICpcbiAqIGA8Ym94IHBvc2l0aW9uPXt7eDogMSwgeTogMiwgejogM319IC8+YFxuICpcbiAqIGNhbiBiZSBjb25zdHJ1Y3RlZCB1c2luZyB0aGlzIGZ1bmN0aW9uIGFzOlxuICpcbiAqIGBjcmVhdGVFbGVtZW50KCdib3gnLCB7IHBvc2l0aW9uOiB7eDogMSwgeTogMiwgejogM30gfSk7YFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBub2RlTmFtZVx0QW4gZW50aXR5IG5hbWUuIEV4OiBgc2NlbmVgLCBgYm94YCwgYGdsdGYtbW9kZWxgLCBldGMuXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlc1x0QW55IGF0dHJpYnV0ZXMvcHJvcHMgdG8gc2V0IG9uIHRoZSBjcmVhdGVkIGVudGl0eS5cbiAqIEBwYXJhbSByZXN0IEFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSB0YWtlbiB0byBiZSBjaGlsZHJlbiB0byBhcHBlbmQuIENhbiBiZSBpbmZpbml0ZWx5IG5lc3RlZCBBcnJheXMuXG4gKlxuICogQHB1YmxpY1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbGVtZW50PFA+KFxuICBub2RlOiBDb21wb25lbnRGYWN0b3J5PFA+LFxuICBwYXJhbXM6IEpTWC5CYXNlRW50aXR5ICYgUCB8IG51bGwsXG4gIC4uLmNoaWxkcmVuOiAoQ29tcG9uZW50Q2hpbGQgfCBDb21wb25lbnRDaGlsZHJlbilbXVxuKTogSVNpbXBsaWZpZWROb2RlXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRWxlbWVudDxLIGV4dGVuZHMga2V5b2YgSlNYLkludHJpbnNpY0VsZW1lbnRzPihcbiAgbm9kZTogSyxcbiAgcGFyYW1zOiBKU1guSW50cmluc2ljRWxlbWVudHNbS10sXG4gIC4uLmNoaWxkcmVuOiAoQ29tcG9uZW50Q2hpbGQgfCBDb21wb25lbnRDaGlsZHJlbilbXVxuKTogSVNpbXBsaWZpZWROb2RlXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRWxlbWVudChcbiAgbm9kZTogc3RyaW5nLFxuICBwYXJhbXM6IFJlY29yZDxzdHJpbmcsIGFueT4gfCBudWxsLFxuICAuLi5jaGlsZHJlbjogKENvbXBvbmVudENoaWxkIHwgQ29tcG9uZW50Q2hpbGRyZW4pW11cbik6IElTaW1wbGlmaWVkTm9kZVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQobm9kZU5hbWU6IHN0cmluZyB8IEZ1bmN0aW9uLCBhdHRyaWJ1dGVzOiBhbnkpIHtcbiAgbGV0IGNoaWxkcmVuOiBJU2ltcGxpZmllZE5vZGVbXSA9IFtdXG4gIGxldCBsYXN0U2ltcGxlOiBib29sZWFuID0gZmFsc2VcbiAgbGV0IGNoaWxkXG4gIGxldCBzaW1wbGU6IGJvb2xlYW4gPSBmYWxzZVxuICBsZXQgaVxuICBsZXQgbm9kZVR5cGU6IHN0cmluZ1xuXG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpzcGFjZS13aXRoaW4tcGFyZW5zXG4gIGZvciAoaSA9IGFyZ3VtZW50cy5sZW5ndGg7IGktLSA+IDI7ICkge1xuICAgIGlmIChhcmd1bWVudHNbaV0gJiYgdHlwZW9mIGFyZ3VtZW50c1tpXSAhPT0gJ3N0cmluZycpIHN0YWNrLnB1c2goYXJndW1lbnRzW2ldKVxuICB9XG4gIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKGF0dHJpYnV0ZXMuY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgaWYgKCFzdGFjay5sZW5ndGgpIHN0YWNrLnB1c2goYXR0cmlidXRlcy5jaGlsZHJlbilcbiAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzLmNoaWxkcmVuXG4gICAgfVxuICB9XG4gIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uZGl0aW9uYWwtYXNzaWdubWVudFxuICAgIGlmICgoY2hpbGQgPSBzdGFjay5wb3AoKSkgJiYgY2hpbGQucG9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpzcGFjZS13aXRoaW4tcGFyZW5zXG4gICAgICBmb3IgKGkgPSBjaGlsZC5sZW5ndGg7IGktLTsgKSBzdGFjay5wdXNoKGNoaWxkW2ldKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnYm9vbGVhbicpIGNoaWxkID0gbnVsbFxuXG4gICAgICBub2RlVHlwZSA9IHR5cGVvZiBub2RlTmFtZVxuXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uZGl0aW9uYWwtYXNzaWdubWVudFxuICAgICAgaWYgKChzaW1wbGUgPSBub2RlVHlwZSAhPT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgaWYgKGNoaWxkID09IG51bGwpIGNoaWxkID0gbnVsbFxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2hpbGQgIT09ICdzdHJpbmcnKSBzaW1wbGUgPSBmYWxzZVxuICAgICAgfVxuXG4gICAgICBpZiAoc2ltcGxlICYmIGxhc3RTaW1wbGUpIHtcbiAgICAgICAgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0gKz0gY2hpbGRcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGQpIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZClcbiAgICAgIH1cblxuICAgICAgbGFzdFNpbXBsZSA9IHNpbXBsZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdGFnOiBub2RlTmFtZSxcbiAgICBhdHRyczogYXR0cmlidXRlcyB8fCB7fSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4gfHwgW11cbiAgfVxufVxuIl19\n\n//# sourceURL=webpack:///./node_modules/decentraland-api/lib/internal/createElement.js?");

/***/ }),

/***/ "./node_modules/decentraland-api/lib/utils/future.js":
/*!***********************************************************!*\
  !*** ./node_modules/decentraland-api/lib/utils/future.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction future() {\n    let resolver = (x) => {\n        throw new Error('Error initilizing mutex');\n    };\n    let rejecter = (x) => {\n        throw x;\n    };\n    const promise = new Promise((ok, err) => {\n        resolver = ok;\n        rejecter = err;\n    });\n    promise.then(() => (promise.isPending = false));\n    promise.catch(() => (promise.isPending = false));\n    promise.resolve = resolver;\n    promise.reject = rejecter;\n    promise.isPending = true;\n    return promise;\n}\nexports.future = future;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnV0dXJlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3V0aWxzL2Z1dHVyZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQU1BLFNBQWdCLE1BQU07SUFDcEIsSUFBSSxRQUFRLEdBQW1CLENBQUMsQ0FBSSxFQUFFLEVBQUU7UUFDdEMsTUFBTSxJQUFJLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxDQUFBO0lBQzVDLENBQUMsQ0FBQTtJQUNELElBQUksUUFBUSxHQUF1QixDQUFDLENBQVEsRUFBRSxFQUFFO1FBQzlDLE1BQU0sQ0FBQyxDQUFBO0lBQ1QsQ0FBQyxDQUFBO0lBRUQsTUFBTSxPQUFPLEdBQVEsSUFBSSxPQUFPLENBQUMsQ0FBQyxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUU7UUFDM0MsUUFBUSxHQUFHLEVBQUUsQ0FBQTtRQUNiLFFBQVEsR0FBRyxHQUFHLENBQUE7SUFDaEIsQ0FBQyxDQUFDLENBQUE7SUFFRixPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFBO0lBQy9DLE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUE7SUFFaEQsT0FBTyxDQUFDLE9BQU8sR0FBRyxRQUFRLENBQUE7SUFDMUIsT0FBTyxDQUFDLE1BQU0sR0FBRyxRQUFRLENBQUE7SUFFekIsT0FBTyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUE7SUFFeEIsT0FBTyxPQUFxQixDQUFBO0FBQzlCLENBQUM7QUF0QkQsd0JBc0JDIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHR5cGUgSUZ1dHVyZTxUPiA9IFByb21pc2U8VD4gJiB7XG4gIHJlc29sdmU6ICh4OiBUKSA9PiB2b2lkXG4gIHJlamVjdDogKHg6IEVycm9yKSA9PiB2b2lkXG4gIGlzUGVuZGluZzogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZnV0dXJlPFQgPSBhbnk+KCk6IElGdXR1cmU8VD4ge1xuICBsZXQgcmVzb2x2ZXI6ICh4OiBUKSA9PiB2b2lkID0gKHg6IFQpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGluaXRpbGl6aW5nIG11dGV4JylcbiAgfVxuICBsZXQgcmVqZWN0ZXI6ICh4OiBFcnJvcikgPT4gdm9pZCA9ICh4OiBFcnJvcikgPT4ge1xuICAgIHRocm93IHhcbiAgfVxuXG4gIGNvbnN0IHByb21pc2U6IGFueSA9IG5ldyBQcm9taXNlKChvaywgZXJyKSA9PiB7XG4gICAgcmVzb2x2ZXIgPSBva1xuICAgIHJlamVjdGVyID0gZXJyXG4gIH0pXG5cbiAgcHJvbWlzZS50aGVuKCgpID0+IChwcm9taXNlLmlzUGVuZGluZyA9IGZhbHNlKSlcbiAgcHJvbWlzZS5jYXRjaCgoKSA9PiAocHJvbWlzZS5pc1BlbmRpbmcgPSBmYWxzZSkpXG5cbiAgcHJvbWlzZS5yZXNvbHZlID0gcmVzb2x2ZXJcbiAgcHJvbWlzZS5yZWplY3QgPSByZWplY3RlclxuXG4gIHByb21pc2UuaXNQZW5kaW5nID0gdHJ1ZVxuXG4gIHJldHVybiBwcm9taXNlIGFzIElGdXR1cmU8VD5cbn1cbiJdfQ==\n\n//# sourceURL=webpack:///./node_modules/decentraland-api/lib/utils/future.js?");

/***/ }),

/***/ "./node_modules/decentraland-rpc/lib/client/EventSubscriber.js":
/*!*********************************************************************!*\
  !*** ./node_modules/decentraland-rpc/lib/client/EventSubscriber.js ***!
  \*********************************************************************/
/*! exports provided: EventSubscriber */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EventSubscriber\", function() { return EventSubscriber; });\n/* harmony import */ var _common_core_EventDispatcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/core/EventDispatcher */ \"./node_modules/decentraland-rpc/lib/common/core/EventDispatcher.js\");\n\nclass EventSubscriber extends _common_core_EventDispatcher__WEBPACK_IMPORTED_MODULE_0__[\"EventDispatcher\"] {\n    constructor(component) {\n        super();\n        this.component = component;\n        component.onSubscribedEvent((data) => {\n            super.emit(data.event, data);\n        });\n    }\n    on(event, handler) {\n        if (this.getEventBindings(event).length === 0) {\n            this.component.subscribe(event).catch(e => this.emit('error', e));\n        }\n        return super.on.apply(this, arguments);\n    }\n    off(event) {\n        let theEventToValidate = null;\n        const offResult = super.off.apply(this, arguments);\n        if (typeof event === 'string') {\n            theEventToValidate = event;\n        }\n        else if (event instanceof _common_core_EventDispatcher__WEBPACK_IMPORTED_MODULE_0__[\"EventDispatcherBinding\"]) {\n            event = event.event;\n        }\n        if (theEventToValidate !== null) {\n            if (this.getEventBindings(theEventToValidate).length === 0) {\n                this.component.unsubscribe(theEventToValidate).catch(e => this.emit('error', e));\n            }\n        }\n        return offResult;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRXZlbnRTdWJzY3JpYmVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NsaWVudC9FdmVudFN1YnNjcmliZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGVBQWUsRUFBRSxzQkFBc0IsRUFBRSxNQUFNLGdDQUFnQyxDQUFBO0FBR3hGLE1BQU0sT0FBTyxlQUFnQixTQUFRLGVBQWU7SUFDbEQsWUFBb0IsU0FBMkI7UUFDN0MsS0FBSyxFQUFFLENBQUE7UUFEVyxjQUFTLEdBQVQsU0FBUyxDQUFrQjtRQUc3QyxTQUFTLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxJQUFTLEVBQUUsRUFBRTtZQUN4QyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUE7UUFDOUIsQ0FBQyxDQUFDLENBQUE7SUFDSixDQUFDO0lBU0QsRUFBRSxDQUFDLEtBQWEsRUFBRSxPQUFZO1FBQzVCLElBQUksSUFBSSxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDN0MsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQTtTQUNsRTtRQUNELE9BQU8sS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFBO0lBQ3hDLENBQUM7SUFPRCxHQUFHLENBQUMsS0FBaUQ7UUFDbkQsSUFBSSxrQkFBa0IsR0FBa0IsSUFBSSxDQUFBO1FBQzVDLE1BQU0sU0FBUyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQTtRQUVsRCxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsRUFBRTtZQUM3QixrQkFBa0IsR0FBRyxLQUFLLENBQUE7U0FDM0I7YUFBTSxJQUFJLEtBQUssWUFBWSxzQkFBc0IsRUFBRTtZQUNsRCxLQUFLLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQTtTQUNwQjtRQUVELElBQUksa0JBQWtCLEtBQUssSUFBSSxFQUFFO1lBQy9CLElBQUksSUFBSSxDQUFDLGdCQUFnQixDQUFDLGtCQUFrQixDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtnQkFJMUQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFBO2FBQ2pGO1NBQ0Y7UUFFRCxPQUFPLFNBQVMsQ0FBQTtJQUNsQixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudERpc3BhdGNoZXIsIEV2ZW50RGlzcGF0Y2hlckJpbmRpbmcgfSBmcm9tICcuLi9jb21tb24vY29yZS9FdmVudERpc3BhdGNoZXInXG5pbXBvcnQgeyBJU3Vic2NyaWJhYmxlQVBJIH0gZnJvbSAnLi4vaG9zdC9BUEknXG5cbmV4cG9ydCBjbGFzcyBFdmVudFN1YnNjcmliZXIgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNvbXBvbmVudDogSVN1YnNjcmliYWJsZUFQSSkge1xuICAgIHN1cGVyKClcblxuICAgIGNvbXBvbmVudC5vblN1YnNjcmliZWRFdmVudCgoZGF0YTogYW55KSA9PiB7XG4gICAgICBzdXBlci5lbWl0KGRhdGEuZXZlbnQsIGRhdGEpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBuZXcgbGlzdGVuZXIgZm9yIGFuIHNwZWNpZmljIGV2ZW50LlxuICAgKiBAcGFyYW0gZXZlbnQgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSBoYW5kbGVyIEEgaGFuZGxlciB3aGljaCBiZSBjYWxsZWQgZWFjaCB0aW1lIHRoZSBldmVudCBpcyByZWNlaXZlZFxuICAgKi9cbiAgb24oZXZlbnQ6IHN0cmluZywgY2FsbGJhY2s6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCwgb25jZT86IGJvb2xlYW4pOiBFdmVudERpc3BhdGNoZXJCaW5kaW5nXG4gIG9uKGV2ZW50OiBzdHJpbmcsIGNhbGxiYWNrOiBhbnksIG9uY2U/OiBib29sZWFuKTogRXZlbnREaXNwYXRjaGVyQmluZGluZ1xuICBvbihldmVudDogc3RyaW5nLCBoYW5kbGVyOiBhbnkpIHtcbiAgICBpZiAodGhpcy5nZXRFdmVudEJpbmRpbmdzKGV2ZW50KS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuY29tcG9uZW50LnN1YnNjcmliZShldmVudCkuY2F0Y2goZSA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZSkpXG4gICAgfVxuICAgIHJldHVybiBzdXBlci5vbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGxpc3RlbmVyIGZvciBhbiBzcGVjaWZpYyBldmVudFxuICAgKiBAcGFyYW0gZXZlbnQgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSBiaW5kaW5nIEEgcmVmZXJlbmNlIHRvIGEgYmluZGluZyByZXR1cm5lZCBieSBhIHByZXZpb3VzIGBhZGRFdmVudExpc3RlbmVyYCBjYWxsXG4gICAqL1xuICBvZmYoZXZlbnQ6IHN0cmluZyB8IEV2ZW50RGlzcGF0Y2hlckJpbmRpbmcgfCBGdW5jdGlvbikge1xuICAgIGxldCB0aGVFdmVudFRvVmFsaWRhdGU6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gICAgY29uc3Qgb2ZmUmVzdWx0ID0gc3VwZXIub2ZmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcblxuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGVFdmVudFRvVmFsaWRhdGUgPSBldmVudFxuICAgIH0gZWxzZSBpZiAoZXZlbnQgaW5zdGFuY2VvZiBFdmVudERpc3BhdGNoZXJCaW5kaW5nKSB7XG4gICAgICBldmVudCA9IGV2ZW50LmV2ZW50XG4gICAgfVxuXG4gICAgaWYgKHRoZUV2ZW50VG9WYWxpZGF0ZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMuZ2V0RXZlbnRCaW5kaW5ncyh0aGVFdmVudFRvVmFsaWRhdGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBJZiB3ZSBhcmUgcmVtb3ZpbmcgdGhlIGxhc3QgZXZlbnQgbGlzdGVuZXIsIHJlbW92ZSBpdCBhbHNvIGZyb20gdGhlIGNvbXBvbmVudFxuICAgICAgICAvLyB0aGlzIHdpbGwga2VlcCBsaXN0ZW5lcnMgdW5yZWxhdGVkIHRvIHRoZSBjb21wb25lbnQgaW50YWN0XG5cbiAgICAgICAgdGhpcy5jb21wb25lbnQudW5zdWJzY3JpYmUodGhlRXZlbnRUb1ZhbGlkYXRlKS5jYXRjaChlID0+IHRoaXMuZW1pdCgnZXJyb3InLCBlKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2ZmUmVzdWx0XG4gIH1cbn1cbiJdfQ==\n\n//# sourceURL=webpack:///./node_modules/decentraland-rpc/lib/client/EventSubscriber.js?");

/***/ }),

/***/ "./node_modules/decentraland-rpc/lib/client/Script.js":
/*!************************************************************!*\
  !*** ./node_modules/decentraland-rpc/lib/client/Script.js ***!
  \************************************************************/
/*! exports provided: inject, getInjectedAPIs, Script */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inject\", function() { return inject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getInjectedAPIs\", function() { return getInjectedAPIs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Script\", function() { return Script; });\n/* harmony import */ var _common_json_rpc_Client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/json-rpc/Client */ \"./node_modules/decentraland-rpc/lib/common/json-rpc/Client.js\");\n/* harmony import */ var _common_json_rpc_API__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/json-rpc/API */ \"./node_modules/decentraland-rpc/lib/common/json-rpc/API.js\");\n/* harmony import */ var _common_core_isPromiseLike__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/core/isPromiseLike */ \"./node_modules/decentraland-rpc/lib/common/core/isPromiseLike.js\");\n\n\n\nconst loadAPIsNotificationName = 'LoadComponents';\nconst hasSymbol = typeof Symbol === 'function' && Symbol.for;\nconst injectedAPISymbol = hasSymbol ? Symbol('injectedAPIs') : 0xfea0;\nfunction inject(apiName) {\n    if (apiName !== undefined && !apiName) {\n        throw new TypeError('API name cannot be null / empty');\n    }\n    return function (target, propertyKey) {\n        if (typeof propertyKey === 'string') {\n            getInjectedAPIs(target).set(propertyKey, apiName || propertyKey);\n        }\n        else\n            throw new TypeError('Cannot inject APIs with non-string names');\n    };\n}\nfunction getInjectedAPIs(instance) {\n    const instanceAny = instance;\n    instanceAny[injectedAPISymbol] = instanceAny[injectedAPISymbol] || new Map();\n    return instanceAny[injectedAPISymbol];\n}\nasync function _injectAPIs(target) {\n    const injectedMap = getInjectedAPIs(target);\n    if (injectedMap.size === 0)\n        return;\n    await target.loadAPIs(Array.from(injectedMap.values()));\n    injectedMap.forEach(function (apiName, property) {\n        target[property] = target.loadedAPIs[apiName];\n    });\n}\nclass Script extends _common_json_rpc_Client__WEBPACK_IMPORTED_MODULE_0__[\"Client\"] {\n    constructor(transport, opt) {\n        super(opt);\n        this.transport = transport;\n        this.loadedAPIs = {};\n        this.started = false;\n        if (transport.onError) {\n            transport.onError(e => {\n                this.emit('error', e);\n            });\n        }\n        if (transport.onClose) {\n            transport.onClose(() => {\n                this.emit('transportClosed');\n            });\n        }\n        transport.onMessage(message => {\n            this.processMessage(message);\n        });\n        if (transport.onConnect) {\n            transport.onConnect(() => {\n                this.didConnect();\n            });\n        }\n        else {\n            this.didConnect();\n        }\n    }\n    sendMessage(message) {\n        this.transport.sendMessage(message);\n    }\n    async loadAPIs(apiName) {\n        const loadedKeys = Object.keys(this.loadedAPIs);\n        const keysToRequest = apiName.filter(function ($) {\n            return !loadedKeys.includes($);\n        });\n        if (keysToRequest.length) {\n            await this.call(loadAPIsNotificationName, [keysToRequest]);\n            keysToRequest.forEach(async (apiName) => {\n                this.loadedAPIs[apiName] = Object(_common_json_rpc_API__WEBPACK_IMPORTED_MODULE_1__[\"getApi\"])(this, apiName);\n            });\n        }\n        return this.loadedAPIs;\n    }\n    didConnect() {\n        const injection = _injectAPIs(this);\n        super.didConnect();\n        injection\n            .then(() => {\n            if (this.systemDidEnable && !this.started) {\n                this.started = true;\n                try {\n                    const r = this.systemDidEnable();\n                    if (r && Object(_common_core_isPromiseLike__WEBPACK_IMPORTED_MODULE_2__[\"isPromiseLike\"])(r)) {\n                        r.catch(e => this.emit('error', e));\n                    }\n                }\n                catch (e) {\n                    this.emit('error', e);\n                }\n            }\n        })\n            .catch(e => this.emit('error', e));\n    }\n}\nScript.inject = inject;\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2NyaXB0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NsaWVudC9TY3JpcHQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLDJCQUEyQixDQUFBO0FBQ2xELE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQTtBQUUvQyxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sOEJBQThCLENBQUE7QUFHNUQsTUFBTSx3QkFBd0IsR0FBRyxnQkFBZ0IsQ0FBQTtBQU1qRCxNQUFNLFNBQVMsR0FBRyxPQUFPLE1BQU0sS0FBSyxVQUFVLElBQUksTUFBTSxDQUFDLEdBQUcsQ0FBQTtBQUU1RCxNQUFNLGlCQUFpQixHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUE7QUFZckUsTUFBTSxVQUFVLE1BQU0sQ0FBQyxPQUFnQjtJQUNyQyxJQUFJLE9BQU8sS0FBSyxTQUFTLElBQUksQ0FBQyxPQUFPLEVBQUU7UUFDckMsTUFBTSxJQUFJLFNBQVMsQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFBO0tBQ3ZEO0lBQ0QsT0FBTyxVQUEyQixNQUFTLEVBQUUsV0FBb0I7UUFDL0QsSUFBSSxPQUFPLFdBQVcsS0FBSyxRQUFRLEVBQUU7WUFDbkMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxXQUFXLEVBQUUsT0FBTyxJQUFJLFdBQVcsQ0FBQyxDQUFBO1NBQ2pFOztZQUFNLE1BQU0sSUFBSSxTQUFTLENBQUMsMENBQTBDLENBQUMsQ0FBQTtJQUN4RSxDQUFDLENBQUE7QUFDSCxDQUFDO0FBTUQsTUFBTSxVQUFVLGVBQWUsQ0FBbUIsUUFBVztJQUMzRCxNQUFNLFdBQVcsR0FBUSxRQUFRLENBQUE7SUFDakMsV0FBVyxDQUFDLGlCQUFpQixDQUFDLEdBQUcsV0FBVyxDQUFDLGlCQUFpQixDQUFDLElBQUksSUFB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S0FBSyxDQUFDLFVBQVUsRUFBRSxDQUFBO1FBRWxCLFNBQVM7YUFDTixJQUFJLENBQUMsR0FBRyxFQUFFO1lBQ1QsSUFBSSxJQUFJLENBQUMsZUFBZSxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRTtnQkFDekMsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUE7Z0JBQ25CLElBQUk7b0JBQ0YsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFBO29CQUNoQyxJQUFJLENBQUMsSUFBSSxhQUFhLENBQUMsQ0FBQyxDQUFDLEVBQUU7d0JBQ3pCLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFBO3FCQUNwQztpQkFDRjtnQkFBQyxPQUFPLENBQUMsRUFBRTtvQkFDVixJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQTtpQkFDdEI7YUFDRjtRQUNILENBQUMsQ0FBQzthQUNELEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUE7SUFDdEMsQ0FBQzs7QUFwRk0sYUFBTSxHQUFHLE1BQU0sQ0FBQTtBQXVGeEIsT0FBTyxFQUFFLE1BQU0sRUFBRSxDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2xpZW50IH0gZnJvbSAnLi4vY29tbW9uL2pzb24tcnBjL0NsaWVudCdcbmltcG9ydCB7IGdldEFwaSB9IGZyb20gJy4uL2NvbW1vbi9qc29uLXJwYy9BUEknXG5pbXBvcnQgeyBJTG9nT3B0cywgU2NyaXB0aW5nVHJhbnNwb3J0IH0gZnJvbSAnLi4vY29tbW9uL2pzb24tcnBjL3R5cGVzJ1xuaW1wb3J0IHsgaXNQcm9taXNlTGlrZSB9IGZyb20gJy4uL2NvbW1vbi9jb3JlL2lzUHJvbWlzZUxpa2UnXG5cbi8qKiB0aGlzIGlzIGRlZmluZWQgaW4gdGhlIGNvbnN0cnVjdG9yIFNjcmlwdGluZ0hvc3QoKSAqL1xuY29uc3QgbG9hZEFQSXNOb3RpZmljYXRpb25OYW1lID0gJ0xvYWRDb21wb25lbnRzJ1xuXG4vLyBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG5cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuY29uc3QgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yXG5cbmNvbnN0IGluamVjdGVkQVBJU3ltYm9sID0gaGFzU3ltYm9sID8gU3ltYm9sKCdpbmplY3RlZEFQSXMnKSA6IDB4ZmVhMFxuXG5pbnRlcmZhY2UgU2NyaXB0IHtcbiAgc3lzdGVtRGlkRW5hYmxlPygpOiBQcm9taXNlPHZvaWQ+IHwgdm9pZFxufVxuXG5leHBvcnQgdHlwZSBBUEkgPSBhbnlcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGRlY29yYXRlcyBwYXJhbWV0ZXJzIHRvIGxvYWQgQVBJc1xuICogQHBhcmFtIGFwaU5hbWUgbmFtZSBvZiB0aGUgQVBJIHRvIGxvYWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluamVjdChhcGlOYW1lPzogc3RyaW5nKSB7XG4gIGlmIChhcGlOYW1lICE9PSB1bmRlZmluZWQgJiYgIWFwaU5hbWUpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBUEkgbmFtZSBjYW5ub3QgYmUgbnVsbCAvIGVtcHR5JylcbiAgfVxuICByZXR1cm4gZnVuY3Rpb248VCBleHRlbmRzIFNjcmlwdD4odGFyZ2V0OiBULCBwcm9wZXJ0eUtleToga2V5b2YgVCkge1xuICAgIGlmICh0eXBlb2YgcHJvcGVydHlLZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBnZXRJbmplY3RlZEFQSXModGFyZ2V0KS5zZXQocHJvcGVydHlLZXksIGFwaU5hbWUgfHwgcHJvcGVydHlLZXkpXG4gICAgfSBlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBpbmplY3QgQVBJcyB3aXRoIG5vbi1zdHJpbmcgbmFtZXMnKVxuICB9XG59XG5cbi8qKlxuICogR2V0cyBhbGwgdGhlIGluamVjdGVkIEFQSXMgb2YgYSBzY3JpcHRcbiAqIEBwYXJhbSBpbnN0YW5jZSBBIHNjcmlwdCB0byBnZXQgdGhlIEFQSXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEluamVjdGVkQVBJczxUIGV4dGVuZHMgU2NyaXB0PihpbnN0YW5jZTogVCk6IE1hcDxrZXlvZiBULCBzdHJpbmc+IHtcbiAgY29uc3QgaW5zdGFuY2VBbnk6IGFueSA9IGluc3RhbmNlXG4gIGluc3RhbmNlQW55W2luamVjdGVkQVBJU3ltYm9sXSA9IGluc3RhbmNlQW55W2luamVjdGVkQVBJU3ltYm9sXSB8fCBuZXcgTWFwKClcbiAgcmV0dXJuIGluc3RhbmNlQW55W2luamVjdGVkQVBJU3ltYm9sXVxufVxuXG5hc3luYyBmdW5jdGlvbiBfaW5qZWN0QVBJcyh0YXJnZXQ6IFNjcmlwdCkge1xuICBjb25zdCBpbmplY3RlZE1hcCA9IGdldEluamVjdGVkQVBJcyh0YXJnZXQpXG5cbiAgaWYgKGluamVjdGVkTWFwLnNpemUgPT09IDApIHJldHVyblxuXG4gIGF3YWl0IHRhcmdldC5sb2FkQVBJcyhBcnJheS5mcm9tKGluamVjdGVkTWFwLnZhbHVlcygpKSlcblxuICBpbmplY3RlZE1hcC5mb3JFYWNoKGZ1bmN0aW9uKGFwaU5hbWU6IHN0cmluZywgcHJvcGVydHkpIHtcbiAgICB0YXJnZXRbcHJvcGVydHldID0gdGFyZ2V0LmxvYWRlZEFQSXNbYXBpTmFtZV1cbiAgfSlcbn1cblxuY2xhc3MgU2NyaXB0IGV4dGVuZHMgQ2xpZW50IHtcbiAgc3RhdGljIGluamVjdCA9IGluamVjdFxuXG4gIGxvYWRlZEFQSXM6IHsgW2tleTogc3RyaW5nXTogQVBJIH0gPSB7fVxuXG4gIHByb3RlY3RlZCBzdGFydGVkID0gZmFsc2VcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHRyYW5zcG9ydDogU2NyaXB0aW5nVHJhbnNwb3J0LCBvcHQ/OiBJTG9nT3B0cykge1xuICAgIHN1cGVyKG9wdClcblxuICAgIGlmICh0cmFuc3BvcnQub25FcnJvcikge1xuICAgICAgdHJhbnNwb3J0Lm9uRXJyb3IoZSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAodHJhbnNwb3J0Lm9uQ2xvc2UpIHtcbiAgICAgIHRyYW5zcG9ydC5vbkNsb3NlKCgpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KCd0cmFuc3BvcnRDbG9zZWQnKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0cmFuc3BvcnQub25NZXNzYWdlKG1lc3NhZ2UgPT4ge1xuICAgICAgdGhpcy5wcm9jZXNzTWVzc2FnZShtZXNzYWdlKVxuICAgIH0pXG5cbiAgICBpZiAodHJhbnNwb3J0Lm9uQ29ubmVjdCkge1xuICAgICAgdHJhbnNwb3J0Lm9uQ29ubmVjdCgoKSA9PiB7XG4gICAgICAgIHRoaXMuZGlkQ29ubmVjdCgpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpZENvbm5lY3QoKVxuICAgIH1cbiAgfVxuXG4gIHNlbmRNZXNzYWdlKG1lc3NhZ2U6IHN0cmluZykge1xuICAgIHRoaXMudHJhbnNwb3J0LnNlbmRNZXNzYWdlKG1lc3NhZ2UpXG4gIH1cblxuICAvKipcbiAgICogUHJvdmlkZSBhIGdsb2JhbCBwb2ludCBvZiBhY2Nlc3MgdG8gYSBzZXJ2aWNlIHdpdGhvdXRcbiAgICogY291cGxpbmcgdXNlcnMgdG8gdGhlIGNvbmNyZXRlIGNsYXNzIHRoYXQgaW1wbGVtZW50cyBpdC5cbiAgICpcbiAgICogQHBhcmFtIGFwaU5hbWUgTmFtZSBvZiB0aGUgcGx1Z2luIHdlIGFyZSB0cnlpbmcgdG8gb2J0YWluXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IGxvYWRlZEFQSXNcbiAgICovXG4gIGFzeW5jIGxvYWRBUElzKGFwaU5hbWU6IHN0cmluZ1tdKTogUHJvbWlzZTx7IFtrZXk6IHN0cmluZ106IGFueSB9PiB7XG4gICAgY29uc3QgbG9hZGVkS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMubG9hZGVkQVBJcylcblxuICAgIGNvbnN0IGtleXNUb1JlcXVlc3QgPSBhcGlOYW1lLmZpbHRlcihmdW5jdGlvbigkKSB7XG4gICAgICByZXR1cm4gIWxvYWRlZEtleXMuaW5jbHVkZXMoJClcbiAgICB9KVxuXG4gICAgaWYgKGtleXNUb1JlcXVlc3QubGVuZ3RoKSB7XG4gICAgICBhd2FpdCB0aGlzLmNhbGwobG9hZEFQSXNOb3RpZmljYXRpb25OYW1lLCBba2V5c1RvUmVxdWVzdF0pXG5cbiAgICAgIC8vIExvYWQgLyByZXF1ZXN0IHRoZSBBUElcbiAgICAgIGtleXNUb1JlcXVlc3QuZm9yRWFjaChhc3luYyBhcGlOYW1lID0+IHtcbiAgICAgICAgdGhpcy5sb2FkZWRBUElzW2FwaU5hbWVdID0gZ2V0QXBpKHRoaXMsIGFwaU5hbWUpXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmxvYWRlZEFQSXNcbiAgfVxuXG4gIHByb3RlY3RlZCBkaWRDb25uZWN0KCkge1xuICAgIGNvbnN0IGluamVjdGlvbiA9IF9pbmplY3RBUElzKHRoaXMpXG5cbiAgICBzdXBlci5kaWRDb25uZWN0KClcblxuICAgIGluamVjdGlvblxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5zeXN0ZW1EaWRFbmFibGUgJiYgIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgciA9IHRoaXMuc3lzdGVtRGlkRW5hYmxlKClcbiAgICAgICAgICAgIGlmIChyICYmIGlzUHJvbWlzZUxpa2UocikpIHtcbiAgICAgICAgICAgICAgci5jYXRjaChlID0+IHRoaXMuZW1pdCgnZXJyb3InLCBlKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZSA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZSkpXG4gIH1cbn1cblxuZXhwb3J0IHsgU2NyaXB0IH1cbiJdfQ==\n\n//# sourceURL=webpack:///./node_modules/decentraland-rpc/lib/client/Script.js?");

/***/ }),

/***/ "./node_modules/decentraland-rpc/lib/client/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/decentraland-rpc/lib/client/index.js ***!
  \***********************************************************/
/*! exports provided: WebWorkerTransport, WebSocketTransport, MemoryTransport, inject, getInjectedAPIs, Script, EventSubscriber */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Script__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Script */ \"./node_modules/decentraland-rpc/lib/client/Script.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"inject\", function() { return _Script__WEBPACK_IMPORTED_MODULE_0__[\"inject\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getInjectedAPIs\", function() { return _Script__WEBPACK_IMPORTED_MODULE_0__[\"getInjectedAPIs\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Script\", function() { return _Script__WEBPACK_IMPORTED_MODULE_0__[\"Script\"]; });\n\n/* harmony import */ var _EventSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EventSubscriber */ \"./node_modules/decentraland-rpc/lib/client/EventSubscriber.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"EventSubscriber\", function() { return _EventSubscriber__WEBPACK_IMPORTED_MODULE_1__[\"EventSubscriber\"]; });\n\n/* harmony import */ var _common_transports_WebWorker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/transports/WebWorker */ \"./node_modules/decentraland-rpc/lib/common/transports/WebWorker.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"WebWorkerTransport\", function() { return _common_transports_WebWorker__WEBPACK_IMPORTED_MODULE_2__[\"WebWorkerTransport\"]; });\n\n/* harmony import */ var _common_transports_WebSocket__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/transports/WebSocket */ \"./node_modules/decentraland-rpc/lib/common/transports/WebSocket.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"WebSocketTransport\", function() { return _common_transports_WebSocket__WEBPACK_IMPORTED_MODULE_3__[\"WebSocketTransport\"]; });\n\n/* harmony import */ var _common_transports_Memory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/transports/Memory */ \"./node_modules/decentraland-rpc/lib/common/transports/Memory.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MemoryTransport\", function() { return _common_transports_Memory__WEBPACK_IMPORTED_MODULE_4__[\"MemoryTransport\"]; });\n\n\n\n\n\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvY2xpZW50L2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBLGNBQWMsVUFBVSxDQUFBO0FBQ3hCLGNBQWMsbUJBQW1CLENBQUE7QUFFakMsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sZ0NBQWdDLENBQUE7QUFDbkUsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sZ0NBQWdDLENBQUE7QUFDbkUsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLDZCQUE2QixDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiLy8gRXhwb3J0c1xuXG5leHBvcnQgKiBmcm9tICcuL1NjcmlwdCdcbmV4cG9ydCAqIGZyb20gJy4vRXZlbnRTdWJzY3JpYmVyJ1xuXG5leHBvcnQgeyBXZWJXb3JrZXJUcmFuc3BvcnQgfSBmcm9tICcuLi9jb21tb24vdHJhbnNwb3J0cy9XZWJXb3JrZXInXG5leHBvcnQgeyBXZWJTb2NrZXRUcmFuc3BvcnQgfSBmcm9tICcuLi9jb21tb24vdHJhbnNwb3J0cy9XZWJTb2NrZXQnXG5leHBvcnQgeyBNZW1vcnlUcmFuc3BvcnQgfSBmcm9tICcuLi9jb21tb24vdHJhbnNwb3J0cy9NZW1vcnknXG4iXX0=\n\n//# sourceURL=webpack:///./node_modules/decentraland-rpc/lib/client/index.js?");

/***/ }),

/***/ "./node_modules/decentraland-rpc/lib/common/core/EventDispatcher.js":
/*!**************************************************************************!*\
  !*** ./node_modules/decentraland-rpc/lib/common/core/EventDispatcher.js ***!
  \**************************************************************************/
/*! exports provided: EventDispatcherBinding, EventDispatcher */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EventDispatcherBinding\", function() { return EventDispatcherBinding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EventDispatcher\", function() { return EventDispatcher; });\nconst eventSplitter = /\\s+/g;\nclass EventDispatcherBinding {\n    constructor(id, cb, event, sharedList, object) {\n        this.id = id;\n        this.cb = cb;\n        this.event = event;\n        this.sharedList = sharedList;\n        this.object = object;\n        this.enabled = true;\n    }\n    off() {\n        if (this.object) {\n            this.cb && this.object.off(this);\n            this.cb = null;\n            this.object = null;\n            if (this.sharedList) {\n                delete this.sharedList;\n            }\n        }\n    }\n    enable() {\n        if (this.sharedList) {\n            for (let i = 0; i < this.sharedList.length; i++) {\n                this.sharedList[i].enabled = true;\n            }\n        }\n        else\n            this.enabled = true;\n    }\n    disable() {\n        if (this.sharedList) {\n            for (let i = 0; i < this.sharedList.length; i++) {\n                this.sharedList[i].enabled = false;\n            }\n        }\n        else {\n            this.enabled = false;\n        }\n    }\n}\nfunction turnOffCallback(f) {\n    delete f.cb;\n}\nclass EventDispatcher {\n    constructor() {\n        this.edBindings = {};\n        this.edBindCount = 0;\n    }\n    on(event, callback, once) {\n        this.edBindCount++;\n        let events = event.split(eventSplitter);\n        let bindList = [];\n        let latest = null;\n        for (let evt of events) {\n            let tmp = new EventDispatcherBinding(this.edBindCount, null, evt, bindList, this);\n            bindList && bindList.push(tmp);\n            if (once) {\n                tmp.cb = function () {\n                    callback.apply(this, arguments);\n                    tmp.cb = null;\n                }.bind(this);\n            }\n            else {\n                tmp.cb = callback.bind(this);\n            }\n            this.edBindings[evt] = this.edBindings[evt] || [];\n            this.edBindings[evt].push(tmp);\n            latest = tmp;\n        }\n        return latest;\n    }\n    once(event, callback) {\n        return this.on(event, callback, true);\n    }\n    off(arg0, arg1) {\n        if (arguments.length === 0) {\n            for (let i in this.edBindings) {\n                for (let e in this.edBindings[i]) {\n                    delete this.edBindings[i][e].cb;\n                }\n                this.edBindings[i].length = 0;\n            }\n        }\n        else if (arg0 instanceof EventDispatcherBinding) {\n            arg0.cb = null;\n            arg0.sharedList && arg0.sharedList.length && arg0.sharedList.forEach(turnOffCallback);\n        }\n        else if (typeof arg0 === 'string') {\n            if (typeof arg1 === 'function') {\n                for (let i in this.edBindings[arg0]) {\n                    if (this.edBindings[arg0][i].cb === arg1) {\n                        this.edBindings[arg0][i].cb = null;\n                    }\n                }\n            }\n            else if (typeof arg0 === 'string') {\n                this.edBindings[arg0] = [];\n            }\n        }\n        else if (typeof arg0 === 'function') {\n            for (let evt in this.edBindings) {\n                for (let i in this.edBindings[evt]) {\n                    if (this.edBindings[evt][i].cb === arg0) {\n                        this.edBindings[evt][i].cb = null;\n                    }\n                }\n            }\n        }\n    }\n    emit(event) {\n        if (event in this.edBindings) {\n            if (arguments.length === 1) {\n                for (let i = 0; i < this.edBindings[event].length; i++) {\n                    let e = this.edBindings[event][i];\n                    e && e.cb && e.enabled && e.cb();\n                }\n            }\n            else if (arguments.length === 2) {\n                for (let i = 0; i < this.edBindings[event].length; i++) {\n                    let e = this.edBindings[event][i];\n                    e && e.cb && e.enabled && e.cb(arguments[1]);\n                }\n            }\n            else if (arguments.length === 3) {\n                for (let i = 0; i < this.edBindings[event].length; i++) {\n                    let e = this.edBindings[event][i];\n                    e && e.cb && e.enabled && e.cb(arguments[1], arguments[2]);\n                }\n            }\n            else if (arguments.length === 4) {\n                for (let i = 0; i < this.edBindings[event].length; i++) {\n                    let e = this.edBindings[event][i];\n                    e && e.cb && e.enabled && e.cb(arguments[1], arguments[2], arguments[3]);\n                }\n            }\n            else if (arguments.length === 5) {\n                for (let i = 0; i < this.edBindings[event].length; i++) {\n                    let e = this.edBindings[event][i];\n                    e && e.cb && e.enabled && e.cb(arguments[1], arguments[2], arguments[3], arguments[4]);\n                }\n            }\n            else if (arguments.length > 4) {\n                let args = Array.prototype.slice.call(arguments, 1);\n                for (let i = 0; i < this.edBindings[event].length; i++) {\n                    let e = this.edBindings[event][i];\n                    e && e.cb && e.enabled && e.cb.apply(this, args);\n                }\n            }\n        }\n        else if (event === 'error') {\n            const firstArgument = arguments[1];\n            let error = null;\n            if (firstArgument instanceof Error) {\n                error = firstArgument;\n            }\n            else {\n                error = Object.assign(new Error('EventDispatcher: Unhandled \"error\" event'), { data: arguments });\n            }\n            console.error(error);\n            console.trace(arguments);\n            throw error;\n        }\n    }\n    getEventBindings(event) {\n        return (this.edBindings[event] || []).filter($ => $ && $.enabled);\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRXZlbnREaXNwYXRjaGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbW1vbi9jb3JlL0V2ZW50RGlzcGF0Y2hlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFJQSxNQUFNLGFBQWEsR0FBRyxNQUFNLENBQUE7QUFFNUIsTUFBTSxPQUFPLHNCQUFzQjtJQUVqQyxZQUNTLEVBQVUsRUFDVixFQUFtQixFQUNuQixLQUFhLEVBQ2IsVUFBb0MsRUFDcEMsTUFBbUM7UUFKbkMsT0FBRSxHQUFGLEVBQUUsQ0FBUTtRQUNWLE9BQUUsR0FBRixFQUFFLENBQWlCO1FBQ25CLFVBQUssR0FBTCxLQUFLLENBQVE7UUFDYixlQUFVLEdBQVYsVUFBVSxDQUEwQjtRQUNwQyxXQUFNLEdBQU4sTUFBTSxDQUE2QjtRQU41QyxZQUFPLEdBQVksSUFBSSxDQUFBO0lBT3BCLENBQUM7SUFFSixHQUFHO1FBQ0QsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ2YsSUFBSSxDQUFDLEVBQUUsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQTtZQUNoQyxJQUFJLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQTtZQUNkLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFBO1lBQ2xCLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtnQkFDbkIsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFBO2FBQ3ZCO1NBQ0Y7SUFDSCxDQUFDO0lBRUQsTUFBTTtRQUNKLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUNuQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQy9DLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQTthQUNsQztTQUNGOztZQUFNLElBQUks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QUMsS0FBYTtRQUN0QyxPQUFPLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFBO0lBQ25FLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBpbnRlcmZhY2UgRGljdGlvbmFyeTxUID0gYW55PiB7XG4gIFtrZXk6IHN0cmluZ106IFRcbn1cblxuY29uc3QgZXZlbnRTcGxpdHRlciA9IC9cXHMrL2dcblxuZXhwb3J0IGNsYXNzIEV2ZW50RGlzcGF0Y2hlckJpbmRpbmcge1xuICBlbmFibGVkOiBib29sZWFuID0gdHJ1ZVxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgaWQ6IG51bWJlcixcbiAgICBwdWJsaWMgY2I6IEZ1bmN0aW9uIHwgbnVsbCxcbiAgICBwdWJsaWMgZXZlbnQ6IHN0cmluZyxcbiAgICBwdWJsaWMgc2hhcmVkTGlzdDogRXZlbnREaXNwYXRjaGVyQmluZGluZ1tdLFxuICAgIHB1YmxpYyBvYmplY3Q6IEV2ZW50RGlzcGF0Y2hlcjxhbnk+IHwgbnVsbFxuICApIHt9XG5cbiAgb2ZmKCkge1xuICAgIGlmICh0aGlzLm9iamVjdCkge1xuICAgICAgdGhpcy5jYiAmJiB0aGlzLm9iamVjdC5vZmYodGhpcylcbiAgICAgIHRoaXMuY2IgPSBudWxsXG4gICAgICB0aGlzLm9iamVjdCA9IG51bGxcbiAgICAgIGlmICh0aGlzLnNoYXJlZExpc3QpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc2hhcmVkTGlzdFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVuYWJsZSgpIHtcbiAgICBpZiAodGhpcy5zaGFyZWRMaXN0KSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2hhcmVkTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnNoYXJlZExpc3RbaV0uZW5hYmxlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2UgdGhpcy5lbmFibGVkID0gdHJ1ZVxuICB9XG5cbiAgZGlzYWJsZSgpIHtcbiAgICBpZiAodGhpcy5zaGFyZWRMaXN0KSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2hhcmVkTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnNoYXJlZExpc3RbaV0uZW5hYmxlZCA9IGZhbHNlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHR1cm5PZmZDYWxsYmFjayhmOiBFdmVudERpc3BhdGNoZXJCaW5kaW5nKSB7XG4gIGRlbGV0ZSBmLmNiXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnREaXNwYXRjaGVyRXZlbnRzQmFzZSB7XG4gIFtrZXk6IHN0cmluZ106IEZ1bmN0aW9uXG59XG5cbmV4cG9ydCBjbGFzcyBFdmVudERpc3BhdGNoZXI8VCA9IEV2ZW50RGlzcGF0Y2hlckV2ZW50c0Jhc2U+IHtcbiAgcHJpdmF0ZSBlZEJpbmRpbmdzOiBEaWN0aW9uYXJ5PEV2ZW50RGlzcGF0Y2hlckJpbmRpbmdbXT4gPSB7fVxuICBwcml2YXRlIGVkQmluZENvdW50ID0gMFxuXG4gIG9uPEsgZXh0ZW5kcyBrZXlvZiBUPihldmVudDogSywgY2FsbGJhY2s6IFRbS10sIG9uY2U/OiBib29sZWFuKTogRXZlbnREaXNwYXRjaGVyQmluZGluZ1xuICBvbihldmVudDogc3RyaW5nLCBjYWxsYmFjazogKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkLCBvbmNlPzogYm9vbGVhbik6IEV2ZW50RGlzcGF0Y2hlckJpbmRpbmdcbiAgb24oZXZlbnQ6IHN0cmluZywgY2FsbGJhY2s6IGFueSwgb25jZT86IGJvb2xlYW4pOiBFdmVudERpc3BhdGNoZXJCaW5kaW5nIHtcbiAgICB0aGlzLmVkQmluZENvdW50KytcblxuICAgIGxldCBldmVudHMgPSBldmVudC5zcGxpdChldmVudFNwbGl0dGVyKVxuXG4gICAgbGV0IGJpbmRMaXN0OiBFdmVudERpc3BhdGNoZXJCaW5kaW5nW10gPSBbXVxuICAgIGxldCBsYXRlc3Q6IEV2ZW50RGlzcGF0Y2hlckJpbmRpbmcgfCBudWxsID0gbnVsbFxuXG4gICAgZm9yIChsZXQgZXZ0IG9mIGV2ZW50cykge1xuICAgICAgbGV0IHRtcCA9IG5ldyBFdmVudERpc3BhdGNoZXJCaW5kaW5nKHRoaXMuZWRCaW5kQ291bnQsIG51bGwsIGV2dCwgYmluZExpc3QsIHRoaXMpXG5cbiAgICAgIGJpbmRMaXN0ICYmIGJpbmRMaXN0LnB1c2godG1wKVxuXG4gICAgICBpZiAob25jZSkge1xuICAgICAgICB0bXAuY2IgPSBmdW5jdGlvbih0aGlzOiBFdmVudERpc3BhdGNoZXI8VD4pIHtcbiAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgdG1wLmNiID0gbnVsbFxuICAgICAgICB9LmJpbmQodGhpcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRtcC5jYiA9IGNhbGxiYWNrLmJpbmQodGhpcylcbiAgICAgIH1cblxuICAgICAgdGhpcy5lZEJpbmRpbmdzW2V2dF0gPSB0aGlzLmVkQmluZGluZ3NbZXZ0XSB8fCBbXVxuICAgICAgdGhpcy5lZEJpbmRpbmdzW2V2dF0ucHVzaCh0bXApXG5cbiAgICAgIGxhdGVzdCA9IHRtcFxuICAgIH1cblxuICAgIHJldHVybiBsYXRlc3QgYXMgRXZlbnREaXNwYXRjaGVyQmluZGluZ1xuICB9XG5cbiAgb25jZTxLIGV4dGVuZHMga2V5b2YgVD4oZXZlbnQ6IEssIGNhbGxiYWNrOiBUW0tdKTogRXZlbnREaXNwYXRjaGVyQmluZGluZ1xuICBvbmNlKGV2ZW50OiBzdHJpbmcsIGNhbGxiYWNrOiBGdW5jdGlvbik6IEV2ZW50RGlzcGF0Y2hlckJpbmRpbmdcbiAgb25jZShldmVudDogc3RyaW5nLCBjYWxsYmFjazogYW55KSB7XG4gICAgcmV0dXJuIHRoaXMub24oZXZlbnQsIGNhbGxiYWNrLCB0cnVlKVxuICB9XG5cbiAgb2ZmKGJpbmRpbmc6IEV2ZW50RGlzcGF0Y2hlckJpbmRpbmcpOiB2b2lkXG4gIG9mZihldmVudE5hbWU6IHN0cmluZywgYm91bmRDYWxsYmFjaz86IEZ1bmN0aW9uKTogdm9pZFxuICBvZmYoYm91bmRDYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkXG4gIG9mZihhcmcwPzogc3RyaW5nIHwgRnVuY3Rpb24gfCBFdmVudERpc3BhdGNoZXJCaW5kaW5nLCBhcmcxPzogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZm9yIChsZXQgaSBpbiB0aGlzLmVkQmluZGluZ3MpIHtcbiAgICAgICAgZm9yIChsZXQgZSBpbiB0aGlzLmVkQmluZGluZ3NbaV0pIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5lZEJpbmRpbmdzW2ldW2VdLmNiXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZEJpbmRpbmdzW2ldLmxlbmd0aCA9IDBcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFyZzAgaW5zdGFuY2VvZiBFdmVudERpc3BhdGNoZXJCaW5kaW5nKSB7XG4gICAgICBhcmcwLmNiID0gbnVsbFxuICAgICAgYXJnMC5zaGFyZWRMaXN0ICYmIGFyZzAuc2hhcmVkTGlzdC5sZW5ndGggJiYgYXJnMC5zaGFyZWRMaXN0LmZvckVhY2godHVybk9mZkNhbGxiYWNrKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm9yIChsZXQgaSBpbiB0aGlzLmVkQmluZGluZ3NbYXJnMF0pIHtcbiAgICAgICAgICBpZiAodGhpcy5lZEJpbmRpbmdzW2FyZzBdW2ldLmNiID09PSBhcmcxKSB7XG4gICAgICAgICAgICB0aGlzLmVkQmluZGluZ3NbYXJnMF1baV0uY2IgPSBudWxsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiAoYXJnMCBhcyBhbnkpID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLmVkQmluZGluZ3NbYXJnMF0gPSBbXVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZvciAobGV0IGV2dCBpbiB0aGlzLmVkQmluZGluZ3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSBpbiB0aGlzLmVkQmluZGluZ3NbZXZ0XSkge1xuICAgICAgICAgIGlmICh0aGlzLmVkQmluZGluZ3NbZXZ0XVtpXS5jYiA9PT0gYXJnMCkge1xuICAgICAgICAgICAgdGhpcy5lZEJpbmRpbmdzW2V2dF1baV0uY2IgPSBudWxsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZW1pdChldmVudDogJ2Vycm9yJywgZXJyb3I6IGFueSk6IHZvaWRcbiAgZW1pdDxLIGV4dGVuZHMga2V5b2YgVD4oZXZlbnQ6IEssIC4uLnBhcmFtczogYW55W10pOiB2b2lkXG4gIGVtaXQoZXZlbnQ6IHN0cmluZywgLi4ucGFyYW1zOiBhbnlbXSk6IHZvaWRcbiAgZW1pdChldmVudDogc3RyaW5nKSB7XG4gICAgaWYgKGV2ZW50IGluIHRoaXMuZWRCaW5kaW5ncykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmVkQmluZGluZ3NbZXZlbnRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGV0IGUgPSB0aGlzLmVkQmluZGluZ3NbZXZlbnRdW2ldXG4gICAgICAgICAgZSAmJiBlLmNiICYmIGUuZW5hYmxlZCAmJiBlLmNiKClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5lZEJpbmRpbmdzW2V2ZW50XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBlID0gdGhpcy5lZEJpbmRpbmdzW2V2ZW50XVtpXVxuICAgICAgICAgIGUgJiYgZS5jYiAmJiBlLmVuYWJsZWQgJiYgZS5jYihhcmd1bWVudHNbMV0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZWRCaW5kaW5nc1tldmVudF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgZSA9IHRoaXMuZWRCaW5kaW5nc1tldmVudF1baV1cbiAgICAgICAgICBlICYmIGUuY2IgJiYgZS5lbmFibGVkICYmIGUuY2IoYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZWRCaW5kaW5nc1tldmVudF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgZSA9IHRoaXMuZWRCaW5kaW5nc1tldmVudF1baV1cbiAgICAgICAgICBlICYmIGUuY2IgJiYgZS5lbmFibGVkICYmIGUuY2IoYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA1KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5lZEJpbmRpbmdzW2V2ZW50XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBlID0gdGhpcy5lZEJpbmRpbmdzW2V2ZW50XVtpXVxuICAgICAgICAgIGUgJiYgZS5jYiAmJiBlLmVuYWJsZWQgJiYgZS5jYihhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdLCBhcmd1bWVudHNbNF0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDQpIHtcbiAgICAgICAgbGV0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmVkQmluZGluZ3NbZXZlbnRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGV0IGUgPSB0aGlzLmVkQmluZGluZ3NbZXZlbnRdW2ldXG4gICAgICAgICAgZSAmJiBlLmNiICYmIGUuZW5hYmxlZCAmJiBlLmNiLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV2ZW50ID09PSAnZXJyb3InKSB7XG4gICAgICBjb25zdCBmaXJzdEFyZ3VtZW50OiBhbnkgPSBhcmd1bWVudHNbMV1cbiAgICAgIGxldCBlcnJvcjogRXJyb3IgfCBudWxsID0gbnVsbFxuXG4gICAgICBpZiAoZmlyc3RBcmd1bWVudCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGVycm9yID0gZmlyc3RBcmd1bWVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IgPSBPYmplY3QuYXNzaWduKG5ldyBFcnJvcignRXZlbnREaXNwYXRjaGVyOiBVbmhhbmRsZWQgXCJlcnJvclwiIGV2ZW50JyksIHsgZGF0YTogYXJndW1lbnRzIH0pXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpXG4gICAgICBjb25zb2xlLnRyYWNlKGFyZ3VtZW50cylcblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0RXZlbnRCaW5kaW5ncyhldmVudDogc3RyaW5nKSB7XG4gICAgcmV0dXJuICh0aGlzLmVkQmluZGluZ3NbZXZlbnRdIHx8IFtdKS5maWx0ZXIoJCA9PiAkICYmICQuZW5hYmxlZClcbiAgfVxufVxuIl19\n\n//# sourceURL=webpack:///./node_modules/decentraland-rpc/lib/common/core/EventDispatcher.js?");

/***/ }),

/***/ "./node_modules/decentraland-rpc/lib/common/core/isPromiseLike.js":
/*!************************************************************************!*\
  !*** ./node_modules/decentraland-rpc/lib/common/core/isPromiseLike.js ***!
  \************************************************************************/
/*! exports provided: isPromiseLike */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isPromiseLike\", function() { return isPromiseLike; });\nfunction isPromiseLike(thing) {\n    return (thing &&\n        typeof thing === 'object' &&\n        typeof thing['then'] === 'function' &&\n        typeof thing['catch'] === 'function');\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaXNQcm9taXNlTGlrZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21tb24vY29yZS9pc1Byb21pc2VMaWtlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUdBLE1BQU0sVUFBVSxhQUFhLENBQUMsS0FBVTtJQUN0QyxPQUFPLENBQ0wsS0FBSztRQUVMLE9BQU8sS0FBSyxLQUFLLFFBQVE7UUFFekIsT0FBTyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssVUFBVTtRQUVuQyxPQUFPLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxVQUFVLENBQ3JDLENBQUE7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGlzUHJvbWlzZUxpa2UodGhpbmc6IFByb21pc2U8YW55Pik6IHRydWVcbmV4cG9ydCBmdW5jdGlvbiBpc1Byb21pc2VMaWtlKHRoaW5nOiB2b2lkKTogZmFsc2VcbmV4cG9ydCBmdW5jdGlvbiBpc1Byb21pc2VMaWtlKHRoaW5nOiBhbnkpOiBmYWxzZVxuZXhwb3J0IGZ1bmN0aW9uIGlzUHJvbWlzZUxpa2UodGhpbmc6IGFueSk6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIHRoaW5nICYmXG4gICAgLy8gaXQgaXMgYW4gb2JqZWN0XG4gICAgdHlwZW9mIHRoaW5nID09PSAnb2JqZWN0JyAmJlxuICAgIC8vIGl0IGhhcyB0aGVuXG4gICAgdHlwZW9mIHRoaW5nWyd0aGVuJ10gPT09ICdmdW5jdGlvbicgJiZcbiAgICAvLyBpdCBoYXMgY2F0Y2hcbiAgICB0eXBlb2YgdGhpbmdbJ2NhdGNoJ10gPT09ICdmdW5jdGlvbidcbiAgKVxufVxuIl19\n\n//# sourceURL=webpack:///./node_modules/decentraland-rpc/lib/common/core/isPromiseLike.js?");

/***/ }),

/***/ "./node_modules/decentraland-rpc/lib/common/json-rpc/API.js":
/*!******************************************************************!*\
  !*** ./node_modules/decentraland-rpc/lib/common/json-rpc/API.js ***!
  \******************************************************************/
/*! exports provided: getApi */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getApi\", function() { return getApi; });\nconst blacklistedMethods = ['then', 'catch'];\nfunction getApi(rpcClient, _prefix = '') {\n    if (!Proxy) {\n        throw new Error('getApi() requires ES6 Proxy. Please use an ES6 compatible engine');\n    }\n    const prefix = _prefix === '' ? '' : `${_prefix}.`;\n    return new Proxy({}, {\n        get: (target, prop) => {\n            if (target[prop]) {\n                return target[prop];\n            }\n            if (prop === '__proto__' || prop === 'prototype') {\n                return Object.prototype;\n            }\n            else if (prop.substr(0, 2) === 'on' && prop.length > 3) {\n                const method = prop.substr(2);\n                target[prop] = (handler) => rpcClient.on(`${prefix}${method}`, (params) => {\n                    try {\n                        if (params && params instanceof Array) {\n                            handler.apply(null, params);\n                        }\n                        else {\n                            handler.call(null, params);\n                        }\n                    }\n                    catch (e) {\n                        rpcClient.emit('error', e);\n                    }\n                });\n            }\n            else if (prop.substr(0, 4) === 'emit' && prop.length > 5) {\n                const method = prop.substr(4);\n                target[prop] = (...args) => rpcClient.notify(`${prefix}${method}`, args);\n            }\n            else if (blacklistedMethods.indexOf(prop) !== -1) {\n                return undefined;\n            }\n            else {\n                const method = prop;\n                target[prop] = (...args) => rpcClient.call(`${prefix}${method}`, args);\n            }\n            return target[prop];\n        }\n    });\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQVBJLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbW1vbi9qc29uLXJwYy9BUEkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUEsTUFBTSxrQkFBa0IsR0FBRyxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQTtBQVU1QyxNQUFNLFVBQVUsTUFBTSxDQUF5QixTQUFpQixFQUFFLFVBQWtCLEVBQUU7SUFDcEYsSUFBSSxDQUFDLEtBQUssRUFBRTtRQUNWLE1BQU0sSUFBSSxLQUFLLENBQUMsa0VBQWtFLENBQUMsQ0FBQTtLQUNwRjtJQUVELE1BQU0sTUFBTSxHQUFHLE9BQU8sS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLEdBQUcsQ0FBQTtJQUVsRCxPQUFPLElBQUksS0FBSyxDQUFDLEVBQU8sRUFBRTtRQUN4QixHQUFHLEVBQUUsQ0FBQyxNQUFXLEVBQUUsSUFBWSxFQUFFLEVBQUU7WUFDakMsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQ2hCLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFBO2FBQ3BCO1lBRUQsSUFBSSxJQUFJLEtBQUssV0FBVyxJQUFJLElBQUksS0FBSyxXQUFXLEVBQUU7Z0JBQ2hELE9BQU8sTUFBTSxDQUFDLFNBQVMsQ0FBQTthQUN4QjtpQkFBTSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLElBQUksSUFBSSxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtnQkFDeEQsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQTtnQkFDN0IsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBaUIsRUFBRSxFQUFFLENBQ25DLFNBQVMsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLEdBQUcsTUFBTSxFQUFFLEVBQUUsQ0FBQyxNQUFXLEVBQUUsRUFBRTtvQkFDakQsSUFBSTt3QkFDRixJQUFJLE1BQU0sSUFBSSxNQUFNLFlBQVksS0FBSyxFQUFFOzRCQUNyQyxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQTt5QkFDNUI7NkJBQU07NEJBQ0wsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUE7eUJBQzNCO3FCQUNGO29CQUFDLE9BQU8sQ0FBQyxFQUFFO3dCQUNWLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFBO3FCQUMzQjtnQkFDSCxDQUFDLENBQUMsQ0FBQTthQUNMO2lCQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssTUFBTSxJQUFJLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUMxRCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFBO2dCQUM3QixNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQVcsRUFBRSxFQUFFLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxHQUFHLE1BQU0sR0FBRyxNQUFNLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQTthQUNoRjtpQkFBTSxJQUFJLGtCQUFrQixDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtnQkFDbEQsT0FBTyxTQUFTLENBQUE7YUFDakI7aUJBQU07Z0JBQ0wsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFBO2dCQUNuQixNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQVcsRUFBRSxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLE1BQU0sR0FBRyxNQUFNLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQTthQUM5RTtZQUVELE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFBO1FBQ3JCLENBQUM7S0FDRixDQUFDLENBQUE7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2xpZW50IH0gZnJvbSAnLi9DbGllbnQnXG5cbmNvbnN0IGJsYWNrbGlzdGVkTWV0aG9kcyA9IFsndGhlbicsICdjYXRjaCddXG5cbi8qKlxuICogQnVpbGRzIGFuIEVTNiBQcm94eSB3aGVyZSBhcGkuZG9tYWluLm1ldGhvZChwYXJhbXMpIHRyYW5zYXRlcyBpbnRvIGNsaWVudC5zZW5kKCd7ZG9tYWlufS57bWV0aG9kfScsIHBhcmFtcykgY2FsbHNcbiAqIGFwaS5kb21haW4ub257bWV0aG9kfSB3aWxsIGFkZCBldmVudCBoYW5kbGVycyBmb3Ige21ldGhvZH0gZXZlbnRzXG4gKiBhcGkuZG9tYWluLmVtaXR7bWV0aG9kfSB3aWxsIHNlbmQge21ldGhvZH0gbm90aWZpY2F0aW9ucyB0byB0aGUgc2VydmVyXG4gKiBUaGUgYXBpIG9iamVjdCBsZWFkcyBpdHNlbGYgdG8gYSB2ZXJ5IGNsZWFuIGludGVyZmFjZSBpLmUgYGF3YWl0IGFwaS5Eb21haW4uZnVuYyhwYXJhbXMpYCBjYWxsc1xuICogVGhpcyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGFic3RyYWN0IGFsbCB0aGUgaW50ZXJuYWwgZGV0YWlscyBvZiBtYXJzaGFsbGluZyB0aGUgbWVzc2FnZSBmcm9tIGZ1bmN0aW9uIGNhbGwgdG8gYSBzdHJpbmdcbiAqIENhbGxpbmcgY2xpZW50LmFwaSgnJykgd2lsbCByZXR1cm4gYW4gdW5wcmVmaXhlZCBjbGllbnQuIGUuZyBhcGkuaGVsbG8oKSBpcyBlcXVpdmFsaWVudCB0byBjbGllbnQuc2VuZCgnaGVsbG8nKVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXBpPFQgZXh0ZW5kcyBvYmplY3QgPSBhbnk+KHJwY0NsaWVudDogQ2xpZW50LCBfcHJlZml4OiBzdHJpbmcgPSAnJyk6IFQge1xuICBpZiAoIVByb3h5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnZXRBcGkoKSByZXF1aXJlcyBFUzYgUHJveHkuIFBsZWFzZSB1c2UgYW4gRVM2IGNvbXBhdGlibGUgZW5naW5lJylcbiAgfVxuXG4gIGNvbnN0IHByZWZpeCA9IF9wcmVmaXggPT09ICcnID8gJycgOiBgJHtfcHJlZml4fS5gXG5cbiAgcmV0dXJuIG5ldyBQcm94eSh7fSBhcyBULCB7XG4gICAgZ2V0OiAodGFyZ2V0OiBhbnksIHByb3A6IHN0cmluZykgPT4ge1xuICAgICAgaWYgKHRhcmdldFtwcm9wXSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdXG4gICAgICB9XG4gICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBwcm90b3R5cGUgc28gY29uc29sZSBpbnRlbGxpc2Vuc2Ugd29ya3Mgb24gb2JqZWN0c1xuICAgICAgaWYgKHByb3AgPT09ICdfX3Byb3RvX18nIHx8IHByb3AgPT09ICdwcm90b3R5cGUnKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlXG4gICAgICB9IGVsc2UgaWYgKHByb3Auc3Vic3RyKDAsIDIpID09PSAnb24nICYmIHByb3AubGVuZ3RoID4gMykge1xuICAgICAgICBjb25zdCBtZXRob2QgPSBwcm9wLnN1YnN0cigyKVxuICAgICAgICB0YXJnZXRbcHJvcF0gPSAoaGFuZGxlcjogRnVuY3Rpb24pID0+XG4gICAgICAgICAgcnBjQ2xpZW50Lm9uKGAke3ByZWZpeH0ke21ldGhvZH1gLCAocGFyYW1zOiBhbnkpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmFwcGx5KG51bGwsIHBhcmFtcylcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmNhbGwobnVsbCwgcGFyYW1zKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJwY0NsaWVudC5lbWl0KCdlcnJvcicsIGUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAocHJvcC5zdWJzdHIoMCwgNCkgPT09ICdlbWl0JyAmJiBwcm9wLmxlbmd0aCA+IDUpIHtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gcHJvcC5zdWJzdHIoNClcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gKC4uLmFyZ3M6IGFueVtdKSA9PiBycGNDbGllbnQubm90aWZ5KGAke3ByZWZpeH0ke21ldGhvZH1gLCBhcmdzKVxuICAgICAgfSBlbHNlIGlmIChibGFja2xpc3RlZE1ldGhvZHMuaW5kZXhPZihwcm9wKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gcHJvcFxuICAgICAgICB0YXJnZXRbcHJvcF0gPSAoLi4uYXJnczogYW55W10pID0+IHJwY0NsaWVudC5jYWxsKGAke3ByZWZpeH0ke21ldGhvZH1gLCBhcmdzKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdXG4gICAgfVxuICB9KVxufVxuIl19\n\n//# sourceURL=webpack:///./node_modules/decentraland-rpc/lib/common/json-rpc/API.js?");

/***/ }),

/***/ "./node_modules/decentraland-rpc/lib/common/json-rpc/Client.js":
/*!*********************************************************************!*\
  !*** ./node_modules/decentraland-rpc/lib/common/json-rpc/Client.js ***!
  \*********************************************************************/
/*! exports provided: Client */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Client\", function() { return Client; });\n/* harmony import */ var _core_EventDispatcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/EventDispatcher */ \"./node_modules/decentraland-rpc/lib/common/core/EventDispatcher.js\");\n/* harmony import */ var msgpack_lite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! msgpack-lite */ \"./node_modules/msgpack-lite/lib/browser.js\");\n/* harmony import */ var msgpack_lite__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(msgpack_lite__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst codec = Object(msgpack_lite__WEBPACK_IMPORTED_MODULE_1__[\"createCodec\"])();\nclass Client extends _core_EventDispatcher__WEBPACK_IMPORTED_MODULE_0__[\"EventDispatcher\"] {\n    constructor(opts) {\n        super();\n        this.sendEncoding = 'JSON';\n        this._responsePromiseMap = new Map();\n        this._nextMessageId = 0;\n        this._consoleLog = false;\n        this._requestQueue = [];\n        this._connected = false;\n        this.setLogging(opts);\n    }\n    processMessage(messageStr) {\n        let message;\n        if (typeof messageStr === 'string' && messageStr.charAt(0) === '{') {\n            this._logMessage(messageStr, 'receive');\n            try {\n                message = JSON.parse(messageStr);\n            }\n            catch (e) {\n                return this.emit('error', e);\n            }\n        }\n        else if (typeof messageStr === 'string' ||\n            messageStr instanceof Uint8Array ||\n            (typeof Buffer !== 'undefined' && messageStr instanceof Buffer) ||\n            messageStr instanceof Array) {\n            message = Object(msgpack_lite__WEBPACK_IMPORTED_MODULE_1__[\"decode\"])(messageStr, { codec });\n        }\n        else {\n            message = messageStr;\n        }\n        if (!message) {\n            this.emit('error', new Error(`Message cannot be null, empty or undefined`));\n        }\n        else if (message.id) {\n            if (this._responsePromiseMap.has(message.id)) {\n                const promise = this._responsePromiseMap.get(message.id);\n                this._responsePromiseMap.delete(message.id);\n                if ('result' in message) {\n                    promise.resolve(message.result);\n                }\n                else if ('error' in message) {\n                    const error = Object.assign(new Error('Remote error'), message.error, (message.error && message.error.data) || {});\n                    promise.reject(error);\n                }\n                else {\n                    promise.reject(Object.assign(new Error(`Response must have result or error: ${messageStr}`), {\n                        code: -32700\n                    }));\n                }\n            }\n            else {\n                this.emit('error', new Error(`Response with id:${message.id} has no pending request`));\n            }\n        }\n        else if (message.method) {\n            this.emit(message.method, message.params);\n        }\n        else {\n            this.emit('error', new Error(`Invalid message: ${messageStr}`));\n        }\n    }\n    setLogging({ logConsole } = {}) {\n        this._consoleLog = !!logConsole;\n    }\n    call(method, params) {\n        if (typeof params !== 'undefined' && typeof params !== 'object') {\n            throw new Error(`Client#call Params must be structured data (Array | Object) got ${JSON.stringify(params)}`);\n        }\n        const id = ++this._nextMessageId;\n        const message = { id, method, params, jsonrpc: '2.0' };\n        return new Promise((resolve, reject) => {\n            try {\n                this._responsePromiseMap.set(id, { resolve, reject });\n                this._send(message);\n            }\n            catch (error) {\n                return reject(error);\n            }\n        });\n    }\n    notify(method, params) {\n        if (typeof params !== 'undefined' && typeof params !== 'object') {\n            throw new Error(`Client#notify Params must be structured data (Array | Object) got ${JSON.stringify(params)}`);\n        }\n        this._send({ method, params, jsonrpc: '2.0' });\n    }\n    didConnect() {\n        if (this._connected === false) {\n            this._connected = true;\n            this._sendQueuedRequests();\n        }\n    }\n    _send(message) {\n        if (this.sendEncoding === 'msgpack') {\n            this._requestQueue.push(Object(msgpack_lite__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(message, { codec }));\n        }\n        else {\n            this._requestQueue.push(JSON.stringify(message));\n        }\n        this._sendQueuedRequests();\n    }\n    _sendQueuedRequests() {\n        if (this._connected) {\n            const queue = this._requestQueue.splice(0, this._requestQueue.length);\n            for (let messageStr of queue) {\n                this._logMessage(messageStr, 'send');\n                this.sendMessage(messageStr);\n            }\n        }\n    }\n    _logMessage(message, direction) {\n        if (this._consoleLog) {\n            console.log(`Client ${direction === 'send' ? '>' : '<'}`, message.toString());\n        }\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2xpZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbW1vbi9qc29uLXJwYy9DbGllbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHlCQUF5QixDQUFBO0FBRXpELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLGNBQWMsQ0FBQTtBQUUxRCxNQUFNLEtBQUssR0FBRyxXQUFXLEVBQUUsQ0FBQTtBQU0zQixNQUFNLE9BQWdCLE1BQU8sU0FBUSxlQUFlO0lBU2xELFlBQVksSUFBMkI7UUFDckMsS0FBSyxFQUFFLENBQUE7UUFUVCxpQkFBWSxHQUF1QixNQUFNLENBQUE7UUFFakMsd0JBQW1CLEdBQXFDLElBQUksR0FBRyxFQUFFLENBQUE7UUFDakUsbUJBQWMsR0FBVyxDQUFDLENBQUE7UUFDMUIsZ0JBQVcsR0FBWSxLQUFLLENBQUE7UUFDNUIsa0JBQWEsR0FBd0IsRUFBRSxDQUFBO1FBQ3ZDLGVBQVUsR0FBRyxLQUFLLENBQUE7UUFJeEIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQTtJQUN2QixDQUFDO0lBSU0sY0FBYyxDQUNuQixVQUFtRztRQUVuRyxJQUFJLE9BQW9ELENBQUE7UUFFeEQsSUFBSSxPQUFPLFVBQVUsS0FBSyxRQUFRLElBQUksVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLEVBQUU7WUFDbEUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLEVBQUUsU0FBUyxDQUFDLENBQUE7WUFHdkMsSUFBSTtnQkFDRixPQUFPLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQTthQUNqQztZQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUNWLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUE7YUFDN0I7U0FDRjthQUFNLElBQ0ws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U0FDakQ7UUFDRCxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQTtJQUM1QixDQUFDO0lBRU8sbUJBQW1CO1FBQ3pCLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUNuQixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQTtZQUNyRSxLQUFLLElBQUksVUFBVSxJQUFJLEtBQUssRUFBRTtnQkFDNUIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLEVBQUUsTUFBTSxDQUFDLENBQUE7Z0JBQ3BDLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLENBQUE7YUFDN0I7U0FDRjtJQUNILENBQUM7SUFFTyxXQUFXLENBQUMsT0FBd0IsRUFBRSxTQUE2QjtRQUN6RSxJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDcEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxVQUFVLFNBQVMsS0FBSyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUE7U0FDOUU7SUFDSCxDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudERpc3BhdGNoZXIgfSBmcm9tICcuLi9jb3JlL0V2ZW50RGlzcGF0Y2hlcidcbmltcG9ydCAqIGFzIEpzb25ScGMyIGZyb20gJy4vdHlwZXMnXG5pbXBvcnQgeyBjcmVhdGVDb2RlYywgZW5jb2RlLCBkZWNvZGUgfSBmcm9tICdtc2dwYWNrLWxpdGUnXG5cbmNvbnN0IGNvZGVjID0gY3JlYXRlQ29kZWMoKVxuXG4vKipcbiAqIENyZWF0ZXMgYSBSUEMgQ2xpZW50LlxuICogSXQgaXMgaW50ZW50aW9uYWwgdGhhdCBDbGllbnQgZG9lcyBub3QgY3JlYXRlIGEgV2ViU29ja2V0IG9iamVjdCBzaW5jZSB3ZSBwcmVmZXIgY29tcG9zYWJpbGl0eVxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQ2xpZW50IGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIGltcGxlbWVudHMgSnNvblJwYzIuSUNsaWVudCB7XG4gIHNlbmRFbmNvZGluZzogJ0pTT04nIHwgJ21zZ3BhY2snID0gJ0pTT04nXG5cbiAgcHJpdmF0ZSBfcmVzcG9uc2VQcm9taXNlTWFwOiBNYXA8bnVtYmVyLCBKc29uUnBjMi5SZXNvbHZhYmxlPiA9IG5ldyBNYXAoKVxuICBwcml2YXRlIF9uZXh0TWVzc2FnZUlkOiBudW1iZXIgPSAwXG4gIHByaXZhdGUgX2NvbnNvbGVMb2c6IGJvb2xlYW4gPSBmYWxzZVxuICBwcml2YXRlIF9yZXF1ZXN0UXVldWU6IChzdHJpbmcgfCBCdWZmZXIpW10gPSBbXVxuICBwcml2YXRlIF9jb25uZWN0ZWQgPSBmYWxzZVxuXG4gIGNvbnN0cnVjdG9yKG9wdHM/OiBKc29uUnBjMi5JQ2xpZW50T3B0cykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLnNldExvZ2dpbmcob3B0cylcbiAgfVxuXG4gIGFic3RyYWN0IHNlbmRNZXNzYWdlKG1lc3NhZ2U6IHN0cmluZyB8IEJ1ZmZlcik6IHZvaWRcblxuICBwdWJsaWMgcHJvY2Vzc01lc3NhZ2UoXG4gICAgbWVzc2FnZVN0cjogc3RyaW5nIHwgKEpzb25ScGMyLklSZXNwb25zZSAmIEpzb25ScGMyLklOb3RpZmljYXRpb24pIHwgQnVmZmVyIHwgVWludDhBcnJheSB8IG51bWJlcltdXG4gICkge1xuICAgIGxldCBtZXNzYWdlOiBKc29uUnBjMi5JUmVzcG9uc2UgJiBKc29uUnBjMi5JTm90aWZpY2F0aW9uXG5cbiAgICBpZiAodHlwZW9mIG1lc3NhZ2VTdHIgPT09ICdzdHJpbmcnICYmIG1lc3NhZ2VTdHIuY2hhckF0KDApID09PSAneycpIHtcbiAgICAgIHRoaXMuX2xvZ01lc3NhZ2UobWVzc2FnZVN0ciwgJ3JlY2VpdmUnKVxuXG4gICAgICAvLyBFbnN1cmUgSlNPTiBpcyBub3QgbWFsZm9ybWVkXG4gICAgICB0cnkge1xuICAgICAgICBtZXNzYWdlID0gSlNPTi5wYXJzZShtZXNzYWdlU3RyKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGUpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHR5cGVvZiBtZXNzYWdlU3RyID09PSAnc3RyaW5nJyB8fFxuICAgICAgbWVzc2FnZVN0ciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgLyogdHNsaW50OmRpc2FibGUtbmV4dC1saW5lICovIHx8XG4gICAgICAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgbWVzc2FnZVN0ciBpbnN0YW5jZW9mIEJ1ZmZlcikgfHxcbiAgICAgIG1lc3NhZ2VTdHIgaW5zdGFuY2VvZiBBcnJheVxuICAgICkge1xuICAgICAgbWVzc2FnZSA9IGRlY29kZShtZXNzYWdlU3RyIGFzIGFueSwgeyBjb2RlYyB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlID0gbWVzc2FnZVN0clxuICAgIH1cblxuICAgIC8vIENoZWNrIHRoYXQgbWVzc2FnZXMgaXMgd2VsbCBmb3JtZWRcbiAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoYE1lc3NhZ2UgY2Fubm90IGJlIG51bGwsIGVtcHR5IG9yIHVuZGVmaW5lZGApKVxuICAgIH0gZWxzZSBpZiAobWVzc2FnZS5pZCkge1xuICAgICAgaWYgKHRoaXMuX3Jlc3BvbnNlUHJvbWlzZU1hcC5oYXMobWVzc2FnZS5pZCkpIHtcbiAgICAgICAgLy8gUmVzb2x2ZSBwcm9taXNlIGZyb20gcGVuZGluZyBtZXNzYWdlXG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLl9yZXNwb25zZVByb21pc2VNYXAuZ2V0KG1lc3NhZ2UuaWQpIGFzIEpzb25ScGMyLlJlc29sdmFibGVcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VQcm9taXNlTWFwLmRlbGV0ZShtZXNzYWdlLmlkKVxuXG4gICAgICAgIGlmICgncmVzdWx0JyBpbiBtZXNzYWdlKSB7XG4gICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKG1lc3NhZ2UucmVzdWx0KVxuICAgICAgICB9IGVsc2UgaWYgKCdlcnJvcicgaW4gbWVzc2FnZSkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIG5ldyBFcnJvcignUmVtb3RlIGVycm9yJyksXG4gICAgICAgICAgICBtZXNzYWdlLmVycm9yLFxuICAgICAgICAgICAgKG1lc3NhZ2UuZXJyb3IgJiYgbWVzc2FnZS5lcnJvci5kYXRhKSB8fCB7fVxuICAgICAgICAgIClcbiAgICAgICAgICBwcm9taXNlLnJlamVjdChlcnJvcilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9taXNlLnJlamVjdChcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obmV3IEVycm9yKGBSZXNwb25zZSBtdXN0IGhhdmUgcmVzdWx0IG9yIGVycm9yOiAke21lc3NhZ2VTdHJ9YCksIHtcbiAgICAgICAgICAgICAgY29kZTogSnNvblJwYzIuRXJyb3JDb2RlLlBhcnNlRXJyb3JcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKGBSZXNwb25zZSB3aXRoIGlkOiR7bWVzc2FnZS5pZH0gaGFzIG5vIHBlbmRpbmcgcmVxdWVzdGApKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWVzc2FnZS5tZXRob2QpIHtcbiAgICAgIC8vIFNlcnZlciBoYXMgc2VudCBhIG5vdGlmaWNhdGlvblxuICAgICAgdGhpcy5lbWl0KG1lc3NhZ2UubWV0aG9kLCBtZXNzYWdlLnBhcmFtcylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcihgSW52YWxpZCBtZXNzYWdlOiAke21lc3NhZ2VTdHJ9YCkpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBsb2dnaW5nIGZvciBhbGwgcmVjZWl2ZWQgYW5kIHNlbnQgbWVzc2FnZXNcbiAgICovXG4gIHB1YmxpYyBzZXRMb2dnaW5nKHsgbG9nQ29uc29sZSB9OiBKc29uUnBjMi5JTG9nT3B0cyA9IHt9KSB7XG4gICAgdGhpcy5fY29uc29sZUxvZyA9ICEhbG9nQ29uc29sZVxuICB9XG5cbiAgY2FsbChtZXRob2Q6IHN0cmluZyk6IFByb21pc2U8YW55PlxuICBjYWxsKG1ldGhvZDogc3RyaW5nLCBwYXJhbXM6IHN0cmluZyk6IG5ldmVyXG4gIGNhbGwobWV0aG9kOiBzdHJpbmcsIHBhcmFtczogbnVtYmVyKTogbmV2ZXJcbiAgY2FsbChtZXRob2Q6IHN0cmluZywgcGFyYW1zOiBib29sZWFuKTogbmV2ZXJcbiAgY2FsbChtZXRob2Q6IHN0cmluZywgcGFyYW1zOiBudWxsKTogbmV2ZXJcbiAgY2FsbDxUPihtZXRob2Q6IHN0cmluZywgcGFyYW1zOiBJdGVyYWJsZTxUPik6IFByb21pc2U8YW55PlxuICBjYWxsKG1ldGhvZDogc3RyaW5nLCBwYXJhbXM6IHsgW2tleTogc3RyaW5nXTogYW55IH0pOiBQcm9taXNlPGFueT5cbiAgY2FsbChtZXRob2Q6IHN0cmluZywgcGFyYW1zPzogYW55KSB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwYXJhbXMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENsaWVudCNjYWxsIFBhcmFtcyBtdXN0IGJlIHN0cnVjdHVyZWQgZGF0YSAoQXJyYXkgfCBPYmplY3QpIGdvdCAke0pTT04uc3RyaW5naWZ5KHBhcmFtcyl9YClcbiAgICB9XG5cbiAgICBjb25zdCBpZCA9ICsrdGhpcy5fbmV4dE1lc3NhZ2VJZFxuICAgIGNvbnN0IG1lc3NhZ2U6IEpzb25ScGMyLklSZXF1ZXN0ID0geyBpZCwgbWV0aG9kLCBwYXJhbXMsIGpzb25ycGM6ICcyLjAnIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9yZXNwb25zZVByb21pc2VNYXAuc2V0KGlkLCB7IHJlc29sdmUsIHJlamVjdCB9KVxuICAgICAgICB0aGlzLl9zZW5kKG1lc3NhZ2UpXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBub3RpZnkobWV0aG9kOiBzdHJpbmcpOiB2b2lkXG4gIG5vdGlmeShtZXRob2Q6IHN0cmluZywgcGFyYW1zOiBzdHJpbmcpOiBuZXZlclxuICBub3RpZnkobWV0aG9kOiBzdHJpbmcsIHBhcmFtczogbnVtYmVyKTogbmV2ZXJcbiAgbm90aWZ5KG1ldGhvZDogc3RyaW5nLCBwYXJhbXM6IGJvb2xlYW4pOiBuZXZlclxuICBub3RpZnkobWV0aG9kOiBzdHJpbmcsIHBhcmFtczogbnVsbCk6IG5ldmVyXG4gIG5vdGlmeTxUPihtZXRob2Q6IHN0cmluZywgcGFyYW1zOiBJdGVyYWJsZTxUPik6IHZvaWRcbiAgbm90aWZ5KG1ldGhvZDogc3RyaW5nLCBwYXJhbXM6IHsgW2tleTogc3RyaW5nXTogYW55IH0pOiB2b2lkXG4gIG5vdGlmeShtZXRob2Q6IHN0cmluZywgcGFyYW1zPzogYW55KTogdm9pZCB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwYXJhbXMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENsaWVudCNub3RpZnkgUGFyYW1zIG11c3QgYmUgc3RydWN0dXJlZCBkYXRhIChBcnJheSB8IE9iamVjdCkgZ290ICR7SlNPTi5zdHJpbmdpZnkocGFyYW1zKX1gKVxuICAgIH1cblxuICAgIHRoaXMuX3NlbmQoeyBtZXRob2QsIHBhcmFtcywganNvbnJwYzogJzIuMCcgfSlcbiAgfVxuXG4gIHByb3RlY3RlZCBkaWRDb25uZWN0KCkge1xuICAgIGlmICh0aGlzLl9jb25uZWN0ZWQgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlXG4gICAgICB0aGlzLl9zZW5kUXVldWVkUmVxdWVzdHMoKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX3NlbmQobWVzc2FnZTogSnNvblJwYzIuSU5vdGlmaWNhdGlvbiB8IEpzb25ScGMyLklSZXF1ZXN0KSB7XG4gICAgaWYgKHRoaXMuc2VuZEVuY29kaW5nID09PSAnbXNncGFjaycpIHtcbiAgICAgIHRoaXMuX3JlcXVlc3RRdWV1ZS5wdXNoKGVuY29kZShtZXNzYWdlLCB7IGNvZGVjIH0pKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXF1ZXN0UXVldWUucHVzaChKU09OLnN0cmluZ2lmeShtZXNzYWdlKSlcbiAgICB9XG4gICAgdGhpcy5fc2VuZFF1ZXVlZFJlcXVlc3RzKClcbiAgfVxuXG4gIHByaXZhdGUgX3NlbmRRdWV1ZWRSZXF1ZXN0cygpIHtcbiAgICBpZiAodGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICBjb25zdCBxdWV1ZSA9IHRoaXMuX3JlcXVlc3RRdWV1ZS5zcGxpY2UoMCwgdGhpcy5fcmVxdWVzdFF1ZXVlLmxlbmd0aClcbiAgICAgIGZvciAobGV0IG1lc3NhZ2VTdHIgb2YgcXVldWUpIHtcbiAgICAgICAgdGhpcy5fbG9nTWVzc2FnZShtZXNzYWdlU3RyLCAnc2VuZCcpXG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UobWVzc2FnZVN0cilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9sb2dNZXNzYWdlKG1lc3NhZ2U6IHN0cmluZyB8IEJ1ZmZlciwgZGlyZWN0aW9uOiAnc2VuZCcgfCAncmVjZWl2ZScpIHtcbiAgICBpZiAodGhpcy5fY29uc29sZUxvZykge1xuICAgICAgY29uc29sZS5sb2coYENsaWVudCAke2RpcmVjdGlvbiA9PT0gJ3NlbmQnID8gJz4nIDogJzwnfWAsIG1lc3NhZ2UudG9TdHJpbmcoKSlcbiAgICB9XG4gIH1cbn1cbiJdfQ==\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/decentraland-rpc/lib/common/json-rpc/Client.js?");

/***/ }),

/***/ "./node_modules/decentraland-rpc/lib/common/transports/Memory.js":
/*!***********************************************************************!*\
  !*** ./node_modules/decentraland-rpc/lib/common/transports/Memory.js ***!
  \***********************************************************************/
/*! exports provided: MemoryTransport */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MemoryTransport\", function() { return MemoryTransport; });\n/* harmony import */ var _core_EventDispatcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/EventDispatcher */ \"./node_modules/decentraland-rpc/lib/common/core/EventDispatcher.js\");\n\nfunction MemoryTransport() {\n    const clientEd = new _core_EventDispatcher__WEBPACK_IMPORTED_MODULE_0__[\"EventDispatcher\"]();\n    const serverEd = new _core_EventDispatcher__WEBPACK_IMPORTED_MODULE_0__[\"EventDispatcher\"]();\n    function configureMemoryTransport(receiver, sender) {\n        return {\n            sendMessage(message) {\n                sender.emit('message', message);\n            },\n            close() {\n                sender.emit('close');\n            },\n            onMessage(handler) {\n                receiver.on('message', handler);\n            },\n            onClose(handler) {\n                receiver.on('close', handler);\n            },\n            onError(handler) {\n                receiver.on('error', handler);\n            },\n            onConnect(handler) {\n                setInterval(handler, 16);\n            }\n        };\n    }\n    const client = configureMemoryTransport(clientEd, serverEd);\n    const server = configureMemoryTransport(serverEd, clientEd);\n    return {\n        client,\n        server\n    };\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWVtb3J5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbW1vbi90cmFuc3BvcnRzL01lbW9yeS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0seUJBQXlCLENBQUE7QUFFekQsTUFBTSxVQUFVLGVBQWU7SUFDN0IsTUFBTSxRQUFRLEdBQUcsSUFBSSxlQUFlLEVBQUUsQ0FBQTtJQUN0QyxNQUFNLFFBQVEsR0FBRyxJQUFJLGVBQWUsRUFBRSxDQUFBO0lBRXRDLFNBQVMsd0JBQXdCLENBQUMsUUFBeUIsRUFBRSxNQUF1QjtRQUNsRixPQUFPO1lBQ0wsV0FBVyxDQUFDLE9BQU87Z0JBQ2pCLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFBO1lBQ2pDLENBQUM7WUFFRCxLQUFLO2dCQUNILE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUE7WUFDdEIsQ0FBQztZQUVELFNBQVMsQ0FBQyxPQUFPO2dCQUNmLFFBQVEsQ0FBQyxFQUFFLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFBO1lBQ2pDLENBQUM7WUFFRCxPQUFPLENBQUMsT0FBTztnQkFDYixRQUFRLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQTtZQUMvQixDQUFDO1lBRUQsT0FBTyxDQUFDLE9BQU87Z0JBQ2IsUUFBUSxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUE7WUFDL0IsQ0FBQztZQUVELFNBQVMsQ0FBQyxPQUFPO2dCQUNmLFdBQVcsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUE7WUFDMUIsQ0FBQztTQUNGLENBQUE7SUFDSCxDQUFDO0lBRUQsTUFBTSxNQUFNLEdBQUcsd0JBQXdCLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFBO0lBQzNELE1BQU0sTUFBTSxHQUFHLHdCQUF3QixDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQTtJQUUzRCxPQUFPO1FBQ0wsTUFBTTtRQUNOLE1BQU07S0FDUCxDQUFBO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNjcmlwdGluZ1RyYW5zcG9ydCB9IGZyb20gJy4uL2pzb24tcnBjL3R5cGVzJ1xuaW1wb3J0IHsgRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnLi4vY29yZS9FdmVudERpc3BhdGNoZXInXG5cbmV4cG9ydCBmdW5jdGlvbiBNZW1vcnlUcmFuc3BvcnQoKSB7XG4gIGNvbnN0IGNsaWVudEVkID0gbmV3IEV2ZW50RGlzcGF0Y2hlcigpXG4gIGNvbnN0IHNlcnZlckVkID0gbmV3IEV2ZW50RGlzcGF0Y2hlcigpXG5cbiAgZnVuY3Rpb24gY29uZmlndXJlTWVtb3J5VHJhbnNwb3J0KHJlY2VpdmVyOiBFdmVudERpc3BhdGNoZXIsIHNlbmRlcjogRXZlbnREaXNwYXRjaGVyKTogU2NyaXB0aW5nVHJhbnNwb3J0IHtcbiAgICByZXR1cm4ge1xuICAgICAgc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBzZW5kZXIuZW1pdCgnbWVzc2FnZScsIG1lc3NhZ2UpXG4gICAgICB9LFxuXG4gICAgICBjbG9zZSgpIHtcbiAgICAgICAgc2VuZGVyLmVtaXQoJ2Nsb3NlJylcbiAgICAgIH0sXG5cbiAgICAgIG9uTWVzc2FnZShoYW5kbGVyKSB7XG4gICAgICAgIHJlY2VpdmVyLm9uKCdtZXNzYWdlJywgaGFuZGxlcilcbiAgICAgIH0sXG5cbiAgICAgIG9uQ2xvc2UoaGFuZGxlcikge1xuICAgICAgICByZWNlaXZlci5vbignY2xvc2UnLCBoYW5kbGVyKVxuICAgICAgfSxcblxuICAgICAgb25FcnJvcihoYW5kbGVyKSB7XG4gICAgICAgIHJlY2VpdmVyLm9uKCdlcnJvcicsIGhhbmRsZXIpXG4gICAgICB9LFxuXG4gICAgICBvbkNvbm5lY3QoaGFuZGxlcikge1xuICAgICAgICBzZXRJbnRlcnZhbChoYW5kbGVyLCAxNilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBjbGllbnQgPSBjb25maWd1cmVNZW1vcnlUcmFuc3BvcnQoY2xpZW50RWQsIHNlcnZlckVkKVxuICBjb25zdCBzZXJ2ZXIgPSBjb25maWd1cmVNZW1vcnlUcmFuc3BvcnQoc2VydmVyRWQsIGNsaWVudEVkKVxuXG4gIHJldHVybiB7XG4gICAgY2xpZW50LFxuICAgIHNlcnZlclxuICB9XG59XG4iXX0=\n\n//# sourceURL=webpack:///./node_modules/decentraland-rpc/lib/common/transports/Memory.js?");

/***/ }),

/***/ "./node_modules/decentraland-rpc/lib/common/transports/WebSocket.js":
/*!**************************************************************************!*\
  !*** ./node_modules/decentraland-rpc/lib/common/transports/WebSocket.js ***!
  \**************************************************************************/
/*! exports provided: WebSocketTransport */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WebSocketTransport\", function() { return WebSocketTransport; });\nfunction WebSocketTransport(socket) {\n    const queue = [];\n    socket.addEventListener('open', function () {\n        flush();\n    });\n    function flush() {\n        if (socket.readyState === socket.OPEN) {\n            queue.forEach($ => send($));\n            queue.length = 0;\n        }\n    }\n    function send(msg) {\n        if (typeof msg === 'string') {\n            socket.send(msg, { binary: false });\n        }\n        else if (msg instanceof Uint8Array || msg instanceof ArrayBuffer || msg instanceof SharedArrayBuffer) {\n            ;\n            socket.binaryType = 'arraybuffer';\n            socket.send(msg, { binary: true });\n        }\n    }\n    const api = {\n        onConnect(handler) {\n            if (socket.readyState === socket.OPEN) {\n                handler();\n            }\n            else {\n                socket.addEventListener('open', () => handler(), { once: true });\n            }\n        },\n        onError(handler) {\n            socket.addEventListener('error', (err) => {\n                if (err.error) {\n                    handler(err.error);\n                }\n                else if (err.message) {\n                    handler(Object.assign(new Error(err.message), {\n                        colno: err.colno,\n                        error: err.error,\n                        filename: err.filename,\n                        lineno: err.lineno,\n                        message: err.message\n                    }));\n                }\n            });\n        },\n        onMessage(handler) {\n            socket.addEventListener('message', (message) => {\n                handler(message.data);\n            });\n        },\n        sendMessage(message) {\n            const toSend = message instanceof Uint8Array ? message.buffer : message;\n            if (socket.readyState === socket.OPEN) {\n                send(toSend);\n            }\n            else {\n                queue.push(toSend);\n            }\n        },\n        close() {\n            socket.close();\n        }\n    };\n    return api;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiV2ViU29ja2V0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbW1vbi90cmFuc3BvcnRzL1dlYlNvY2tldC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFtQ0EsTUFBTSxVQUFVLGtCQUFrQixDQUFDLE1BQWtCO0lBQ25ELE1BQU0sS0FBSyxHQUF1RSxFQUFFLENBQUE7SUFFcEYsTUFBTSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sRUFBRTtRQUM5QixLQUFLLEVBQUUsQ0FBQTtJQUNULENBQUMsQ0FBQyxDQUFBO0lBRUYsU0FBUyxLQUFLO1FBQ1osSUFBSSxNQUFNLENBQUMsVUFBVSxLQUFLLE1BQU0sQ0FBQyxJQUFJLEVBQUU7WUFDckMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFBO1lBQzNCLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFBO1NBQ2pCO0lBQ0gsQ0FBQztJQUVELFNBQVMsSUFBSSxDQUFDLEdBQW1FO1FBQy9FLElBQUksT0FBTyxHQUFHLEtBQUssUUFBUSxFQUFFO1lBQzNCLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUE7U0FDcEM7YUFBTSxJQUFJLEdBQUcsWUFBWSxVQUFVLElBQUksR0FBRyxZQUFZLFdBQVcsSUFBSSxHQUFHLFlBQVksaUJBQWlCLEVBQUU7WUFFdEcsQ0FBQztZQUFDLE1BQWMsQ0FBQyxVQUFVLEdBQUcsYUFBYSxDQUFBO1lBQzNDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUE7U0FDbkM7SUFDSCxDQUFDO0lBRUQsTUFBTSxHQUFHLEdBQXVCO1FBQzlCLFNBQVMsQ0FBQyxPQUFPO1lBQ2YsSUFBSSxNQUFNLENBQUMsVUFBVSxLQUFLLE1BQU0sQ0FBQyxJQUFJLEVBQUU7Z0JBQ3JDLE9BQU8sRUFBRSxDQUFBO2FBQ1Y7aUJBQU07Z0JBQ0wsTUFBTSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxHQUFHLEVBQUUsQ0FBQyxPQUFPLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFBO2FBQ2pFO1FBQ0gsQ0FBQztRQUNELE9BQU8sQ0FBQyxPQUFPO1lBQ2IsTUFBTSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxDQUFDLEdBQWUsRUFBRSxFQUFFO2dCQUNuRCxJQUFJLEdBQUcsQ0FBQyxLQUFLLEVBQUU7b0JBQ2IsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQTtpQkFDbkI7cUJBQU0sSUFBSSxHQUFHLENBQUMsT0FBTyxFQUFFO29CQUN0QixPQUFPLENBQ0wsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEVBQUU7d0JBQ3BDLEtBQUssRUFBRSxHQUFHLENBQUMsS0FBSzt3QkFDaEIsS0FBSyxFQUFFLEdBQUcsQ0FBQyxLQUFLO3dCQUNoQixRQUFRLEVBQUUsR0FBRyxDQUFDLFFBQVE7d0JBQ3RCLE1BQU0sRUFBRSxHQUFHLENBQUMsTUFBTTt3QkFDbEIsT0FBTyxFQUFFLEdBQUcsQ0FBQyxPQUFPO3FCQUNyQixDQUFDLENBQ0gsQ0FBQTtpQkFDRjtZQUNILENBQUMsQ0FBQyxDQUFBO1FBQ0osQ0FBQztRQUNELFNBQVMsQ0FBQyxPQUFPO1lBQ2YsTUFBTSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxDQUFDLE9BQXNCLEVBQUUsRUFBRTtnQkFDNUQsT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQTtZQUN2QixDQUFDLENBQUMsQ0FBQTtRQUNKLENBQUM7UUFDRCxXQUFXLENBQUMsT0FBTztZQUNqQixNQUFNLE1BQU0sR0FBRyxPQUFPLFlBQVksVUFBVSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUE7WUFFdkUsSUFBSSxNQUFNLENBQUMsVUFBVSxLQUFLLE1BQU0sQ0FBQyxJQUFJLEVBQUU7Z0JBQ3JDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQTthQUNiO2lCQUFNO2dCQUNMLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUE7YUFDbkI7UUFDSCxDQUFDO1FBQ0QsS0FBSztZQUNILE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQTtRQUNoQixDQUFDO0tBQ0YsQ0FBQTtJQUVELE9BQU8sR0FBRyxDQUFBO0FBQ1osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNjcmlwdGluZ1RyYW5zcG9ydCB9IGZyb20gJy4uL2pzb24tcnBjL3R5cGVzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIElXZWJTb2NrZXRFdmVudE1hcCB7XG4gIGNsb3NlOiBhbnlcbiAgZXJyb3I6IGFueVxuICBtZXNzYWdlOiB7IGRhdGE6IGFueSB9XG4gIG9wZW46IGFueVxufVxuXG4vKipcbiAqIFRoaXMgaW50ZXJmYWNlIHNob3VsZCBiZSBjb21wYXRpYmxlIHdpdGggdGhlIEJyb3dzZXJzIGludGVyZmFjZVxuICogYW5kIG5wbSB3cyBwYWNrYWdlIGZvciBzZXJ2ZXJzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSVdlYlNvY2tldCB7XG4gIENPTk5FQ1RJTkc6IG51bWJlclxuICBPUEVOOiBudW1iZXJcbiAgQ0xPU0lORzogbnVtYmVyXG4gIENMT1NFRDogbnVtYmVyXG5cbiAgcmVhZHlTdGF0ZTogbnVtYmVyXG5cbiAgY2xvc2UoY29kZT86IG51bWJlciwgZGF0YT86IHN0cmluZyk6IHZvaWRcblxuICBzZW5kKGRhdGE6IGFueSwgY2I/OiAoZXJyOiBFcnJvcikgPT4gdm9pZCk6IHZvaWRcbiAgc2VuZChkYXRhOiBhbnksIG9wdGlvbnM6IGFueSwgY2I/OiAoZXJyOiBFcnJvcikgPT4gdm9pZCk6IHZvaWRcblxuICB0ZXJtaW5hdGU/KCk6IHZvaWRcblxuICBhZGRFdmVudExpc3RlbmVyPEsgZXh0ZW5kcyBrZXlvZiBJV2ViU29ja2V0RXZlbnRNYXA+KFxuICAgIHR5cGU6IEssXG4gICAgbGlzdGVuZXI6IChldjogSVdlYlNvY2tldEV2ZW50TWFwW0tdKSA9PiBhbnksXG4gICAgb3B0aW9ucz86IGFueVxuICApOiB2b2lkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBXZWJTb2NrZXRUcmFuc3BvcnQoc29ja2V0OiBJV2ViU29ja2V0KTogU2NyaXB0aW5nVHJhbnNwb3J0IHtcbiAgY29uc3QgcXVldWU6IChzdHJpbmcgfCBVaW50OEFycmF5IHwgQXJyYXlCdWZmZXIgfCBTaGFyZWRBcnJheUJ1ZmZlciB8IEJ1ZmZlcilbXSA9IFtdXG5cbiAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ29wZW4nLCBmdW5jdGlvbigpIHtcbiAgICBmbHVzaCgpXG4gIH0pXG5cbiAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgaWYgKHNvY2tldC5yZWFkeVN0YXRlID09PSBzb2NrZXQuT1BFTikge1xuICAgICAgcXVldWUuZm9yRWFjaCgkID0+IHNlbmQoJCkpXG4gICAgICBxdWV1ZS5sZW5ndGggPSAwXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2VuZChtc2c6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBBcnJheUJ1ZmZlciB8IFNoYXJlZEFycmF5QnVmZmVyIHwgQnVmZmVyKSB7XG4gICAgaWYgKHR5cGVvZiBtc2cgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzb2NrZXQuc2VuZChtc2csIHsgYmluYXJ5OiBmYWxzZSB9KVxuICAgIH0gZWxzZSBpZiAobXNnIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBtc2cgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBtc2cgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcikge1xuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnNlbWljb2xvblxuICAgICAgOyhzb2NrZXQgYXMgYW55KS5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJ1xuICAgICAgc29ja2V0LnNlbmQobXNnLCB7IGJpbmFyeTogdHJ1ZSB9KVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGFwaTogU2NyaXB0aW5nVHJhbnNwb3J0ID0ge1xuICAgIG9uQ29ubmVjdChoYW5kbGVyKSB7XG4gICAgICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgPT09IHNvY2tldC5PUEVOKSB7XG4gICAgICAgIGhhbmRsZXIoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ29wZW4nLCAoKSA9PiBoYW5kbGVyKCksIHsgb25jZTogdHJ1ZSB9KVxuICAgICAgfVxuICAgIH0sXG4gICAgb25FcnJvcihoYW5kbGVyKSB7XG4gICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXJyOiBFcnJvckV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChlcnIuZXJyb3IpIHtcbiAgICAgICAgICBoYW5kbGVyKGVyci5lcnJvcilcbiAgICAgICAgfSBlbHNlIGlmIChlcnIubWVzc2FnZSkge1xuICAgICAgICAgIGhhbmRsZXIoXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG5ldyBFcnJvcihlcnIubWVzc2FnZSksIHtcbiAgICAgICAgICAgICAgY29sbm86IGVyci5jb2xubyxcbiAgICAgICAgICAgICAgZXJyb3I6IGVyci5lcnJvcixcbiAgICAgICAgICAgICAgZmlsZW5hbWU6IGVyci5maWxlbmFtZSxcbiAgICAgICAgICAgICAgbGluZW5vOiBlcnIubGluZW5vLFxuICAgICAgICAgICAgICBtZXNzYWdlOiBlcnIubWVzc2FnZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSxcbiAgICBvbk1lc3NhZ2UoaGFuZGxlcikge1xuICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAobWVzc2FnZTogeyBkYXRhOiBhbnkgfSkgPT4ge1xuICAgICAgICBoYW5kbGVyKG1lc3NhZ2UuZGF0YSlcbiAgICAgIH0pXG4gICAgfSxcbiAgICBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICBjb25zdCB0b1NlbmQgPSBtZXNzYWdlIGluc3RhbmNlb2YgVWludDhBcnJheSA/IG1lc3NhZ2UuYnVmZmVyIDogbWVzc2FnZVxuXG4gICAgICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgPT09IHNvY2tldC5PUEVOKSB7XG4gICAgICAgIHNlbmQodG9TZW5kKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWUucHVzaCh0b1NlbmQpXG4gICAgICB9XG4gICAgfSxcbiAgICBjbG9zZSgpIHtcbiAgICAgIHNvY2tldC5jbG9zZSgpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFwaVxufVxuIl19\n\n//# sourceURL=webpack:///./node_modules/decentraland-rpc/lib/common/transports/WebSocket.js?");

/***/ }),

/***/ "./node_modules/decentraland-rpc/lib/common/transports/WebWorker.js":
/*!**************************************************************************!*\
  !*** ./node_modules/decentraland-rpc/lib/common/transports/WebWorker.js ***!
  \**************************************************************************/
/*! exports provided: WebWorkerTransport */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WebWorkerTransport\", function() { return WebWorkerTransport; });\nfunction WebWorkerTransport(worker) {\n    const api = {\n        onConnect(handler) {\n            worker.addEventListener('message', () => handler(), { once: true });\n        },\n        onError(handler) {\n            worker.addEventListener('error', (err) => {\n                if (err.error) {\n                    handler(err.error);\n                }\n                else if (err.message) {\n                    handler(Object.assign(new Error(err.message), {\n                        colno: err.colno,\n                        error: err.error,\n                        filename: err.filename,\n                        lineno: err.lineno,\n                        message: err.message\n                    }));\n                }\n            });\n        },\n        onMessage(handler) {\n            worker.addEventListener('message', (message) => {\n                handler(message.data);\n            });\n        },\n        sendMessage(message) {\n            worker.postMessage(message);\n        },\n        close() {\n            if ('terminate' in worker) {\n                ;\n                worker.terminate();\n            }\n            else if ('close' in worker) {\n                ;\n                worker.close();\n            }\n        }\n    };\n    return api;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiV2ViV29ya2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbW1vbi90cmFuc3BvcnRzL1dlYldvcmtlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFTQSxNQUFNLFVBQVUsa0JBQWtCLENBQUMsTUFBZTtJQUNoRCxNQUFNLEdBQUcsR0FBdUI7UUFDOUIsU0FBUyxDQUFDLE9BQU87WUFDZixNQUFNLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxFQUFFLEdBQUcsRUFBRSxDQUFDLE9BQU8sRUFBRSxFQUFFLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUE7UUFDckUsQ0FBQztRQUNELE9BQU8sQ0FBQyxPQUFPO1lBQ2IsTUFBTSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxDQUFDLEdBQWUsRUFBRSxFQUFFO2dCQUNuRCxJQUFJLEdBQUcsQ0FBQyxLQUFLLEVBQUU7b0JBQ2IsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQTtpQkFDbkI7cUJBQU0sSUFBSSxHQUFHLENBQUMsT0FBTyxFQUFFO29CQUN0QixPQUFPLENBQ0wsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEVBQUU7d0JBQ3BDLEtBQUssRUFBRSxHQUFHLENBQUMsS0FBSzt3QkFDaEIsS0FBSyxFQUFFLEdBQUcsQ0FBQyxLQUFLO3dCQUNoQixRQUFRLEVBQUUsR0FBRyxDQUFDLFFBQVE7d0JBQ3RCLE1BQU0sRUFBRSxHQUFHLENBQUMsTUFBTTt3QkFDbEIsT0FBTyxFQUFFLEdBQUcsQ0FBQyxPQUFPO3FCQUNyQixDQUFDLENBQ0gsQ0FBQTtpQkFDRjtZQUNILENBQUMsQ0FBQyxDQUFBO1FBQ0osQ0FBQztRQUNELFNBQVMsQ0FBQyxPQUFPO1lBQ2YsTUFBTSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxDQUFDLE9BQXFCLEVBQUUsRUFBRTtnQkFDM0QsT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQTtZQUN2QixDQUFDLENBQUMsQ0FBQTtRQUNKLENBQUM7UUFDRCxXQUFXLENBQUMsT0FBTztZQUNqQixNQUFNLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFBO1FBQzdCLENBQUM7UUFDRCxLQUFLO1lBQ0gsSUFBSSxXQUFXLElBQUksTUFBTSxFQUFFO2dCQUV6QixDQUFDO2dCQUFDLE1BQWMsQ0FBQyxTQUFTLEVBQUUsQ0FBQTthQUM3QjtpQkFBTSxJQUFJLE9BQU8sSUFBSSxNQUFNLEVBQUU7Z0JBRTVCLENBQUM7Z0JBQUMsTUFBYyxDQUFDLEtBQUssRUFBRSxDQUFBO2FBQ3pCO1FBQ0gsQ0FBQztLQUNGLENBQUE7SUFFRCxPQUFPLEdBQUcsQ0FBQTtBQUNaLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTY3JpcHRpbmdUcmFuc3BvcnQgfSBmcm9tICcuLi9qc29uLXJwYy90eXBlcydcblxuZXhwb3J0IGludGVyZmFjZSBJV29ya2VyIHtcbiAgdGVybWluYXRlPygpOiB2b2lkXG4gIGNsb3NlPygpOiB2b2lkXG4gIHBvc3RNZXNzYWdlKG1lc3NhZ2U6IGFueSk6IHZvaWRcbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlOiAnbWVzc2FnZScgfCAnZXJyb3InLCBsaXN0ZW5lcjogRnVuY3Rpb24sIG9wdGlvbnM/OiBhbnkpOiB2b2lkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBXZWJXb3JrZXJUcmFuc3BvcnQod29ya2VyOiBJV29ya2VyKTogU2NyaXB0aW5nVHJhbnNwb3J0IHtcbiAgY29uc3QgYXBpOiBTY3JpcHRpbmdUcmFuc3BvcnQgPSB7XG4gICAgb25Db25uZWN0KGhhbmRsZXIpIHtcbiAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKCkgPT4gaGFuZGxlcigpLCB7IG9uY2U6IHRydWUgfSlcbiAgICB9LFxuICAgIG9uRXJyb3IoaGFuZGxlcikge1xuICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgKGVycjogRXJyb3JFdmVudCkgPT4ge1xuICAgICAgICBpZiAoZXJyLmVycm9yKSB7XG4gICAgICAgICAgaGFuZGxlcihlcnIuZXJyb3IpXG4gICAgICAgIH0gZWxzZSBpZiAoZXJyLm1lc3NhZ2UpIHtcbiAgICAgICAgICBoYW5kbGVyKFxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoZXJyLm1lc3NhZ2UpLCB7XG4gICAgICAgICAgICAgIGNvbG5vOiBlcnIuY29sbm8sXG4gICAgICAgICAgICAgIGVycm9yOiBlcnIuZXJyb3IsXG4gICAgICAgICAgICAgIGZpbGVuYW1lOiBlcnIuZmlsZW5hbWUsXG4gICAgICAgICAgICAgIGxpbmVubzogZXJyLmxpbmVubyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogZXJyLm1lc3NhZ2VcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0sXG4gICAgb25NZXNzYWdlKGhhbmRsZXIpIHtcbiAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKG1lc3NhZ2U6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICBoYW5kbGVyKG1lc3NhZ2UuZGF0YSlcbiAgICAgIH0pXG4gICAgfSxcbiAgICBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICB3b3JrZXIucG9zdE1lc3NhZ2UobWVzc2FnZSlcbiAgICB9LFxuICAgIGNsb3NlKCkge1xuICAgICAgaWYgKCd0ZXJtaW5hdGUnIGluIHdvcmtlcikge1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6c2VtaWNvbG9uXG4gICAgICAgIDsod29ya2VyIGFzIGFueSkudGVybWluYXRlKClcbiAgICAgIH0gZWxzZSBpZiAoJ2Nsb3NlJyBpbiB3b3JrZXIpIHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnNlbWljb2xvblxuICAgICAgICA7KHdvcmtlciBhcyBhbnkpLmNsb3NlKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXBpXG59XG4iXX0=\n\n//# sourceURL=webpack:///./node_modules/decentraland-rpc/lib/common/transports/WebWorker.js?");

/***/ }),

/***/ "./node_modules/event-lite/event-lite.js":
/*!***********************************************!*\
  !*** ./node_modules/event-lite/event-lite.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * event-lite.js - Light-weight EventEmitter (less than 1KB when gzipped)\n *\n * @copyright Yusuke Kawasaki\n * @license MIT\n * @constructor\n * @see https://github.com/kawanet/event-lite\n * @see http://kawanet.github.io/event-lite/EventLite.html\n * @example\n * var EventLite = require(\"event-lite\");\n *\n * function MyClass() {...}             // your class\n *\n * EventLite.mixin(MyClass.prototype);  // import event methods\n *\n * var obj = new MyClass();\n * obj.on(\"foo\", function() {...});     // add event listener\n * obj.once(\"bar\", function() {...});   // add one-time event listener\n * obj.emit(\"foo\");                     // dispatch event\n * obj.emit(\"bar\");                     // dispatch another event\n * obj.off(\"foo\");                      // remove event listener\n */\n\nfunction EventLite() {\n  if (!(this instanceof EventLite)) return new EventLite();\n}\n\n(function(EventLite) {\n  // export the class for node.js\n  if (true) module.exports = EventLite;\n\n  // property name to hold listeners\n  var LISTENERS = \"listeners\";\n\n  // methods to export\n  var methods = {\n    on: on,\n    once: once,\n    off: off,\n    emit: emit\n  };\n\n  // mixin to self\n  mixin(EventLite.prototype);\n\n  // export mixin function\n  EventLite.mixin = mixin;\n\n  /**\n   * Import on(), once(), off() and emit() methods into target object.\n   *\n   * @function EventLite.mixin\n   * @param target {Prototype}\n   */\n\n  function mixin(target) {\n    for (var key in methods) {\n      target[key] = methods[key];\n    }\n    return target;\n  }\n\n  /**\n   * Add an event listener.\n   *\n   * @function EventLite.prototype.on\n   * @param type {string}\n   * @param func {Function}\n   * @returns {EventLite} Self for method chaining\n   */\n\n  function on(type, func) {\n    getListeners(this, type).push(func);\n    return this;\n  }\n\n  /**\n   * Add one-time event listener.\n   *\n   * @function EventLite.prototype.once\n   * @param type {string}\n   * @param func {Function}\n   * @returns {EventLite} Self for method chaining\n   */\n\n  function once(type, func) {\n    var that = this;\n    wrap.originalListener = func;\n    getListeners(that, type).push(wrap);\n    return that;\n\n    function wrap() {\n      off.call(that, type, wrap);\n      func.apply(this, arguments);\n    }\n  }\n\n  /**\n   * Remove an event listener.\n   *\n   * @function EventLite.prototype.off\n   * @param [type] {string}\n   * @param [func] {Function}\n   * @returns {EventLite} Self for method chaining\n   */\n\n  function off(type, func) {\n    var that = this;\n    var listners;\n    if (!arguments.length) {\n      delete that[LISTENERS];\n    } else if (!func) {\n      listners = that[LISTENERS];\n      if (listners) {\n        delete listners[type];\n        if (!Object.keys(listners).length) return off.call(that);\n      }\n    } else {\n      listners = getListeners(that, type, true);\n      if (listners) {\n        listners = listners.filter(ne);\n        if (!listners.length) return off.call(that, type);\n        that[LISTENERS][type] = listners;\n      }\n    }\n    return that;\n\n    function ne(test) {\n      return test !== func && test.originalListener !== func;\n    }\n  }\n\n  /**\n   * Dispatch (trigger) an event.\n   *\n   * @function EventLite.prototype.emit\n   * @param type {string}\n   * @param [value] {*}\n   * @returns {boolean} True when a listener received the event\n   */\n\n  function emit(type, value) {\n    var that = this;\n    var listeners = getListeners(that, type, true);\n    if (!listeners) return false;\n    var arglen = arguments.length;\n    if (arglen === 1) {\n      listeners.forEach(zeroarg);\n    } else if (arglen === 2) {\n      listeners.forEach(onearg);\n    } else {\n      var args = Array.prototype.slice.call(arguments, 1);\n      listeners.forEach(moreargs);\n    }\n    return !!listeners.length;\n\n    function zeroarg(func) {\n      func.call(that);\n    }\n\n    function onearg(func) {\n      func.call(that, value);\n    }\n\n    function moreargs(func) {\n      func.apply(that, args);\n    }\n  }\n\n  /**\n   * @ignore\n   */\n\n  function getListeners(that, type, readonly) {\n    if (readonly && !that[LISTENERS]) return;\n    var listeners = that[LISTENERS] || (that[LISTENERS] = {});\n    return listeners[type] || (listeners[type] = []);\n  }\n\n})(EventLite);\n\n\n//# sourceURL=webpack:///./node_modules/event-lite/event-lite.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack:///./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/int64-buffer/int64-buffer.js":
/*!***************************************************!*\
  !*** ./node_modules/int64-buffer/int64-buffer.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {// int64-buffer.js\n\n/*jshint -W018 */ // Confusing use of '!'.\n/*jshint -W030 */ // Expected an assignment or function call and instead saw an expression.\n/*jshint -W093 */ // Did you mean to return a conditional instead of an assignment?\n\nvar Uint64BE, Int64BE, Uint64LE, Int64LE;\n\n!function(exports) {\n  // constants\n\n  var UNDEFINED = \"undefined\";\n  var BUFFER = (UNDEFINED !== typeof Buffer) && Buffer;\n  var UINT8ARRAY = (UNDEFINED !== typeof Uint8Array) && Uint8Array;\n  var ARRAYBUFFER = (UNDEFINED !== typeof ArrayBuffer) && ArrayBuffer;\n  var ZERO = [0, 0, 0, 0, 0, 0, 0, 0];\n  var isArray = Array.isArray || _isArray;\n  var BIT32 = 4294967296;\n  var BIT24 = 16777216;\n\n  // storage class\n\n  var storage; // Array;\n\n  // generate classes\n\n  Uint64BE = factory(\"Uint64BE\", true, true);\n  Int64BE = factory(\"Int64BE\", true, false);\n  Uint64LE = factory(\"Uint64LE\", false, true);\n  Int64LE = factory(\"Int64LE\", false, false);\n\n  // class factory\n\n  function factory(name, bigendian, unsigned) {\n    var posH = bigendian ? 0 : 4;\n    var posL = bigendian ? 4 : 0;\n    var pos0 = bigendian ? 0 : 3;\n    var pos1 = bigendian ? 1 : 2;\n    var pos2 = bigendian ? 2 : 1;\n    var pos3 = bigendian ? 3 : 0;\n    var fromPositive = bigendian ? fromPositiveBE : fromPositiveLE;\n    var fromNegative = bigendian ? fromNegativeBE : fromNegativeLE;\n    var proto = Int64.prototype;\n    var isName = \"is\" + name;\n    var _isInt64 = \"_\" + isName;\n\n    // properties\n    proto.buffer = void 0;\n    proto.offset = 0;\n    proto[_isInt64] = true;\n\n    // methods\n    proto.toNumber = toNumber;\n    proto.toString = toString;\n    proto.toJSON = toNumber;\n    proto.toArray = toArray;\n\n    // add .toBuffer() method only when Buffer available\n    if (BUFFER) proto.toBuffer = toBuffer;\n\n    // add .toArrayBuffer() method only when Uint8Array available\n    if (UINT8ARRAY) proto.toArrayBuffer = toArrayBuffer;\n\n    // isUint64BE, isInt64BE\n    Int64[isName] = isInt64;\n\n    // CommonJS\n    exports[name] = Int64;\n\n    return Int64;\n\n    // constructor\n    function Int64(buffer, offset, value, raddix) {\n      if (!(this instanceof Int64)) return new Int64(buffer, offset, value, raddix);\n      return init(this, buffer, offset, value, raddix);\n    }\n\n    // isUint64BE, isInt64BE\n    function isInt64(b) {\n      return !!(b && b[_isInt64]);\n    }\n\n    // initializer\n    function init(that, buffer, offset, value, raddix) {\n      if (UINT8ARRAY && ARRAYBUFFER) {\n        if (buffer instanceof ARRAYBUFFER) buffer = new UINT8ARRAY(buffer);\n        if (value instanceof ARRAYBUFFER) value = new UINT8ARRAY(value);\n      }\n\n      // Int64BE() style\n      if (!buffer && !offset && !value && !storage) {\n        // shortcut to initialize with zero\n        that.buffer = newArray(ZERO, 0);\n        return;\n      }\n\n      // Int64BE(value, raddix) style\n      if (!isValidBuffer(buffer, offset)) {\n        var _storage = storage || Array;\n        raddix = offset;\n        value = buffer;\n        offset = 0;\n        buffer = new _storage(8);\n      }\n\n      that.buffer = buffer;\n      that.offset = offset |= 0;\n\n      // Int64BE(buffer, offset) style\n      if (UNDEFINED === typeof value) return;\n\n      // Int64BE(buffer, offset, value, raddix) style\n      if (\"string\" === typeof value) {\n        fromString(buffer, offset, value, raddix || 10);\n      } else if (isValidBuffer(value, raddix)) {\n        fromArray(buffer, offset, value, raddix);\n      } else if (\"number\" === typeof raddix) {\n        writeInt32(buffer, offset + posH, value); // high\n        writeInt32(buffer, offset + posL, raddix); // low\n      } else if (value > 0) {\n        fromPositive(buffer, offset, value); // positive\n      } else if (value < 0) {\n        fromNegative(buffer, offset, value); // negative\n      } else {\n        fromArray(buffer, offset, ZERO, 0); // zero, NaN and others\n      }\n    }\n\n    function fromString(buffer, offset, str, raddix) {\n      var pos = 0;\n      var len = str.length;\n      var high = 0;\n      var low = 0;\n      if (str[0] === \"-\") pos++;\n      var sign = pos;\n      while (pos < len) {\n        var chr = parseInt(str[pos++], raddix);\n        if (!(chr >= 0)) break; // NaN\n        low = low * raddix + chr;\n        high = high * raddix + Math.floor(low / BIT32);\n        low %= BIT32;\n      }\n      if (sign) {\n        high = ~high;\n        if (low) {\n          low = BIT32 - low;\n        } else {\n          high++;\n        }\n      }\n      writeInt32(buffer, offset + posH, high);\n      writeInt32(buffer, offset + posL, low);\n    }\n\n    function toNumber() {\n      var buffer = this.buffer;\n      var offset = this.offset;\n      var high = readInt32(buffer, offset + posH);\n      var low = readInt32(buffer, offset + posL);\n      if (!unsigned) high |= 0; // a trick to get signed\n      return high ? (high * BIT32 + low) : low;\n    }\n\n    function toString(radix) {\n      var buffer = this.buffer;\n      var offset = this.offset;\n      var high = readInt32(buffer, offset + posH);\n      var low = readInt32(buffer, offset + posL);\n      var str = \"\";\n      var sign = !unsigned && (high & 0x80000000);\n      if (sign) {\n        high = ~high;\n        low = BIT32 - low;\n      }\n      radix = radix || 10;\n      while (1) {\n        var mod = (high % radix) * BIT32 + low;\n        high = Math.floor(high / radix);\n        low = Math.floor(mod / radix);\n        str = (mod % radix).toString(radix) + str;\n        if (!high && !low) break;\n      }\n      if (sign) {\n        str = \"-\" + str;\n      }\n      return str;\n    }\n\n    function writeInt32(buffer, offset, value) {\n      buffer[offset + pos3] = value & 255;\n      value = value >> 8;\n      buffer[offset + pos2] = value & 255;\n      value = value >> 8;\n      buffer[offset + pos1] = value & 255;\n      value = value >> 8;\n      buffer[offset + pos0] = value & 255;\n    }\n\n    function readInt32(buffer, offset) {\n      return (buffer[offset + pos0] * BIT24) +\n        (buffer[offset + pos1] << 16) +\n        (buffer[offset + pos2] << 8) +\n        buffer[offset + pos3];\n    }\n  }\n\n  function toArray(raw) {\n    var buffer = this.buffer;\n    var offset = this.offset;\n    storage = null; // Array\n    if (raw !== false && offset === 0 && buffer.length === 8 && isArray(buffer)) return buffer;\n    return newArray(buffer, offset);\n  }\n\n  function toBuffer(raw) {\n    var buffer = this.buffer;\n    var offset = this.offset;\n    storage = BUFFER;\n    if (raw !== false && offset === 0 && buffer.length === 8 && Buffer.isBuffer(buffer)) return buffer;\n    var dest = new BUFFER(8);\n    fromArray(dest, 0, buffer, offset);\n    return dest;\n  }\n\n  function toArrayBuffer(raw) {\n    var buffer = this.buffer;\n    var offset = this.offset;\n    var arrbuf = buffer.buffer;\n    storage = UINT8ARRAY;\n    if (raw !== false && offset === 0 && (arrbuf instanceof ARRAYBUFFER) && arrbuf.byteLength === 8) return arrbuf;\n    var dest = new UINT8ARRAY(8);\n    fromArray(dest, 0, buffer, offset);\n    return dest.buffer;\n  }\n\n  function isValidBuffer(buffer, offset) {\n    var len = buffer && buffer.length;\n    offset |= 0;\n    return len && (offset + 8 <= len) && (\"string\" !== typeof buffer[offset]);\n  }\n\n  function fromArray(destbuf, destoff, srcbuf, srcoff) {\n    destoff |= 0;\n    srcoff |= 0;\n    for (var i = 0; i < 8; i++) {\n      destbuf[destoff++] = srcbuf[srcoff++] & 255;\n    }\n  }\n\n  function newArray(buffer, offset) {\n    return Array.prototype.slice.call(buffer, offset, offset + 8);\n  }\n\n  function fromPositiveBE(buffer, offset, value) {\n    var pos = offset + 8;\n    while (pos > offset) {\n      buffer[--pos] = value & 255;\n      value /= 256;\n    }\n  }\n\n  function fromNegativeBE(buffer, offset, value) {\n    var pos = offset + 8;\n    value++;\n    while (pos > offset) {\n      buffer[--pos] = ((-value) & 255) ^ 255;\n      value /= 256;\n    }\n  }\n\n  function fromPositiveLE(buffer, offset, value) {\n    var end = offset + 8;\n    while (offset < end) {\n      buffer[offset++] = value & 255;\n      value /= 256;\n    }\n  }\n\n  function fromNegativeLE(buffer, offset, value) {\n    var end = offset + 8;\n    value++;\n    while (offset < end) {\n      buffer[offset++] = ((-value) & 255) ^ 255;\n      value /= 256;\n    }\n  }\n\n  // https://github.com/retrofox/is-array\n  function _isArray(val) {\n    return !!val && \"[object Array]\" == Object.prototype.toString.call(val);\n  }\n\n}(typeof exports === 'object' && typeof exports.nodeName !== 'string' ? exports : (this || {}));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/int64-buffer/int64-buffer.js?");

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack:///./node_modules/isarray/index.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/browser.js":
/*!**************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/browser.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// browser.js\n\nexports.encode = __webpack_require__(/*! ./encode */ \"./node_modules/msgpack-lite/lib/encode.js\").encode;\nexports.decode = __webpack_require__(/*! ./decode */ \"./node_modules/msgpack-lite/lib/decode.js\").decode;\n\nexports.Encoder = __webpack_require__(/*! ./encoder */ \"./node_modules/msgpack-lite/lib/encoder.js\").Encoder;\nexports.Decoder = __webpack_require__(/*! ./decoder */ \"./node_modules/msgpack-lite/lib/decoder.js\").Decoder;\n\nexports.createCodec = __webpack_require__(/*! ./ext */ \"./node_modules/msgpack-lite/lib/ext.js\").createCodec;\nexports.codec = __webpack_require__(/*! ./codec */ \"./node_modules/msgpack-lite/lib/codec.js\").codec;\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/browser.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/buffer-global.js":
/*!********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/buffer-global.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {/* globals Buffer */\n\nmodule.exports =\n  c((\"undefined\" !== typeof Buffer) && Buffer) ||\n  c(this.Buffer) ||\n  c((\"undefined\" !== typeof window) && window.Buffer) ||\n  this.Buffer;\n\nfunction c(B) {\n  return B && B.isBuffer && B;\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/buffer-global.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/buffer-lite.js":
/*!******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/buffer-lite.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// buffer-lite.js\n\nvar MAXBUFLEN = 8192;\n\nexports.copy = copy;\nexports.toString = toString;\nexports.write = write;\n\n/**\n * Buffer.prototype.write()\n *\n * @param string {String}\n * @param [offset] {Number}\n * @returns {Number}\n */\n\nfunction write(string, offset) {\n  var buffer = this;\n  var index = offset || (offset |= 0);\n  var length = string.length;\n  var chr = 0;\n  var i = 0;\n  while (i < length) {\n    chr = string.charCodeAt(i++);\n\n    if (chr < 128) {\n      buffer[index++] = chr;\n    } else if (chr < 0x800) {\n      // 2 bytes\n      buffer[index++] = 0xC0 | (chr >>> 6);\n      buffer[index++] = 0x80 | (chr & 0x3F);\n    } else if (chr < 0xD800 || chr > 0xDFFF) {\n      // 3 bytes\n      buffer[index++] = 0xE0 | (chr  >>> 12);\n      buffer[index++] = 0x80 | ((chr >>> 6)  & 0x3F);\n      buffer[index++] = 0x80 | (chr          & 0x3F);\n    } else {\n      // 4 bytes - surrogate pair\n      chr = (((chr - 0xD800) << 10) | (string.charCodeAt(i++) - 0xDC00)) + 0x10000;\n      buffer[index++] = 0xF0 | (chr >>> 18);\n      buffer[index++] = 0x80 | ((chr >>> 12) & 0x3F);\n      buffer[index++] = 0x80 | ((chr >>> 6)  & 0x3F);\n      buffer[index++] = 0x80 | (chr          & 0x3F);\n    }\n  }\n  return index - offset;\n}\n\n/**\n * Buffer.prototype.toString()\n *\n * @param [encoding] {String} ignored\n * @param [start] {Number}\n * @param [end] {Number}\n * @returns {String}\n */\n\nfunction toString(encoding, start, end) {\n  var buffer = this;\n  var index = start|0;\n  if (!end) end = buffer.length;\n  var string = '';\n  var chr = 0;\n\n  while (index < end) {\n    chr = buffer[index++];\n    if (chr < 128) {\n      string += String.fromCharCode(chr);\n      continue;\n    }\n\n    if ((chr & 0xE0) === 0xC0) {\n      // 2 bytes\n      chr = (chr & 0x1F) << 6 |\n            (buffer[index++] & 0x3F);\n\n    } else if ((chr & 0xF0) === 0xE0) {\n      // 3 bytes\n      chr = (chr & 0x0F)             << 12 |\n            (buffer[index++] & 0x3F) << 6  |\n            (buffer[index++] & 0x3F);\n\n    } else if ((chr & 0xF8) === 0xF0) {\n      // 4 bytes\n      chr = (chr & 0x07)             << 18 |\n            (buffer[index++] & 0x3F) << 12 |\n            (buffer[index++] & 0x3F) << 6  |\n            (buffer[index++] & 0x3F);\n    }\n\n    if (chr >= 0x010000) {\n      // A surrogate pair\n      chr -= 0x010000;\n\n      string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);\n    } else {\n      string += String.fromCharCode(chr);\n    }\n  }\n\n  return string;\n}\n\n/**\n * Buffer.prototype.copy()\n *\n * @param target {Buffer}\n * @param [targetStart] {Number}\n * @param [start] {Number}\n * @param [end] {Number}\n * @returns {number}\n */\n\nfunction copy(target, targetStart, start, end) {\n  var i;\n  if (!start) start = 0;\n  if (!end && end !== 0) end = this.length;\n  if (!targetStart) targetStart = 0;\n  var len = end - start;\n\n  if (target === this && start < targetStart && targetStart < end) {\n    // descending\n    for (i = len - 1; i >= 0; i--) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else {\n    // ascending\n    for (i = 0; i < len; i++) {\n      target[i + targetStart] = this[i + start];\n    }\n  }\n\n  return len;\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/buffer-lite.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/bufferish-array.js":
/*!**********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/bufferish-array.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// bufferish-array.js\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\n\nvar exports = module.exports = alloc(0);\n\nexports.alloc = alloc;\nexports.concat = Bufferish.concat;\nexports.from = from;\n\n/**\n * @param size {Number}\n * @returns {Buffer|Uint8Array|Array}\n */\n\nfunction alloc(size) {\n  return new Array(size);\n}\n\n/**\n * @param value {Array|ArrayBuffer|Buffer|String}\n * @returns {Array}\n */\n\nfunction from(value) {\n  if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {\n    // TypedArray to Uint8Array\n    value = Bufferish.Uint8Array.from(value);\n  } else if (Bufferish.isArrayBuffer(value)) {\n    // ArrayBuffer to Uint8Array\n    value = new Uint8Array(value);\n  } else if (typeof value === \"string\") {\n    // String to Array\n    return Bufferish.from.call(exports, value);\n  } else if (typeof value === \"number\") {\n    throw new TypeError('\"value\" argument must not be a number');\n  }\n\n  // Array-like to Array\n  return Array.prototype.slice.call(value);\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/bufferish-array.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/bufferish-buffer.js":
/*!***********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/bufferish-buffer.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// bufferish-buffer.js\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\nvar Buffer = Bufferish.global;\n\nvar exports = module.exports = Bufferish.hasBuffer ? alloc(0) : [];\n\nexports.alloc = Bufferish.hasBuffer && Buffer.alloc || alloc;\nexports.concat = Bufferish.concat;\nexports.from = from;\n\n/**\n * @param size {Number}\n * @returns {Buffer|Uint8Array|Array}\n */\n\nfunction alloc(size) {\n  return new Buffer(size);\n}\n\n/**\n * @param value {Array|ArrayBuffer|Buffer|String}\n * @returns {Buffer}\n */\n\nfunction from(value) {\n  if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {\n    // TypedArray to Uint8Array\n    value = Bufferish.Uint8Array.from(value);\n  } else if (Bufferish.isArrayBuffer(value)) {\n    // ArrayBuffer to Uint8Array\n    value = new Uint8Array(value);\n  } else if (typeof value === \"string\") {\n    // String to Buffer\n    return Bufferish.from.call(exports, value);\n  } else if (typeof value === \"number\") {\n    throw new TypeError('\"value\" argument must not be a number');\n  }\n\n  // Array-like to Buffer\n  if (Buffer.from && Buffer.from.length !== 1) {\n    return Buffer.from(value); // node v6+\n  } else {\n    return new Buffer(value); // node v4\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/bufferish-buffer.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/bufferish-proto.js":
/*!**********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/bufferish-proto.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// bufferish-proto.js\n\n/* jshint eqnull:true */\n\nvar BufferLite = __webpack_require__(/*! ./buffer-lite */ \"./node_modules/msgpack-lite/lib/buffer-lite.js\");\n\nexports.copy = copy;\nexports.slice = slice;\nexports.toString = toString;\nexports.write = gen(\"write\");\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\nvar Buffer = Bufferish.global;\n\nvar isBufferShim = Bufferish.hasBuffer && (\"TYPED_ARRAY_SUPPORT\" in Buffer);\nvar brokenTypedArray = isBufferShim && !Buffer.TYPED_ARRAY_SUPPORT;\n\n/**\n * @param target {Buffer|Uint8Array|Array}\n * @param [targetStart] {Number}\n * @param [start] {Number}\n * @param [end] {Number}\n * @returns {Buffer|Uint8Array|Array}\n */\n\nfunction copy(target, targetStart, start, end) {\n  var thisIsBuffer = Bufferish.isBuffer(this);\n  var targetIsBuffer = Bufferish.isBuffer(target);\n  if (thisIsBuffer && targetIsBuffer) {\n    // Buffer to Buffer\n    return this.copy(target, targetStart, start, end);\n  } else if (!brokenTypedArray && !thisIsBuffer && !targetIsBuffer &&\n    Bufferish.isView(this) && Bufferish.isView(target)) {\n    // Uint8Array to Uint8Array (except for minor some browsers)\n    var buffer = (start || end != null) ? slice.call(this, start, end) : this;\n    target.set(buffer, targetStart);\n    return buffer.length;\n  } else {\n    // other cases\n    return BufferLite.copy.call(this, target, targetStart, start, end);\n  }\n}\n\n/**\n * @param [start] {Number}\n * @param [end] {Number}\n * @returns {Buffer|Uint8Array|Array}\n */\n\nfunction slice(start, end) {\n  // for Buffer, Uint8Array (except for minor some browsers) and Array\n  var f = this.slice || (!brokenTypedArray && this.subarray);\n  if (f) return f.call(this, start, end);\n\n  // Uint8Array (for minor some browsers)\n  var target = Bufferish.alloc.call(this, end - start);\n  copy.call(this, target, 0, start, end);\n  return target;\n}\n\n/**\n * Buffer.prototype.toString()\n *\n * @param [encoding] {String} ignored\n * @param [start] {Number}\n * @param [end] {Number}\n * @returns {String}\n */\n\nfunction toString(encoding, start, end) {\n  var f = (!isBufferShim && Bufferish.isBuffer(this)) ? this.toString : BufferLite.toString;\n  return f.apply(this, arguments);\n}\n\n/**\n * @private\n */\n\nfunction gen(method) {\n  return wrap;\n\n  function wrap() {\n    var f = this[method] || BufferLite[method];\n    return f.apply(this, arguments);\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/bufferish-proto.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/bufferish-uint8array.js":
/*!***************************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/bufferish-uint8array.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// bufferish-uint8array.js\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\n\nvar exports = module.exports = Bufferish.hasArrayBuffer ? alloc(0) : [];\n\nexports.alloc = alloc;\nexports.concat = Bufferish.concat;\nexports.from = from;\n\n/**\n * @param size {Number}\n * @returns {Buffer|Uint8Array|Array}\n */\n\nfunction alloc(size) {\n  return new Uint8Array(size);\n}\n\n/**\n * @param value {Array|ArrayBuffer|Buffer|String}\n * @returns {Uint8Array}\n */\n\nfunction from(value) {\n  if (Bufferish.isView(value)) {\n    // TypedArray to ArrayBuffer\n    var byteOffset = value.byteOffset;\n    var byteLength = value.byteLength;\n    value = value.buffer;\n    if (value.byteLength !== byteLength) {\n      if (value.slice) {\n        value = value.slice(byteOffset, byteOffset + byteLength);\n      } else {\n        // Android 4.1 does not have ArrayBuffer.prototype.slice\n        value = new Uint8Array(value);\n        if (value.byteLength !== byteLength) {\n          // TypedArray to ArrayBuffer to Uint8Array to Array\n          value = Array.prototype.slice.call(value, byteOffset, byteOffset + byteLength);\n        }\n      }\n    }\n  } else if (typeof value === \"string\") {\n    // String to Uint8Array\n    return Bufferish.from.call(exports, value);\n  } else if (typeof value === \"number\") {\n    throw new TypeError('\"value\" argument must not be a number');\n  }\n\n  return new Uint8Array(value);\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/bufferish-uint8array.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/bufferish.js":
/*!****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/bufferish.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// bufferish.js\n\nvar Buffer = exports.global = __webpack_require__(/*! ./buffer-global */ \"./node_modules/msgpack-lite/lib/buffer-global.js\");\nvar hasBuffer = exports.hasBuffer = Buffer && !!Buffer.isBuffer;\nvar hasArrayBuffer = exports.hasArrayBuffer = (\"undefined\" !== typeof ArrayBuffer);\n\nvar isArray = exports.isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\");\nexports.isArrayBuffer = hasArrayBuffer ? isArrayBuffer : _false;\nvar isBuffer = exports.isBuffer = hasBuffer ? Buffer.isBuffer : _false;\nvar isView = exports.isView = hasArrayBuffer ? (ArrayBuffer.isView || _is(\"ArrayBuffer\", \"buffer\")) : _false;\n\nexports.alloc = alloc;\nexports.concat = concat;\nexports.from = from;\n\nvar BufferArray = exports.Array = __webpack_require__(/*! ./bufferish-array */ \"./node_modules/msgpack-lite/lib/bufferish-array.js\");\nvar BufferBuffer = exports.Buffer = __webpack_require__(/*! ./bufferish-buffer */ \"./node_modules/msgpack-lite/lib/bufferish-buffer.js\");\nvar BufferUint8Array = exports.Uint8Array = __webpack_require__(/*! ./bufferish-uint8array */ \"./node_modules/msgpack-lite/lib/bufferish-uint8array.js\");\nvar BufferProto = exports.prototype = __webpack_require__(/*! ./bufferish-proto */ \"./node_modules/msgpack-lite/lib/bufferish-proto.js\");\n\n/**\n * @param value {Array|ArrayBuffer|Buffer|String}\n * @returns {Buffer|Uint8Array|Array}\n */\n\nfunction from(value) {\n  if (typeof value === \"string\") {\n    return fromString.call(this, value);\n  } else {\n    return auto(this).from(value);\n  }\n}\n\n/**\n * @param size {Number}\n * @returns {Buffer|Uint8Array|Array}\n */\n\nfunction alloc(size) {\n  return auto(this).alloc(size);\n}\n\n/**\n * @param list {Array} array of (Buffer|Uint8Array|Array)s\n * @param [length]\n * @returns {Buffer|Uint8Array|Array}\n */\n\nfunction concat(list, length) {\n  if (!length) {\n    length = 0;\n    Array.prototype.forEach.call(list, dryrun);\n  }\n  var ref = (this !== exports) && this || list[0];\n  var result = alloc.call(ref, length);\n  var offset = 0;\n  Array.prototype.forEach.call(list, append);\n  return result;\n\n  function dryrun(buffer) {\n    length += buffer.length;\n  }\n\n  function append(buffer) {\n    offset += BufferProto.copy.call(buffer, result, offset);\n  }\n}\n\nvar _isArrayBuffer = _is(\"ArrayBuffer\");\n\nfunction isArrayBuffer(value) {\n  return (value instanceof ArrayBuffer) || _isArrayBuffer(value);\n}\n\n/**\n * @private\n */\n\nfunction fromString(value) {\n  var expected = value.length * 3;\n  var that = alloc.call(this, expected);\n  var actual = BufferProto.write.call(that, value);\n  if (expected !== actual) {\n    that = BufferProto.slice.call(that, 0, actual);\n  }\n  return that;\n}\n\nfunction auto(that) {\n  return isBuffer(that) ? BufferBuffer\n    : isView(that) ? BufferUint8Array\n    : isArray(that) ? BufferArray\n    : hasBuffer ? BufferBuffer\n    : hasArrayBuffer ? BufferUint8Array\n    : BufferArray;\n}\n\nfunction _false() {\n  return false;\n}\n\nfunction _is(name, key) {\n  /* jshint eqnull:true */\n  name = \"[object \" + name + \"]\";\n  return function(value) {\n    return (value != null) && {}.toString.call(key ? value[key] : value) === name;\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/bufferish.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/codec-base.js":
/*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/codec-base.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// codec-base.js\n\nvar IS_ARRAY = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\");\n\nexports.createCodec = createCodec;\nexports.install = install;\nexports.filter = filter;\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\n\nfunction Codec(options) {\n  if (!(this instanceof Codec)) return new Codec(options);\n  this.options = options;\n  this.init();\n}\n\nCodec.prototype.init = function() {\n  var options = this.options;\n\n  if (options && options.uint8array) {\n    this.bufferish = Bufferish.Uint8Array;\n  }\n\n  return this;\n};\n\nfunction install(props) {\n  for (var key in props) {\n    Codec.prototype[key] = add(Codec.prototype[key], props[key]);\n  }\n}\n\nfunction add(a, b) {\n  return (a && b) ? ab : (a || b);\n\n  function ab() {\n    a.apply(this, arguments);\n    return b.apply(this, arguments);\n  }\n}\n\nfunction join(filters) {\n  filters = filters.slice();\n\n  return function(value) {\n    return filters.reduce(iterator, value);\n  };\n\n  function iterator(value, filter) {\n    return filter(value);\n  }\n}\n\nfunction filter(filter) {\n  return IS_ARRAY(filter) ? join(filter) : filter;\n}\n\n// @public\n// msgpack.createCodec()\n\nfunction createCodec(options) {\n  return new Codec(options);\n}\n\n// default shared codec\n\nexports.preset = createCodec({preset: true});\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/codec-base.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/codec.js":
/*!************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/codec.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// codec.js\n\n// load both interfaces\n__webpack_require__(/*! ./read-core */ \"./node_modules/msgpack-lite/lib/read-core.js\");\n__webpack_require__(/*! ./write-core */ \"./node_modules/msgpack-lite/lib/write-core.js\");\n\n// @public\n// msgpack.codec.preset\n\nexports.codec = {\n  preset: __webpack_require__(/*! ./codec-base */ \"./node_modules/msgpack-lite/lib/codec-base.js\").preset\n};\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/codec.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/decode-buffer.js":
/*!********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/decode-buffer.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// decode-buffer.js\n\nexports.DecodeBuffer = DecodeBuffer;\n\nvar preset = __webpack_require__(/*! ./read-core */ \"./node_modules/msgpack-lite/lib/read-core.js\").preset;\n\nvar FlexDecoder = __webpack_require__(/*! ./flex-buffer */ \"./node_modules/msgpack-lite/lib/flex-buffer.js\").FlexDecoder;\n\nFlexDecoder.mixin(DecodeBuffer.prototype);\n\nfunction DecodeBuffer(options) {\n  if (!(this instanceof DecodeBuffer)) return new DecodeBuffer(options);\n\n  if (options) {\n    this.options = options;\n    if (options.codec) {\n      var codec = this.codec = options.codec;\n      if (codec.bufferish) this.bufferish = codec.bufferish;\n    }\n  }\n}\n\nDecodeBuffer.prototype.codec = preset;\n\nDecodeBuffer.prototype.fetch = function() {\n  return this.codec.decode(this);\n};\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/decode-buffer.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/decode.js":
/*!*************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/decode.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// decode.js\n\nexports.decode = decode;\n\nvar DecodeBuffer = __webpack_require__(/*! ./decode-buffer */ \"./node_modules/msgpack-lite/lib/decode-buffer.js\").DecodeBuffer;\n\nfunction decode(input, options) {\n  var decoder = new DecodeBuffer(options);\n  decoder.write(input);\n  return decoder.read();\n}\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/decode.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/decoder.js":
/*!**************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/decoder.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// decoder.js\n\nexports.Decoder = Decoder;\n\nvar EventLite = __webpack_require__(/*! event-lite */ \"./node_modules/event-lite/event-lite.js\");\nvar DecodeBuffer = __webpack_require__(/*! ./decode-buffer */ \"./node_modules/msgpack-lite/lib/decode-buffer.js\").DecodeBuffer;\n\nfunction Decoder(options) {\n  if (!(this instanceof Decoder)) return new Decoder(options);\n  DecodeBuffer.call(this, options);\n}\n\nDecoder.prototype = new DecodeBuffer();\n\nEventLite.mixin(Decoder.prototype);\n\nDecoder.prototype.decode = function(chunk) {\n  if (arguments.length) this.write(chunk);\n  this.flush();\n};\n\nDecoder.prototype.push = function(chunk) {\n  this.emit(\"data\", chunk);\n};\n\nDecoder.prototype.end = function(chunk) {\n  this.decode(chunk);\n  this.emit(\"end\");\n};\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/decoder.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/encode-buffer.js":
/*!********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/encode-buffer.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// encode-buffer.js\n\nexports.EncodeBuffer = EncodeBuffer;\n\nvar preset = __webpack_require__(/*! ./write-core */ \"./node_modules/msgpack-lite/lib/write-core.js\").preset;\n\nvar FlexEncoder = __webpack_require__(/*! ./flex-buffer */ \"./node_modules/msgpack-lite/lib/flex-buffer.js\").FlexEncoder;\n\nFlexEncoder.mixin(EncodeBuffer.prototype);\n\nfunction EncodeBuffer(options) {\n  if (!(this instanceof EncodeBuffer)) return new EncodeBuffer(options);\n\n  if (options) {\n    this.options = options;\n    if (options.codec) {\n      var codec = this.codec = options.codec;\n      if (codec.bufferish) this.bufferish = codec.bufferish;\n    }\n  }\n}\n\nEncodeBuffer.prototype.codec = preset;\n\nEncodeBuffer.prototype.write = function(input) {\n  this.codec.encode(this, input);\n};\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/encode-buffer.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/encode.js":
/*!*************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/encode.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// encode.js\n\nexports.encode = encode;\n\nvar EncodeBuffer = __webpack_require__(/*! ./encode-buffer */ \"./node_modules/msgpack-lite/lib/encode-buffer.js\").EncodeBuffer;\n\nfunction encode(input, options) {\n  var encoder = new EncodeBuffer(options);\n  encoder.write(input);\n  return encoder.read();\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/encode.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/encoder.js":
/*!**************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/encoder.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// encoder.js\n\nexports.Encoder = Encoder;\n\nvar EventLite = __webpack_require__(/*! event-lite */ \"./node_modules/event-lite/event-lite.js\");\nvar EncodeBuffer = __webpack_require__(/*! ./encode-buffer */ \"./node_modules/msgpack-lite/lib/encode-buffer.js\").EncodeBuffer;\n\nfunction Encoder(options) {\n  if (!(this instanceof Encoder)) return new Encoder(options);\n  EncodeBuffer.call(this, options);\n}\n\nEncoder.prototype = new EncodeBuffer();\n\nEventLite.mixin(Encoder.prototype);\n\nEncoder.prototype.encode = function(chunk) {\n  this.write(chunk);\n  this.emit(\"data\", this.read());\n};\n\nEncoder.prototype.end = function(chunk) {\n  if (arguments.length) this.encode(chunk);\n  this.flush();\n  this.emit(\"end\");\n};\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/encoder.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/ext-buffer.js":
/*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/ext-buffer.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// ext-buffer.js\n\nexports.ExtBuffer = ExtBuffer;\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\n\nfunction ExtBuffer(buffer, type) {\n  if (!(this instanceof ExtBuffer)) return new ExtBuffer(buffer, type);\n  this.buffer = Bufferish.from(buffer);\n  this.type = type;\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/ext-buffer.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/ext-packer.js":
/*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/ext-packer.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// ext-packer.js\n\nexports.setExtPackers = setExtPackers;\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\nvar Buffer = Bufferish.global;\nvar packTypedArray = Bufferish.Uint8Array.from;\nvar _encode;\n\nvar ERROR_COLUMNS = {name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1};\n\nfunction setExtPackers(codec) {\n  codec.addExtPacker(0x0E, Error, [packError, encode]);\n  codec.addExtPacker(0x01, EvalError, [packError, encode]);\n  codec.addExtPacker(0x02, RangeError, [packError, encode]);\n  codec.addExtPacker(0x03, ReferenceError, [packError, encode]);\n  codec.addExtPacker(0x04, SyntaxError, [packError, encode]);\n  codec.addExtPacker(0x05, TypeError, [packError, encode]);\n  codec.addExtPacker(0x06, URIError, [packError, encode]);\n\n  codec.addExtPacker(0x0A, RegExp, [packRegExp, encode]);\n  codec.addExtPacker(0x0B, Boolean, [packValueOf, encode]);\n  codec.addExtPacker(0x0C, String, [packValueOf, encode]);\n  codec.addExtPacker(0x0D, Date, [Number, encode]);\n  codec.addExtPacker(0x0F, Number, [packValueOf, encode]);\n\n  if (\"undefined\" !== typeof Uint8Array) {\n    codec.addExtPacker(0x11, Int8Array, packTypedArray);\n    codec.addExtPacker(0x12, Uint8Array, packTypedArray);\n    codec.addExtPacker(0x13, Int16Array, packTypedArray);\n    codec.addExtPacker(0x14, Uint16Array, packTypedArray);\n    codec.addExtPacker(0x15, Int32Array, packTypedArray);\n    codec.addExtPacker(0x16, Uint32Array, packTypedArray);\n    codec.addExtPacker(0x17, Float32Array, packTypedArray);\n\n    // PhantomJS/1.9.7 doesn't have Float64Array\n    if (\"undefined\" !== typeof Float64Array) {\n      codec.addExtPacker(0x18, Float64Array, packTypedArray);\n    }\n\n    // IE10 doesn't have Uint8ClampedArray\n    if (\"undefined\" !== typeof Uint8ClampedArray) {\n      codec.addExtPacker(0x19, Uint8ClampedArray, packTypedArray);\n    }\n\n    codec.addExtPacker(0x1A, ArrayBuffer, packTypedArray);\n    codec.addExtPacker(0x1D, DataView, packTypedArray);\n  }\n\n  if (Bufferish.hasBuffer) {\n    codec.addExtPacker(0x1B, Buffer, Bufferish.from);\n  }\n}\n\nfunction encode(input) {\n  if (!_encode) _encode = __webpack_require__(/*! ./encode */ \"./node_modules/msgpack-lite/lib/encode.js\").encode; // lazy load\n  return _encode(input);\n}\n\nfunction packValueOf(value) {\n  return (value).valueOf();\n}\n\nfunction packRegExp(value) {\n  value = RegExp.prototype.toString.call(value).split(\"/\");\n  value.shift();\n  var out = [value.pop()];\n  out.unshift(value.join(\"/\"));\n  return out;\n}\n\nfunction packError(value) {\n  var out = {};\n  for (var key in ERROR_COLUMNS) {\n    out[key] = value[key];\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/ext-packer.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/ext-unpacker.js":
/*!*******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/ext-unpacker.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// ext-unpacker.js\n\nexports.setExtUnpackers = setExtUnpackers;\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\nvar Buffer = Bufferish.global;\nvar _decode;\n\nvar ERROR_COLUMNS = {name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1};\n\nfunction setExtUnpackers(codec) {\n  codec.addExtUnpacker(0x0E, [decode, unpackError(Error)]);\n  codec.addExtUnpacker(0x01, [decode, unpackError(EvalError)]);\n  codec.addExtUnpacker(0x02, [decode, unpackError(RangeError)]);\n  codec.addExtUnpacker(0x03, [decode, unpackError(ReferenceError)]);\n  codec.addExtUnpacker(0x04, [decode, unpackError(SyntaxError)]);\n  codec.addExtUnpacker(0x05, [decode, unpackError(TypeError)]);\n  codec.addExtUnpacker(0x06, [decode, unpackError(URIError)]);\n\n  codec.addExtUnpacker(0x0A, [decode, unpackRegExp]);\n  codec.addExtUnpacker(0x0B, [decode, unpackClass(Boolean)]);\n  codec.addExtUnpacker(0x0C, [decode, unpackClass(String)]);\n  codec.addExtUnpacker(0x0D, [decode, unpackClass(Date)]);\n  codec.addExtUnpacker(0x0F, [decode, unpackClass(Number)]);\n\n  if (\"undefined\" !== typeof Uint8Array) {\n    codec.addExtUnpacker(0x11, unpackClass(Int8Array));\n    codec.addExtUnpacker(0x12, unpackClass(Uint8Array));\n    codec.addExtUnpacker(0x13, [unpackArrayBuffer, unpackClass(Int16Array)]);\n    codec.addExtUnpacker(0x14, [unpackArrayBuffer, unpackClass(Uint16Array)]);\n    codec.addExtUnpacker(0x15, [unpackArrayBuffer, unpackClass(Int32Array)]);\n    codec.addExtUnpacker(0x16, [unpackArrayBuffer, unpackClass(Uint32Array)]);\n    codec.addExtUnpacker(0x17, [unpackArrayBuffer, unpackClass(Float32Array)]);\n\n    // PhantomJS/1.9.7 doesn't have Float64Array\n    if (\"undefined\" !== typeof Float64Array) {\n      codec.addExtUnpacker(0x18, [unpackArrayBuffer, unpackClass(Float64Array)]);\n    }\n\n    // IE10 doesn't have Uint8ClampedArray\n    if (\"undefined\" !== typeof Uint8ClampedArray) {\n      codec.addExtUnpacker(0x19, unpackClass(Uint8ClampedArray));\n    }\n\n    codec.addExtUnpacker(0x1A, unpackArrayBuffer);\n    codec.addExtUnpacker(0x1D, [unpackArrayBuffer, unpackClass(DataView)]);\n  }\n\n  if (Bufferish.hasBuffer) {\n    codec.addExtUnpacker(0x1B, unpackClass(Buffer));\n  }\n}\n\nfunction decode(input) {\n  if (!_decode) _decode = __webpack_require__(/*! ./decode */ \"./node_modules/msgpack-lite/lib/decode.js\").decode; // lazy load\n  return _decode(input);\n}\n\nfunction unpackRegExp(value) {\n  return RegExp.apply(null, value);\n}\n\nfunction unpackError(Class) {\n  return function(value) {\n    var out = new Class();\n    for (var key in ERROR_COLUMNS) {\n      out[key] = value[key];\n    }\n    return out;\n  };\n}\n\nfunction unpackClass(Class) {\n  return function(value) {\n    return new Class(value);\n  };\n}\n\nfunction unpackArrayBuffer(value) {\n  return (new Uint8Array(value)).buffer;\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/ext-unpacker.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/ext.js":
/*!**********************************************!*\
  !*** ./node_modules/msgpack-lite/lib/ext.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// ext.js\n\n// load both interfaces\n__webpack_require__(/*! ./read-core */ \"./node_modules/msgpack-lite/lib/read-core.js\");\n__webpack_require__(/*! ./write-core */ \"./node_modules/msgpack-lite/lib/write-core.js\");\n\nexports.createCodec = __webpack_require__(/*! ./codec-base */ \"./node_modules/msgpack-lite/lib/codec-base.js\").createCodec;\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/ext.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/flex-buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/flex-buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// flex-buffer.js\n\nexports.FlexDecoder = FlexDecoder;\nexports.FlexEncoder = FlexEncoder;\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\n\nvar MIN_BUFFER_SIZE = 2048;\nvar MAX_BUFFER_SIZE = 65536;\nvar BUFFER_SHORTAGE = \"BUFFER_SHORTAGE\";\n\nfunction FlexDecoder() {\n  if (!(this instanceof FlexDecoder)) return new FlexDecoder();\n}\n\nfunction FlexEncoder() {\n  if (!(this instanceof FlexEncoder)) return new FlexEncoder();\n}\n\nFlexDecoder.mixin = mixinFactory(getDecoderMethods());\nFlexDecoder.mixin(FlexDecoder.prototype);\n\nFlexEncoder.mixin = mixinFactory(getEncoderMethods());\nFlexEncoder.mixin(FlexEncoder.prototype);\n\nfunction getDecoderMethods() {\n  return {\n    bufferish: Bufferish,\n    write: write,\n    fetch: fetch,\n    flush: flush,\n    push: push,\n    pull: pull,\n    read: read,\n    reserve: reserve,\n    offset: 0\n  };\n\n  function write(chunk) {\n    var prev = this.offset ? Bufferish.prototype.slice.call(this.buffer, this.offset) : this.buffer;\n    this.buffer = prev ? (chunk ? this.bufferish.concat([prev, chunk]) : prev) : chunk;\n    this.offset = 0;\n  }\n\n  function flush() {\n    while (this.offset < this.buffer.length) {\n      var start = this.offset;\n      var value;\n      try {\n        value = this.fetch();\n      } catch (e) {\n        if (e && e.message != BUFFER_SHORTAGE) throw e;\n        // rollback\n        this.offset = start;\n        break;\n      }\n      this.push(value);\n    }\n  }\n\n  function reserve(length) {\n    var start = this.offset;\n    var end = start + length;\n    if (end > this.buffer.length) throw new Error(BUFFER_SHORTAGE);\n    this.offset = end;\n    return start;\n  }\n}\n\nfunction getEncoderMethods() {\n  return {\n    bufferish: Bufferish,\n    write: write,\n    fetch: fetch,\n    flush: flush,\n    push: push,\n    pull: pull,\n    read: read,\n    reserve: reserve,\n    send: send,\n    maxBufferSize: MAX_BUFFER_SIZE,\n    minBufferSize: MIN_BUFFER_SIZE,\n    offset: 0,\n    start: 0\n  };\n\n  function fetch() {\n    var start = this.start;\n    if (start < this.offset) {\n      var end = this.start = this.offset;\n      return Bufferish.prototype.slice.call(this.buffer, start, end);\n    }\n  }\n\n  function flush() {\n    while (this.start < this.offset) {\n      var value = this.fetch();\n      if (value) this.push(value);\n    }\n  }\n\n  function pull() {\n    var buffers = this.buffers || (this.buffers = []);\n    var chunk = buffers.length > 1 ? this.bufferish.concat(buffers) : buffers[0];\n    buffers.length = 0; // buffer exhausted\n    return chunk;\n  }\n\n  function reserve(length) {\n    var req = length | 0;\n\n    if (this.buffer) {\n      var size = this.buffer.length;\n      var start = this.offset | 0;\n      var end = start + req;\n\n      // is it long enough?\n      if (end < size) {\n        this.offset = end;\n        return start;\n      }\n\n      // flush current buffer\n      this.flush();\n\n      // resize it to 2x current length\n      length = Math.max(length, Math.min(size * 2, this.maxBufferSize));\n    }\n\n    // minimum buffer size\n    length = Math.max(length, this.minBufferSize);\n\n    // allocate new buffer\n    this.buffer = this.bufferish.alloc(length);\n    this.start = 0;\n    this.offset = req;\n    return 0;\n  }\n\n  function send(buffer) {\n    var length = buffer.length;\n    if (length > this.minBufferSize) {\n      this.flush();\n      this.push(buffer);\n    } else {\n      var offset = this.reserve(length);\n      Bufferish.prototype.copy.call(buffer, this.buffer, offset);\n    }\n  }\n}\n\n// common methods\n\nfunction write() {\n  throw new Error(\"method not implemented: write()\");\n}\n\nfunction fetch() {\n  throw new Error(\"method not implemented: fetch()\");\n}\n\nfunction read() {\n  var length = this.buffers && this.buffers.length;\n\n  // fetch the first result\n  if (!length) return this.fetch();\n\n  // flush current buffer\n  this.flush();\n\n  // read from the results\n  return this.pull();\n}\n\nfunction push(chunk) {\n  var buffers = this.buffers || (this.buffers = []);\n  buffers.push(chunk);\n}\n\nfunction pull() {\n  var buffers = this.buffers || (this.buffers = []);\n  return buffers.shift();\n}\n\nfunction mixinFactory(source) {\n  return mixin;\n\n  function mixin(target) {\n    for (var key in source) {\n      target[key] = source[key];\n    }\n    return target;\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/flex-buffer.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/read-core.js":
/*!****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/read-core.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// read-core.js\n\nvar ExtBuffer = __webpack_require__(/*! ./ext-buffer */ \"./node_modules/msgpack-lite/lib/ext-buffer.js\").ExtBuffer;\nvar ExtUnpacker = __webpack_require__(/*! ./ext-unpacker */ \"./node_modules/msgpack-lite/lib/ext-unpacker.js\");\nvar readUint8 = __webpack_require__(/*! ./read-format */ \"./node_modules/msgpack-lite/lib/read-format.js\").readUint8;\nvar ReadToken = __webpack_require__(/*! ./read-token */ \"./node_modules/msgpack-lite/lib/read-token.js\");\nvar CodecBase = __webpack_require__(/*! ./codec-base */ \"./node_modules/msgpack-lite/lib/codec-base.js\");\n\nCodecBase.install({\n  addExtUnpacker: addExtUnpacker,\n  getExtUnpacker: getExtUnpacker,\n  init: init\n});\n\nexports.preset = init.call(CodecBase.preset);\n\nfunction getDecoder(options) {\n  var readToken = ReadToken.getReadToken(options);\n  return decode;\n\n  function decode(decoder) {\n    var type = readUint8(decoder);\n    var func = readToken[type];\n    if (!func) throw new Error(\"Invalid type: \" + (type ? (\"0x\" + type.toString(16)) : type));\n    return func(decoder);\n  }\n}\n\nfunction init() {\n  var options = this.options;\n  this.decode = getDecoder(options);\n\n  if (options && options.preset) {\n    ExtUnpacker.setExtUnpackers(this);\n  }\n\n  return this;\n}\n\nfunction addExtUnpacker(etype, unpacker) {\n  var unpackers = this.extUnpackers || (this.extUnpackers = []);\n  unpackers[etype] = CodecBase.filter(unpacker);\n}\n\nfunction getExtUnpacker(type) {\n  var unpackers = this.extUnpackers || (this.extUnpackers = []);\n  return unpackers[type] || extUnpacker;\n\n  function extUnpacker(buffer) {\n    return new ExtBuffer(buffer, type);\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/read-core.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/read-format.js":
/*!******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/read-format.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// read-format.js\n\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\");\nvar Int64Buffer = __webpack_require__(/*! int64-buffer */ \"./node_modules/int64-buffer/int64-buffer.js\");\nvar Uint64BE = Int64Buffer.Uint64BE;\nvar Int64BE = Int64Buffer.Int64BE;\n\nexports.getReadFormat = getReadFormat;\nexports.readUint8 = uint8;\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\nvar BufferProto = __webpack_require__(/*! ./bufferish-proto */ \"./node_modules/msgpack-lite/lib/bufferish-proto.js\");\n\nvar HAS_MAP = (\"undefined\" !== typeof Map);\nvar NO_ASSERT = true;\n\nfunction getReadFormat(options) {\n  var binarraybuffer = Bufferish.hasArrayBuffer && options && options.binarraybuffer;\n  var int64 = options && options.int64;\n  var usemap = HAS_MAP && options && options.usemap;\n\n  var readFormat = {\n    map: (usemap ? map_to_map : map_to_obj),\n    array: array,\n    str: str,\n    bin: (binarraybuffer ? bin_arraybuffer : bin_buffer),\n    ext: ext,\n    uint8: uint8,\n    uint16: uint16,\n    uint32: uint32,\n    uint64: read(8, int64 ? readUInt64BE_int64 : readUInt64BE),\n    int8: int8,\n    int16: int16,\n    int32: int32,\n    int64: read(8, int64 ? readInt64BE_int64 : readInt64BE),\n    float32: read(4, readFloatBE),\n    float64: read(8, readDoubleBE)\n  };\n\n  return readFormat;\n}\n\nfunction map_to_obj(decoder, len) {\n  var value = {};\n  var i;\n  var k = new Array(len);\n  var v = new Array(len);\n\n  var decode = decoder.codec.decode;\n  for (i = 0; i < len; i++) {\n    k[i] = decode(decoder);\n    v[i] = decode(decoder);\n  }\n  for (i = 0; i < len; i++) {\n    value[k[i]] = v[i];\n  }\n  return value;\n}\n\nfunction map_to_map(decoder, len) {\n  var value = new Map();\n  var i;\n  var k = new Array(len);\n  var v = new Array(len);\n\n  var decode = decoder.codec.decode;\n  for (i = 0; i < len; i++) {\n    k[i] = decode(decoder);\n    v[i] = decode(decoder);\n  }\n  for (i = 0; i < len; i++) {\n    value.set(k[i], v[i]);\n  }\n  return value;\n}\n\nfunction array(decoder, len) {\n  var value = new Array(len);\n  var decode = decoder.codec.decode;\n  for (var i = 0; i < len; i++) {\n    value[i] = decode(decoder);\n  }\n  return value;\n}\n\nfunction str(decoder, len) {\n  var start = decoder.reserve(len);\n  var end = start + len;\n  return BufferProto.toString.call(decoder.buffer, \"utf-8\", start, end);\n}\n\nfunction bin_buffer(decoder, len) {\n  var start = decoder.reserve(len);\n  var end = start + len;\n  var buf = BufferProto.slice.call(decoder.buffer, start, end);\n  return Bufferish.from(buf);\n}\n\nfunction bin_arraybuffer(decoder, len) {\n  var start = decoder.reserve(len);\n  var end = start + len;\n  var buf = BufferProto.slice.call(decoder.buffer, start, end);\n  return Bufferish.Uint8Array.from(buf).buffer;\n}\n\nfunction ext(decoder, len) {\n  var start = decoder.reserve(len+1);\n  var type = decoder.buffer[start++];\n  var end = start + len;\n  var unpack = decoder.codec.getExtUnpacker(type);\n  if (!unpack) throw new Error(\"Invalid ext type: \" + (type ? (\"0x\" + type.toString(16)) : type));\n  var buf = BufferProto.slice.call(decoder.buffer, start, end);\n  return unpack(buf);\n}\n\nfunction uint8(decoder) {\n  var start = decoder.reserve(1);\n  return decoder.buffer[start];\n}\n\nfunction int8(decoder) {\n  var start = decoder.reserve(1);\n  var value = decoder.buffer[start];\n  return (value & 0x80) ? value - 0x100 : value;\n}\n\nfunction uint16(decoder) {\n  var start = decoder.reserve(2);\n  var buffer = decoder.buffer;\n  return (buffer[start++] << 8) | buffer[start];\n}\n\nfunction int16(decoder) {\n  var start = decoder.reserve(2);\n  var buffer = decoder.buffer;\n  var value = (buffer[start++] << 8) | buffer[start];\n  return (value & 0x8000) ? value - 0x10000 : value;\n}\n\nfunction uint32(decoder) {\n  var start = decoder.reserve(4);\n  var buffer = decoder.buffer;\n  return (buffer[start++] * 16777216) + (buffer[start++] << 16) + (buffer[start++] << 8) + buffer[start];\n}\n\nfunction int32(decoder) {\n  var start = decoder.reserve(4);\n  var buffer = decoder.buffer;\n  return (buffer[start++] << 24) | (buffer[start++] << 16) | (buffer[start++] << 8) | buffer[start];\n}\n\nfunction read(len, method) {\n  return function(decoder) {\n    var start = decoder.reserve(len);\n    return method.call(decoder.buffer, start, NO_ASSERT);\n  };\n}\n\nfunction readUInt64BE(start) {\n  return new Uint64BE(this, start).toNumber();\n}\n\nfunction readInt64BE(start) {\n  return new Int64BE(this, start).toNumber();\n}\n\nfunction readUInt64BE_int64(start) {\n  return new Uint64BE(this, start);\n}\n\nfunction readInt64BE_int64(start) {\n  return new Int64BE(this, start);\n}\n\nfunction readFloatBE(start) {\n  return ieee754.read(this, start, false, 23, 4);\n}\n\nfunction readDoubleBE(start) {\n  return ieee754.read(this, start, false, 52, 8);\n}\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/read-format.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/read-token.js":
/*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/read-token.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// read-token.js\n\nvar ReadFormat = __webpack_require__(/*! ./read-format */ \"./node_modules/msgpack-lite/lib/read-format.js\");\n\nexports.getReadToken = getReadToken;\n\nfunction getReadToken(options) {\n  var format = ReadFormat.getReadFormat(options);\n\n  if (options && options.useraw) {\n    return init_useraw(format);\n  } else {\n    return init_token(format);\n  }\n}\n\nfunction init_token(format) {\n  var i;\n  var token = new Array(256);\n\n  // positive fixint -- 0x00 - 0x7f\n  for (i = 0x00; i <= 0x7f; i++) {\n    token[i] = constant(i);\n  }\n\n  // fixmap -- 0x80 - 0x8f\n  for (i = 0x80; i <= 0x8f; i++) {\n    token[i] = fix(i - 0x80, format.map);\n  }\n\n  // fixarray -- 0x90 - 0x9f\n  for (i = 0x90; i <= 0x9f; i++) {\n    token[i] = fix(i - 0x90, format.array);\n  }\n\n  // fixstr -- 0xa0 - 0xbf\n  for (i = 0xa0; i <= 0xbf; i++) {\n    token[i] = fix(i - 0xa0, format.str);\n  }\n\n  // nil -- 0xc0\n  token[0xc0] = constant(null);\n\n  // (never used) -- 0xc1\n  token[0xc1] = null;\n\n  // false -- 0xc2\n  // true -- 0xc3\n  token[0xc2] = constant(false);\n  token[0xc3] = constant(true);\n\n  // bin 8 -- 0xc4\n  // bin 16 -- 0xc5\n  // bin 32 -- 0xc6\n  token[0xc4] = flex(format.uint8, format.bin);\n  token[0xc5] = flex(format.uint16, format.bin);\n  token[0xc6] = flex(format.uint32, format.bin);\n\n  // ext 8 -- 0xc7\n  // ext 16 -- 0xc8\n  // ext 32 -- 0xc9\n  token[0xc7] = flex(format.uint8, format.ext);\n  token[0xc8] = flex(format.uint16, format.ext);\n  token[0xc9] = flex(format.uint32, format.ext);\n\n  // float 32 -- 0xca\n  // float 64 -- 0xcb\n  token[0xca] = format.float32;\n  token[0xcb] = format.float64;\n\n  // uint 8 -- 0xcc\n  // uint 16 -- 0xcd\n  // uint 32 -- 0xce\n  // uint 64 -- 0xcf\n  token[0xcc] = format.uint8;\n  token[0xcd] = format.uint16;\n  token[0xce] = format.uint32;\n  token[0xcf] = format.uint64;\n\n  // int 8 -- 0xd0\n  // int 16 -- 0xd1\n  // int 32 -- 0xd2\n  // int 64 -- 0xd3\n  token[0xd0] = format.int8;\n  token[0xd1] = format.int16;\n  token[0xd2] = format.int32;\n  token[0xd3] = format.int64;\n\n  // fixext 1 -- 0xd4\n  // fixext 2 -- 0xd5\n  // fixext 4 -- 0xd6\n  // fixext 8 -- 0xd7\n  // fixext 16 -- 0xd8\n  token[0xd4] = fix(1, format.ext);\n  token[0xd5] = fix(2, format.ext);\n  token[0xd6] = fix(4, format.ext);\n  token[0xd7] = fix(8, format.ext);\n  token[0xd8] = fix(16, format.ext);\n\n  // str 8 -- 0xd9\n  // str 16 -- 0xda\n  // str 32 -- 0xdb\n  token[0xd9] = flex(format.uint8, format.str);\n  token[0xda] = flex(format.uint16, format.str);\n  token[0xdb] = flex(format.uint32, format.str);\n\n  // array 16 -- 0xdc\n  // array 32 -- 0xdd\n  token[0xdc] = flex(format.uint16, format.array);\n  token[0xdd] = flex(format.uint32, format.array);\n\n  // map 16 -- 0xde\n  // map 32 -- 0xdf\n  token[0xde] = flex(format.uint16, format.map);\n  token[0xdf] = flex(format.uint32, format.map);\n\n  // negative fixint -- 0xe0 - 0xff\n  for (i = 0xe0; i <= 0xff; i++) {\n    token[i] = constant(i - 0x100);\n  }\n\n  return token;\n}\n\nfunction init_useraw(format) {\n  var i;\n  var token = init_token(format).slice();\n\n  // raw 8 -- 0xd9\n  // raw 16 -- 0xda\n  // raw 32 -- 0xdb\n  token[0xd9] = token[0xc4];\n  token[0xda] = token[0xc5];\n  token[0xdb] = token[0xc6];\n\n  // fixraw -- 0xa0 - 0xbf\n  for (i = 0xa0; i <= 0xbf; i++) {\n    token[i] = fix(i - 0xa0, format.bin);\n  }\n\n  return token;\n}\n\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\nfunction flex(lenFunc, decodeFunc) {\n  return function(decoder) {\n    var len = lenFunc(decoder);\n    return decodeFunc(decoder, len);\n  };\n}\n\nfunction fix(len, method) {\n  return function(decoder) {\n    return method(decoder, len);\n  };\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/read-token.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/write-core.js":
/*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/write-core.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// write-core.js\n\nvar ExtBuffer = __webpack_require__(/*! ./ext-buffer */ \"./node_modules/msgpack-lite/lib/ext-buffer.js\").ExtBuffer;\nvar ExtPacker = __webpack_require__(/*! ./ext-packer */ \"./node_modules/msgpack-lite/lib/ext-packer.js\");\nvar WriteType = __webpack_require__(/*! ./write-type */ \"./node_modules/msgpack-lite/lib/write-type.js\");\nvar CodecBase = __webpack_require__(/*! ./codec-base */ \"./node_modules/msgpack-lite/lib/codec-base.js\");\n\nCodecBase.install({\n  addExtPacker: addExtPacker,\n  getExtPacker: getExtPacker,\n  init: init\n});\n\nexports.preset = init.call(CodecBase.preset);\n\nfunction getEncoder(options) {\n  var writeType = WriteType.getWriteType(options);\n  return encode;\n\n  function encode(encoder, value) {\n    var func = writeType[typeof value];\n    if (!func) throw new Error(\"Unsupported type \\\"\" + (typeof value) + \"\\\": \" + value);\n    func(encoder, value);\n  }\n}\n\nfunction init() {\n  var options = this.options;\n  this.encode = getEncoder(options);\n\n  if (options && options.preset) {\n    ExtPacker.setExtPackers(this);\n  }\n\n  return this;\n}\n\nfunction addExtPacker(etype, Class, packer) {\n  packer = CodecBase.filter(packer);\n  var name = Class.name;\n  if (name && name !== \"Object\") {\n    var packers = this.extPackers || (this.extPackers = {});\n    packers[name] = extPacker;\n  } else {\n    // fallback for IE\n    var list = this.extEncoderList || (this.extEncoderList = []);\n    list.unshift([Class, extPacker]);\n  }\n\n  function extPacker(value) {\n    if (packer) value = packer(value);\n    return new ExtBuffer(value, etype);\n  }\n}\n\nfunction getExtPacker(value) {\n  var packers = this.extPackers || (this.extPackers = {});\n  var c = value.constructor;\n  var e = c && c.name && packers[c.name];\n  if (e) return e;\n\n  // fallback for IE\n  var list = this.extEncoderList || (this.extEncoderList = []);\n  var len = list.length;\n  for (var i = 0; i < len; i++) {\n    var pair = list[i];\n    if (c === pair[0]) return pair[1];\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/write-core.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/write-token.js":
/*!******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/write-token.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// write-token.js\n\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\");\nvar Int64Buffer = __webpack_require__(/*! int64-buffer */ \"./node_modules/int64-buffer/int64-buffer.js\");\nvar Uint64BE = Int64Buffer.Uint64BE;\nvar Int64BE = Int64Buffer.Int64BE;\n\nvar uint8 = __webpack_require__(/*! ./write-uint8 */ \"./node_modules/msgpack-lite/lib/write-uint8.js\").uint8;\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\nvar Buffer = Bufferish.global;\nvar IS_BUFFER_SHIM = Bufferish.hasBuffer && (\"TYPED_ARRAY_SUPPORT\" in Buffer);\nvar NO_TYPED_ARRAY = IS_BUFFER_SHIM && !Buffer.TYPED_ARRAY_SUPPORT;\nvar Buffer_prototype = Bufferish.hasBuffer && Buffer.prototype || {};\n\nexports.getWriteToken = getWriteToken;\n\nfunction getWriteToken(options) {\n  if (options && options.uint8array) {\n    return init_uint8array();\n  } else if (NO_TYPED_ARRAY || (Bufferish.hasBuffer && options && options.safe)) {\n    return init_safe();\n  } else {\n    return init_token();\n  }\n}\n\nfunction init_uint8array() {\n  var token = init_token();\n\n  // float 32 -- 0xca\n  // float 64 -- 0xcb\n  token[0xca] = writeN(0xca, 4, writeFloatBE);\n  token[0xcb] = writeN(0xcb, 8, writeDoubleBE);\n\n  return token;\n}\n\n// Node.js and browsers with TypedArray\n\nfunction init_token() {\n  // (immediate values)\n  // positive fixint -- 0x00 - 0x7f\n  // nil -- 0xc0\n  // false -- 0xc2\n  // true -- 0xc3\n  // negative fixint -- 0xe0 - 0xff\n  var token = uint8.slice();\n\n  // bin 8 -- 0xc4\n  // bin 16 -- 0xc5\n  // bin 32 -- 0xc6\n  token[0xc4] = write1(0xc4);\n  token[0xc5] = write2(0xc5);\n  token[0xc6] = write4(0xc6);\n\n  // ext 8 -- 0xc7\n  // ext 16 -- 0xc8\n  // ext 32 -- 0xc9\n  token[0xc7] = write1(0xc7);\n  token[0xc8] = write2(0xc8);\n  token[0xc9] = write4(0xc9);\n\n  // float 32 -- 0xca\n  // float 64 -- 0xcb\n  token[0xca] = writeN(0xca, 4, (Buffer_prototype.writeFloatBE || writeFloatBE), true);\n  token[0xcb] = writeN(0xcb, 8, (Buffer_prototype.writeDoubleBE || writeDoubleBE), true);\n\n  // uint 8 -- 0xcc\n  // uint 16 -- 0xcd\n  // uint 32 -- 0xce\n  // uint 64 -- 0xcf\n  token[0xcc] = write1(0xcc);\n  token[0xcd] = write2(0xcd);\n  token[0xce] = write4(0xce);\n  token[0xcf] = writeN(0xcf, 8, writeUInt64BE);\n\n  // int 8 -- 0xd0\n  // int 16 -- 0xd1\n  // int 32 -- 0xd2\n  // int 64 -- 0xd3\n  token[0xd0] = write1(0xd0);\n  token[0xd1] = write2(0xd1);\n  token[0xd2] = write4(0xd2);\n  token[0xd3] = writeN(0xd3, 8, writeInt64BE);\n\n  // str 8 -- 0xd9\n  // str 16 -- 0xda\n  // str 32 -- 0xdb\n  token[0xd9] = write1(0xd9);\n  token[0xda] = write2(0xda);\n  token[0xdb] = write4(0xdb);\n\n  // array 16 -- 0xdc\n  // array 32 -- 0xdd\n  token[0xdc] = write2(0xdc);\n  token[0xdd] = write4(0xdd);\n\n  // map 16 -- 0xde\n  // map 32 -- 0xdf\n  token[0xde] = write2(0xde);\n  token[0xdf] = write4(0xdf);\n\n  return token;\n}\n\n// safe mode: for old browsers and who needs asserts\n\nfunction init_safe() {\n  // (immediate values)\n  // positive fixint -- 0x00 - 0x7f\n  // nil -- 0xc0\n  // false -- 0xc2\n  // true -- 0xc3\n  // negative fixint -- 0xe0 - 0xff\n  var token = uint8.slice();\n\n  // bin 8 -- 0xc4\n  // bin 16 -- 0xc5\n  // bin 32 -- 0xc6\n  token[0xc4] = writeN(0xc4, 1, Buffer.prototype.writeUInt8);\n  token[0xc5] = writeN(0xc5, 2, Buffer.prototype.writeUInt16BE);\n  token[0xc6] = writeN(0xc6, 4, Buffer.prototype.writeUInt32BE);\n\n  // ext 8 -- 0xc7\n  // ext 16 -- 0xc8\n  // ext 32 -- 0xc9\n  token[0xc7] = writeN(0xc7, 1, Buffer.prototype.writeUInt8);\n  token[0xc8] = writeN(0xc8, 2, Buffer.prototype.writeUInt16BE);\n  token[0xc9] = writeN(0xc9, 4, Buffer.prototype.writeUInt32BE);\n\n  // float 32 -- 0xca\n  // float 64 -- 0xcb\n  token[0xca] = writeN(0xca, 4, Buffer.prototype.writeFloatBE);\n  token[0xcb] = writeN(0xcb, 8, Buffer.prototype.writeDoubleBE);\n\n  // uint 8 -- 0xcc\n  // uint 16 -- 0xcd\n  // uint 32 -- 0xce\n  // uint 64 -- 0xcf\n  token[0xcc] = writeN(0xcc, 1, Buffer.prototype.writeUInt8);\n  token[0xcd] = writeN(0xcd, 2, Buffer.prototype.writeUInt16BE);\n  token[0xce] = writeN(0xce, 4, Buffer.prototype.writeUInt32BE);\n  token[0xcf] = writeN(0xcf, 8, writeUInt64BE);\n\n  // int 8 -- 0xd0\n  // int 16 -- 0xd1\n  // int 32 -- 0xd2\n  // int 64 -- 0xd3\n  token[0xd0] = writeN(0xd0, 1, Buffer.prototype.writeInt8);\n  token[0xd1] = writeN(0xd1, 2, Buffer.prototype.writeInt16BE);\n  token[0xd2] = writeN(0xd2, 4, Buffer.prototype.writeInt32BE);\n  token[0xd3] = writeN(0xd3, 8, writeInt64BE);\n\n  // str 8 -- 0xd9\n  // str 16 -- 0xda\n  // str 32 -- 0xdb\n  token[0xd9] = writeN(0xd9, 1, Buffer.prototype.writeUInt8);\n  token[0xda] = writeN(0xda, 2, Buffer.prototype.writeUInt16BE);\n  token[0xdb] = writeN(0xdb, 4, Buffer.prototype.writeUInt32BE);\n\n  // array 16 -- 0xdc\n  // array 32 -- 0xdd\n  token[0xdc] = writeN(0xdc, 2, Buffer.prototype.writeUInt16BE);\n  token[0xdd] = writeN(0xdd, 4, Buffer.prototype.writeUInt32BE);\n\n  // map 16 -- 0xde\n  // map 32 -- 0xdf\n  token[0xde] = writeN(0xde, 2, Buffer.prototype.writeUInt16BE);\n  token[0xdf] = writeN(0xdf, 4, Buffer.prototype.writeUInt32BE);\n\n  return token;\n}\n\nfunction write1(type) {\n  return function(encoder, value) {\n    var offset = encoder.reserve(2);\n    var buffer = encoder.buffer;\n    buffer[offset++] = type;\n    buffer[offset] = value;\n  };\n}\n\nfunction write2(type) {\n  return function(encoder, value) {\n    var offset = encoder.reserve(3);\n    var buffer = encoder.buffer;\n    buffer[offset++] = type;\n    buffer[offset++] = value >>> 8;\n    buffer[offset] = value;\n  };\n}\n\nfunction write4(type) {\n  return function(encoder, value) {\n    var offset = encoder.reserve(5);\n    var buffer = encoder.buffer;\n    buffer[offset++] = type;\n    buffer[offset++] = value >>> 24;\n    buffer[offset++] = value >>> 16;\n    buffer[offset++] = value >>> 8;\n    buffer[offset] = value;\n  };\n}\n\nfunction writeN(type, len, method, noAssert) {\n  return function(encoder, value) {\n    var offset = encoder.reserve(len + 1);\n    encoder.buffer[offset++] = type;\n    method.call(encoder.buffer, value, offset, noAssert);\n  };\n}\n\nfunction writeUInt64BE(value, offset) {\n  new Uint64BE(this, offset, value);\n}\n\nfunction writeInt64BE(value, offset) {\n  new Int64BE(this, offset, value);\n}\n\nfunction writeFloatBE(value, offset) {\n  ieee754.write(this, value, offset, false, 23, 4);\n}\n\nfunction writeDoubleBE(value, offset) {\n  ieee754.write(this, value, offset, false, 52, 8);\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/write-token.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/write-type.js":
/*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/write-type.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// write-type.js\n\nvar IS_ARRAY = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\");\nvar Int64Buffer = __webpack_require__(/*! int64-buffer */ \"./node_modules/int64-buffer/int64-buffer.js\");\nvar Uint64BE = Int64Buffer.Uint64BE;\nvar Int64BE = Int64Buffer.Int64BE;\n\nvar Bufferish = __webpack_require__(/*! ./bufferish */ \"./node_modules/msgpack-lite/lib/bufferish.js\");\nvar BufferProto = __webpack_require__(/*! ./bufferish-proto */ \"./node_modules/msgpack-lite/lib/bufferish-proto.js\");\nvar WriteToken = __webpack_require__(/*! ./write-token */ \"./node_modules/msgpack-lite/lib/write-token.js\");\nvar uint8 = __webpack_require__(/*! ./write-uint8 */ \"./node_modules/msgpack-lite/lib/write-uint8.js\").uint8;\nvar ExtBuffer = __webpack_require__(/*! ./ext-buffer */ \"./node_modules/msgpack-lite/lib/ext-buffer.js\").ExtBuffer;\n\nvar HAS_UINT8ARRAY = (\"undefined\" !== typeof Uint8Array);\nvar HAS_MAP = (\"undefined\" !== typeof Map);\n\nvar extmap = [];\nextmap[1] = 0xd4;\nextmap[2] = 0xd5;\nextmap[4] = 0xd6;\nextmap[8] = 0xd7;\nextmap[16] = 0xd8;\n\nexports.getWriteType = getWriteType;\n\nfunction getWriteType(options) {\n  var token = WriteToken.getWriteToken(options);\n  var useraw = options && options.useraw;\n  var binarraybuffer = HAS_UINT8ARRAY && options && options.binarraybuffer;\n  var isBuffer = binarraybuffer ? Bufferish.isArrayBuffer : Bufferish.isBuffer;\n  var bin = binarraybuffer ? bin_arraybuffer : bin_buffer;\n  var usemap = HAS_MAP && options && options.usemap;\n  var map = usemap ? map_to_map : obj_to_map;\n\n  var writeType = {\n    \"boolean\": bool,\n    \"function\": nil,\n    \"number\": number,\n    \"object\": (useraw ? object_raw : object),\n    \"string\": _string(useraw ? raw_head_size : str_head_size),\n    \"symbol\": nil,\n    \"undefined\": nil\n  };\n\n  return writeType;\n\n  // false -- 0xc2\n  // true -- 0xc3\n  function bool(encoder, value) {\n    var type = value ? 0xc3 : 0xc2;\n    token[type](encoder, value);\n  }\n\n  function number(encoder, value) {\n    var ivalue = value | 0;\n    var type;\n    if (value !== ivalue) {\n      // float 64 -- 0xcb\n      type = 0xcb;\n      token[type](encoder, value);\n      return;\n    } else if (-0x20 <= ivalue && ivalue <= 0x7F) {\n      // positive fixint -- 0x00 - 0x7f\n      // negative fixint -- 0xe0 - 0xff\n      type = ivalue & 0xFF;\n    } else if (0 <= ivalue) {\n      // uint 8 -- 0xcc\n      // uint 16 -- 0xcd\n      // uint 32 -- 0xce\n      type = (ivalue <= 0xFF) ? 0xcc : (ivalue <= 0xFFFF) ? 0xcd : 0xce;\n    } else {\n      // int 8 -- 0xd0\n      // int 16 -- 0xd1\n      // int 32 -- 0xd2\n      type = (-0x80 <= ivalue) ? 0xd0 : (-0x8000 <= ivalue) ? 0xd1 : 0xd2;\n    }\n    token[type](encoder, ivalue);\n  }\n\n  // uint 64 -- 0xcf\n  function uint64(encoder, value) {\n    var type = 0xcf;\n    token[type](encoder, value.toArray());\n  }\n\n  // int 64 -- 0xd3\n  function int64(encoder, value) {\n    var type = 0xd3;\n    token[type](encoder, value.toArray());\n  }\n\n  // str 8 -- 0xd9\n  // str 16 -- 0xda\n  // str 32 -- 0xdb\n  // fixstr -- 0xa0 - 0xbf\n  function str_head_size(length) {\n    return (length < 32) ? 1 : (length <= 0xFF) ? 2 : (length <= 0xFFFF) ? 3 : 5;\n  }\n\n  // raw 16 -- 0xda\n  // raw 32 -- 0xdb\n  // fixraw -- 0xa0 - 0xbf\n  function raw_head_size(length) {\n    return (length < 32) ? 1 : (length <= 0xFFFF) ? 3 : 5;\n  }\n\n  function _string(head_size) {\n    return string;\n\n    function string(encoder, value) {\n      // prepare buffer\n      var length = value.length;\n      var maxsize = 5 + length * 3;\n      encoder.offset = encoder.reserve(maxsize);\n      var buffer = encoder.buffer;\n\n      // expected header size\n      var expected = head_size(length);\n\n      // expected start point\n      var start = encoder.offset + expected;\n\n      // write string\n      length = BufferProto.write.call(buffer, value, start);\n\n      // actual header size\n      var actual = head_size(length);\n\n      // move content when needed\n      if (expected !== actual) {\n        var targetStart = start + actual - expected;\n        var end = start + length;\n        BufferProto.copy.call(buffer, buffer, targetStart, start, end);\n      }\n\n      // write header\n      var type = (actual === 1) ? (0xa0 + length) : (actual <= 3) ? (0xd7 + actual) : 0xdb;\n      token[type](encoder, length);\n\n      // move cursor\n      encoder.offset += length;\n    }\n  }\n\n  function object(encoder, value) {\n    // null\n    if (value === null) return nil(encoder, value);\n\n    // Buffer\n    if (isBuffer(value)) return bin(encoder, value);\n\n    // Array\n    if (IS_ARRAY(value)) return array(encoder, value);\n\n    // int64-buffer objects\n    if (Uint64BE.isUint64BE(value)) return uint64(encoder, value);\n    if (Int64BE.isInt64BE(value)) return int64(encoder, value);\n\n    // ext formats\n    var packer = encoder.codec.getExtPacker(value);\n    if (packer) value = packer(value);\n    if (value instanceof ExtBuffer) return ext(encoder, value);\n\n    // plain old Objects or Map\n    map(encoder, value);\n  }\n\n  function object_raw(encoder, value) {\n    // Buffer\n    if (isBuffer(value)) return raw(encoder, value);\n\n    // others\n    object(encoder, value);\n  }\n\n  // nil -- 0xc0\n  function nil(encoder, value) {\n    var type = 0xc0;\n    token[type](encoder, value);\n  }\n\n  // fixarray -- 0x90 - 0x9f\n  // array 16 -- 0xdc\n  // array 32 -- 0xdd\n  function array(encoder, value) {\n    var length = value.length;\n    var type = (length < 16) ? (0x90 + length) : (length <= 0xFFFF) ? 0xdc : 0xdd;\n    token[type](encoder, length);\n\n    var encode = encoder.codec.encode;\n    for (var i = 0; i < length; i++) {\n      encode(encoder, value[i]);\n    }\n  }\n\n  // bin 8 -- 0xc4\n  // bin 16 -- 0xc5\n  // bin 32 -- 0xc6\n  function bin_buffer(encoder, value) {\n    var length = value.length;\n    var type = (length < 0xFF) ? 0xc4 : (length <= 0xFFFF) ? 0xc5 : 0xc6;\n    token[type](encoder, length);\n    encoder.send(value);\n  }\n\n  function bin_arraybuffer(encoder, value) {\n    bin_buffer(encoder, new Uint8Array(value));\n  }\n\n  // fixext 1 -- 0xd4\n  // fixext 2 -- 0xd5\n  // fixext 4 -- 0xd6\n  // fixext 8 -- 0xd7\n  // fixext 16 -- 0xd8\n  // ext 8 -- 0xc7\n  // ext 16 -- 0xc8\n  // ext 32 -- 0xc9\n  function ext(encoder, value) {\n    var buffer = value.buffer;\n    var length = buffer.length;\n    var type = extmap[length] || ((length < 0xFF) ? 0xc7 : (length <= 0xFFFF) ? 0xc8 : 0xc9);\n    token[type](encoder, length);\n    uint8[value.type](encoder);\n    encoder.send(buffer);\n  }\n\n  // fixmap -- 0x80 - 0x8f\n  // map 16 -- 0xde\n  // map 32 -- 0xdf\n  function obj_to_map(encoder, value) {\n    var keys = Object.keys(value);\n    var length = keys.length;\n    var type = (length < 16) ? (0x80 + length) : (length <= 0xFFFF) ? 0xde : 0xdf;\n    token[type](encoder, length);\n\n    var encode = encoder.codec.encode;\n    keys.forEach(function(key) {\n      encode(encoder, key);\n      encode(encoder, value[key]);\n    });\n  }\n\n  // fixmap -- 0x80 - 0x8f\n  // map 16 -- 0xde\n  // map 32 -- 0xdf\n  function map_to_map(encoder, value) {\n    if (!(value instanceof Map)) return obj_to_map(encoder, value);\n\n    var length = value.size;\n    var type = (length < 16) ? (0x80 + length) : (length <= 0xFFFF) ? 0xde : 0xdf;\n    token[type](encoder, length);\n\n    var encode = encoder.codec.encode;\n    value.forEach(function(val, key, m) {\n      encode(encoder, key);\n      encode(encoder, val);\n    });\n  }\n\n  // raw 16 -- 0xda\n  // raw 32 -- 0xdb\n  // fixraw -- 0xa0 - 0xbf\n  function raw(encoder, value) {\n    var length = value.length;\n    var type = (length < 32) ? (0xa0 + length) : (length <= 0xFFFF) ? 0xda : 0xdb;\n    token[type](encoder, length);\n    encoder.send(value);\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/write-type.js?");

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/write-uint8.js":
/*!******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/write-uint8.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// write-unit8.js\n\nvar constant = exports.uint8 = new Array(256);\n\nfor (var i = 0x00; i <= 0xFF; i++) {\n  constant[i] = write0(i);\n}\n\nfunction write0(type) {\n  return function(encoder) {\n    var offset = encoder.reserve(1);\n    encoder.buffer[offset] = type;\n  };\n}\n\n\n//# sourceURL=webpack:///./node_modules/msgpack-lite/lib/write-uint8.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./scene.tsx":
/*!*******************!*\
  !*** ./scene.tsx ***!
  \*******************/
/*! exports provided: sleep, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sleep\", function() { return sleep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return the2048Game; });\n/* harmony import */ var decentraland_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! decentraland-api */ \"./node_modules/decentraland-api/lib/index.js\");\n/* harmony import */ var decentraland_api__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(decentraland_api__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var components_tile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! components/tile */ \"./components/tile.tsx\");\n/* harmony import */ var src_board__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! src/board */ \"./src/board.ts\");\n/* harmony import */ var ts_EventManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ts/EventManager */ \"./ts/EventManager.ts\");\n\n\n\n\nconst gemSpeed = 300;\nfunction sleep(ms = 0) {\n    return new Promise(r => setTimeout(r, ms));\n}\nclass the2048Game extends decentraland_api__WEBPACK_IMPORTED_MODULE_0__[\"ScriptableScene\"] {\n    constructor() {\n        super(...arguments);\n        this.state = {\n            board: new src_board__WEBPACK_IMPORTED_MODULE_2__[\"Board\"],\n            pointerDown: false,\n            lookingDirection: { x: 0, y: 0, z: 0 },\n            initialDirection: { x: 0, y: 0, z: 0 },\n            openChest: false\n        };\n    }\n    sceneDidMount() {\n        ts_EventManager__WEBPACK_IMPORTED_MODULE_3__[\"EventManager\"].init(this.eventSubscriber);\n        this.eventSubscriber.on('merge', e => this.mergeTiles());\n        this.subscribeTo(\"pointerDown\", e => {\n            this.setState({ pointerDown: true, initialDirection: this.state.lookingDirection });\n        });\n        this.subscribeTo(\"pointerUp\", e => {\n            let deltaX = this.state.initialDirection.x - this.state.lookingDirection.x;\n            let deltaY = this.state.initialDirection.y - this.state.lookingDirection.y;\n            let direction = -1;\n            if (Math.abs(deltaY) < 3 && deltaX < -5) {\n                direction = 0;\n            }\n            else if (deltaY > 5 && Math.abs(deltaX) < 3) {\n                direction = 1;\n            }\n            else if (Math.abs(deltaY) < 3 && deltaX > 5) {\n                direction = 2;\n            }\n            else if (deltaY < -5 && Math.abs(deltaX) < 3) {\n                direction = 3;\n            }\n            this.shiftBlocks(direction);\n            this.setState({ pointerDown: false });\n        });\n        this.subscribeTo(\"rotationChanged\", e => {\n            this.setState({ lookingDirection: e.rotation });\n        });\n        this.eventSubscriber.on(\"chest_click\", () => {\n            this.openChest();\n        });\n    }\n    async shiftBlocks(direction) {\n        if (direction == -1) {\n            return;\n        }\n        this.setState({ board: this.state.board.move(direction) });\n        this.forceUpdate();\n        await sleep(gemSpeed - 50);\n        this.forceUpdate();\n    }\n    openChest() {\n        this.setState({\n            openChest: !this.state.openChest,\n            board: new src_board__WEBPACK_IMPORTED_MODULE_2__[\"Board\"]\n        });\n        console.log(\"action chest\");\n    }\n    mergeTiles() {\n        console.log(\"merged tiles\");\n    }\n    gridToScene(row, col) {\n        var convertedPos = {\n            x: (row * 2) - 3,\n            y: (col * 2) - 2,\n            z: 0\n        };\n        return convertedPos;\n    }\n    renderCells() {\n        var cells = this.state.board.cells.map((row, rowIndex) => {\n            return (decentraland_api__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"](\"entity\", { key: rowIndex }, row.map((_, columnIndex) => decentraland_api__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"](\"plane\", { key: rowIndex * this.state.board.size + columnIndex, position: this.gridToScene(rowIndex, columnIndex) }))));\n        });\n        return cells;\n    }\n    renderTiles() {\n        var tiles = this.state.board.tiles\n            .filter(tile => tile.value != 0 && !tile.mergedInto)\n            .map(tile => decentraland_api__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"](components_tile__WEBPACK_IMPORTED_MODULE_1__[\"Tile\"], { id: tile.id.toString(), position: this.gridToScene(tile.row, tile.column), value: tile.value, speed: gemSpeed }));\n        return tiles;\n    }\n    async render() {\n        return (decentraland_api__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"](\"scene\", null,\n            decentraland_api__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"](\"gltf-model\", { src: \"models/Island.gltf\", position: { x: 5, y: 0, z: 5 }, rotation: { x: 0, y: 90, z: 0 } }),\n            decentraland_api__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"](\"gltf-model\", { id: \"chest\", src: \"models/Chest.gltf\", position: { x: 5, y: 0.3, z: 5 }, rotation: { x: 0, y: 90, z: 0 }, scale: 0.8, skeletalAnimation: this.state.openChest\n                    ? [\n                        { clip: \"Close\", playing: false },\n                        { clip: \"Open\", playing: true, loop: false }\n                    ]\n                    : [\n                        { clip: \"Close\", playing: true, loop: false },\n                        { clip: \"Open\", playing: true }\n                    ] }),\n            this.state.openChest ?\n                decentraland_api__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"](\"entity\", { scale: 0.5, position: { x: 5, y: 4.5, z: 5 } },\n                    this.renderCells(),\n                    this.renderTiles())\n                : decentraland_api__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"](\"entity\", null)));\n    }\n}\n\n\n//# sourceURL=webpack:///./scene.tsx?");

/***/ }),

/***/ "./src/board.ts":
/*!**********************!*\
  !*** ./src/board.ts ***!
  \**********************/
/*! exports provided: sleep, Tile, Board */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sleep\", function() { return sleep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Tile\", function() { return Tile; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Board\", function() { return Board; });\nconst BoardSize = 4;\nconst fourProbability = 0.1;\nconst deltaX = [-1, 0, 1, 0];\nconst deltaY = [0, -1, 0, 1];\nvar rotateLeft = function (matrix) {\n    var rows = matrix.length;\n    var columns = matrix[0].length;\n    var res = [];\n    for (var row = 0; row < rows; ++row) {\n        res.push([]);\n        for (var column = 0; column < columns; ++column) {\n            res[row][column] = matrix[column][columns - row - 1];\n        }\n    }\n    return res;\n};\nvar mergeTiles = async function (old, target) {\n    await sleep(250);\n    old.mergedInto = target;\n};\nfunction sleep(ms = 0) {\n    return new Promise(r => setTimeout(r, ms));\n}\nlet TileId = 0;\nclass Tile {\n    constructor(value, row, column) {\n        this.value = value || 0;\n        this.row = row || -1;\n        this.column = column || -1;\n        this.oldRow = -1;\n        this.oldColumn = -1;\n        this.markForDeletion = false;\n        this.id = TileId++;\n    }\n    moveTo(row, column) {\n        this.oldRow = this.row;\n        this.oldColumn = this.column;\n        this.row = row;\n        this.column = column;\n    }\n    isNew() {\n        return this.oldRow == -1 && !this.mergedInto;\n    }\n    hasMoved() {\n        return (this.fromRow() != -1 && (this.fromRow() != this.toRow() || this.fromColumn() != this.toColumn())) ||\n            this.mergedInto;\n    }\n    fromRow() {\n        return this.mergedInto ? this.row : this.oldRow;\n    }\n    fromColumn() {\n        return this.mergedInto ? this.column : this.oldColumn;\n    }\n    toRow() {\n        return this.mergedInto ? this.mergedInto.row : this.row;\n    }\n    toColumn() {\n        return this.mergedInto ? this.mergedInto.column : this.column;\n    }\n}\nclass Board {\n    constructor() {\n        this.tiles = [];\n        this.cells = [];\n        this.size = BoardSize;\n        for (var i = 0; i < this.size; ++i) {\n            this.cells[i] = [this.addTile(0, i, 1), this.addTile(0, i, 2), this.addTile(0, i, 3), this.addTile(0, i, 4)];\n        }\n        this.addRandomTile();\n        this.setPositions();\n        this.won = false;\n        this.fourProbability = fourProbability;\n        this.deltaX = deltaX;\n        this.deltaY = deltaY;\n    }\n    addTile(value, row, column) {\n        var res = new Tile(value, row, column);\n        this.tiles.push(res);\n        return res;\n    }\n    moveLeft() {\n        var hasChanged = false;\n        for (var row = 0; row < this.size; ++row) {\n            var currentRow = this.cells[row].filter(tile => tile.value != 0);\n            var resultRow = [];\n            for (var target = 0; target < this.size; ++target) {\n                var targetTile = currentRow.length ? currentRow.shift() : this.addTile(0, -1, -1);\n                if (currentRow.length > 0 && currentRow[0].value == targetTile.value) {\n                    var tile1 = targetTile;\n                    targetTile = this.addTile(targetTile.value, targetTile.row, targetTile.column);\n                    tile1.mergedInto = targetTile;\n                    var tile2 = currentRow.shift();\n                    tile2.row = tile1.row;\n                    tile2.column = tile1.column;\n                    mergeTiles(tile2, targetTile);\n                    targetTile.value += tile2.value;\n                }\n                resultRow[target] = targetTile;\n                this.won = (targetTile.value == 2048 ? true : this.won);\n                hasChanged = (targetTile.value != this.cells[row][target].value ? true : hasChanged);\n            }\n            this.cells[row] = resultRow;\n        }\n        return hasChanged;\n    }\n    setPositions() {\n        this.cells.forEach((row, rowIndex) => {\n            row.forEach((tile, columnIndex) => {\n                tile.oldRow = tile.row;\n                tile.oldColumn = tile.column;\n                tile.row = rowIndex;\n                tile.column = columnIndex;\n                tile.markForDeletion = false;\n            });\n        });\n    }\n    addRandomTile() {\n        var emptyCells = [];\n        for (var r = 0; r < this.size; ++r) {\n            for (var c = 0; c < this.size; ++c) {\n                if (this.cells[r][c].value == 0) {\n                    emptyCells.push({ r: r, c: c });\n                }\n            }\n        }\n        var index = ~~(Math.random() * emptyCells.length);\n        var cell = emptyCells[index];\n        var newValue = Math.random() < this.fourProbability ? 4 : 2;\n        console.log(\"new cell added, \" + cell.r + \" & \" + cell.c);\n        this.cells[cell.r][cell.c] = this.addTile(newValue, cell.r, cell.c);\n    }\n    move(direction) {\n        this.clearOldTiles();\n        for (var i = 0; i < direction; ++i) {\n            this.cells = rotateLeft(this.cells);\n        }\n        var hasChanged = this.moveLeft();\n        for (var i = direction; i < 4; ++i) {\n            this.cells = rotateLeft(this.cells);\n        }\n        if (hasChanged) {\n            this.addRandomTile();\n        }\n        this.setPositions();\n        return this;\n    }\n    clearOldTiles() {\n        this.tiles = this.tiles.filter(tile => tile.markForDeletion == false);\n        this.tiles.forEach(tile => { tile.markForDeletion = true; });\n    }\n    hasWon() {\n        return this.won;\n    }\n    hasLost() {\n        var canMove = false;\n        for (var row = 0; row < this.size; ++row) {\n            for (var column = 0; column < this.size; ++column) {\n                canMove = (this.cells[row][column].value == 0 ? true : canMove);\n                for (var dir = 0; dir < 4; ++dir) {\n                    var newRow = row + this.deltaX[dir];\n                    var newColumn = column + this.deltaY[dir];\n                    if (newRow < 0 || newRow >= this.size || newColumn < 0 || newColumn >= this.size) {\n                        continue;\n                    }\n                    canMove = (this.cells[row][column].value == this.cells[newRow][newColumn].value ? true : canMove);\n                }\n            }\n        }\n        return !canMove;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/board.ts?");

/***/ }),

/***/ "./ts/EventManager.ts":
/*!****************************!*\
  !*** ./ts/EventManager.ts ***!
  \****************************/
/*! exports provided: EventManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EventManager\", function() { return EventManager; });\nvar EventManager;\n(function (EventManager) {\n    let eventSubscriber;\n    function init(_eventSubscriber) {\n        eventSubscriber = _eventSubscriber;\n    }\n    EventManager.init = init;\n    function emit(eventType, ...params) {\n        eventSubscriber.emit(eventType, ...params);\n    }\n    EventManager.emit = emit;\n})(EventManager || (EventManager = {}));\n\n\n//# sourceURL=webpack:///./ts/EventManager.ts?");

/***/ })

/******/ })));