import { Script, EventSubscriber } from 'decentraland-rpc';
import { ISimplifiedNode } from './interfaces';
import { IEventNames, IEvents } from './events';
export declare const defer: any;
export declare function recursiveRender(tree: ISimplifiedNode): ISimplifiedNode | null;
export interface ScriptableScene<Props, State> {
    props: Props;
    state: State;
    /**
     * Called to determine whether the change in props and state should trigger a re-render.
     *
     * If false is returned, `ScriptableScene#render`, and `sceneDidUpdate` will not be called.
     */
    shouldSceneUpdate?(nextProps: Props, nextState: State): Promise<boolean> | boolean;
    /**
     * Called immediately before a scene is destroyed. Perform any necessary cleanup in this method, such as
     * cancelled network requests, or cleaning up any elements created in `sceneDidMount`.
     */
    sceneWillUnmount?(): Promise<void> | void;
    /**
     * Called immediately after a compoment is mounted. Setting state here will trigger re-rendering.
     */
    sceneDidMount?(): Promise<void> | void;
    /**
     * Called immediately after updating occurs. Not called for the initial render.
     */
    sceneDidUpdate?(prevProps: Readonly<Props>, prevState: Readonly<State>): Promise<void> | void;
}
/**
 * Base Scene class.
 * Provides `setState()` and `forceUpdate()`, which trigger rendering.
 * @public
 *
 * @example
 * class MyFoo extends ScriptableScene {
 *   async render() {
 *     return <sphere />;
 *   }
 * }
 */
export declare abstract class ScriptableScene<Props = {}, State = {}> extends Script {
    eventSubscriber: EventSubscriber;
    state: State;
    props: Props;
    /**
     * Update scene state by copying properties from `state` to `this.state`.
     * @param {object} state A hash of state properties to update with new values
     */
    setState(state: Partial<State> | ((state: State, props: Props) => Partial<State>)): void;
    /**
     * Immediately perform a synchronous re-render of the component.
     */
    forceUpdate(): void;
    /**
     * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.
     * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).
     * @param {object} props    Props (eg: JSX attributes) received from parent element/component
     * @param {object} state    The component's current state
     */
    abstract render(props: Props, state: State): Promise<ISimplifiedNode>;
    /**
     * It makes a subscription to remote events, those events occur in the context of the game and are sent thru the wire
     * protocol.
     *
     * @param event name of the remote event to listen
     * @param handler an async
     */
    subscribeTo<T extends IEventNames>(event: T, handler: (data: IEvents[T]) => void | Promise<void>): void;
    /**
     * Get a standard ethereum provider
     * Please notice this is highly experimental and might change in the future.
     *
     * method whitelist = [
     *   'eth_sendTransaction',
     *   'eth_getTransactionReceipt',
     *   'eth_estimateGas',
     *   'eth_call',
     *   'eth_getBalance',
     *   'eth_getStorageAt',
     *   'eth_blockNumber',
     *   'eth_getBlockByNumber',
     *   'eth_gasPrice',
     *   'eth_protocolVersion',
     *   'net_version',
     *   'web3_sha3',
     *   'web3_clientVersion',
     *   'eth_getTransactionCount'
     * ]
     */
    getEthereumProvider(): Promise<{
        send: Function;
        sendAsync: Function;
    }>;
}
