"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("./common");
/**
 * HttpProvider should be used to send rpc calls over http
 */
class HTTPProvider {
    constructor(host, options = {}) {
        this.host = host;
        this.options = options;
        this.debug = false;
        this.host = host || 'http://localhost:8545';
    }
    /* istanbul ignore next */
    // tslint:disable-next-line:prefer-function-over-method
    send() {
        /* istanbul ignore next */
        throw new Error('Sync requests are deprecated');
    }
    /**
     * Should be used to make async request
     *
     * @method send
     * @param {Object} payload
     * @param {Function} callback triggered on end with (err, result)
     */
    sendAsync(payload, callback) {
        try {
            let toSend = null;
            if (payload instanceof Array) {
                toSend = payload.map($ => common_1.toRPC($));
            }
            else {
                toSend = common_1.toRPC(payload);
            }
            /* istanbul ignore if */
            if (typeof fetch === 'undefined') {
                throw new Error('There is no global fetch object. Please install and import isomorphic-fetch');
            }
            const params = {
                body: JSON.stringify(toSend),
                method: 'POST',
                // mode: 'cors',
                headers: Object.assign({}, this.options.headers, { 'Content-Type': 'application/json' })
            };
            /* istanbul ignore if */
            // tslint:disable-next-line:no-console
            if (this.debug)
                console.log('SEND >> ' + params.body);
            fetch(this.host, params).then(async ($) => {
                if (!$.ok) {
                    /* istanbul ignore if */
                    // tslint:disable-next-line:no-console
                    if (this.debug)
                        console.log('ERR << ' + JSON.stringify($));
                    callback(new Error('External error. response code: ' + $.status));
                }
                else {
                    const json = await $.json();
                    /* istanbul ignore if */
                    // tslint:disable-next-line:no-console
                    if (this.debug)
                        console.log('RECV << ' + JSON.stringify(json));
                    if (json.error) {
                        callback(json);
                    }
                    else {
                        callback(null, json);
                    }
                }
            }, err => {
                /* istanbul ignore if */
                // tslint:disable-next-line:no-console
                if (this.debug)
                    console.log('ERR << ' + JSON.stringify(err));
                callback(err);
            });
        }
        catch (e) {
            /* istanbul ignore if */
            // tslint:disable-next-line:no-console
            if (this.debug)
                console.log('ERR << ' + JSON.stringify(e));
            callback(e);
        }
    }
}
exports.HTTPProvider = HTTPProvider;
//# sourceMappingURL=HTTPProvider.js.map