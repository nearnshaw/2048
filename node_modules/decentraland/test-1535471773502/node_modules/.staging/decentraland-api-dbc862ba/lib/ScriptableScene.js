"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
const decentraland_rpc_1 = require("decentraland-rpc");
const future_1 = require("./utils/future");
const handlers_1 = require("./handlers");
const interfaces_1 = require("./interfaces");
exports.defer = Promise.resolve().then.bind(Promise.resolve());
/** Managed queue of dirty components to be re-rendered */
let items = [];
function enqueueRender(scene) {
    if (!scene._dirty) {
        scene._dirty = true;
        if (items.push(scene) === 1) {
            exports.defer(rerender);
        }
    }
}
function rerender() {
    let p;
    const list = items;
    items = [];
    // tslint:disable-next-line:no-conditional-assignment
    while ((p = list.pop())) {
        if (p._dirty)
            renderScriptableScene(p);
    }
}
function filterNonFalsy($) {
    return !!$;
}
let currentFunctionMap;
const attrRegularExpression = /^on[A-Z]/;
/**
 * This function finds recursively all the /on[A-Z]./ attributes that are also a
 * function, then it replaces the function by a UUID. It stores the reference in
 * the currentFunctionMap
 */
function fixCallbacks(scene) {
    currentFunctionMap = scene._functionMap;
    if (!currentFunctionMap) {
        currentFunctionMap = scene._functionMap = new Map();
    }
    else {
        currentFunctionMap.clear();
    }
    if (scene._component) {
        fixAttributes(scene._component);
    }
}
function fixAttributes(node) {
    if (node.attrs) {
        for (let i in node.attrs) {
            if (attrRegularExpression.test(i)) {
                if (typeof node.attrs[i] === 'function') {
                    const fn = node.attrs[i];
                    const id = handlers_1.putHandler(fn);
                    currentFunctionMap.set(id, fn);
                    node.attrs[i] = id;
                }
            }
        }
    }
    if (node.children) {
        for (let i = 0; i < node.children.length; i++) {
            fixAttributes(node.children[i]);
        }
    }
}
function recursiveRender(tree) {
    if (typeof tree === 'string') {
        // tslint:disable-next-line:no-console
        console.error('Warning, you are trying to render a text');
        return null;
    }
    if (typeof tree.tag === 'function') {
        const hoc = tree.tag;
        if (hoc.prototype && hoc.prototype.render) {
            throw new Error('Only function components are allowed');
        }
        return hoc(Object.assign({}, tree.attrs, { children: tree.children }));
    }
    if (!tree || !tree.tag)
        return null;
    return {
        tag: tree.tag,
        attrs: tree.attrs,
        children: tree.children.map(recursiveRender).filter(filterNonFalsy)
    };
}
exports.recursiveRender = recursiveRender;
/**
 * Render a ScriptableScene, triggering necessary lifecycle events and taking High-Order ScriptableScenes into account.
 * @param {ScriptableScene} scene
 * @internal
 */
function renderScriptableScene(scene, force) {
    let props = scene.props;
    let state = scene.state;
    let previousProps = scene.prevProps || props;
    let previousState = scene.prevState || state;
    let skip = false;
    const isUpdate = !!scene._component;
    // if updating
    if (isUpdate) {
        scene.props = previousProps;
        scene.state = previousState;
        if (!force && scene.shouldSceneUpdate && scene.shouldSceneUpdate(props, state) === false) {
            skip = true;
        }
        scene.props = props;
        scene.state = state;
    }
    scene.prevProps = scene.prevState = null;
    scene._dirty = false;
    if (!skip) {
        let rendererResult = scene.render(props, state);
        if (!('then' in rendererResult && 'catch' in rendererResult)) {
            rendererResult = Promise.resolve(rendererResult);
        }
        rendererResult
            .then(recursiveRender)
            .then(async (rendered) => {
            if (!rendered) {
                throw new Error('the async render() method yielded an empty result');
            }
            scene._component = rendered;
            // replace functions by uuids
            fixCallbacks(scene);
            if (scene.sceneDidUpdate) {
                await scene.sceneDidUpdate(previousProps, previousState);
            }
            await scene.connectionFuture;
            try {
                // TODO(agus): diff/patch
                await scene.entityController.render(rendered);
            }
            catch (e) {
                if (e.message === interfaces_1.Constants.ReplaceWholeTreeException) {
                    await scene.entityController.render(rendered);
                }
                else {
                    throw e;
                }
            }
        })
            .catch(err => {
            // tslint:disable-next-line:no-console
            console.error(err);
        });
    }
}
exports.renderScriptableScene = renderScriptableScene;
/**
 * Base Scene class.
 * Provides `setState()` and `forceUpdate()`, which trigger rendering.
 * @public
 *
 * @example
 * class MyFoo extends ScriptableScene {
 *   async render() {
 *     return <sphere />;
 *   }
 * }
 */
class ScriptableScene extends decentraland_rpc_1.Script {
    constructor() {
        super(...arguments);
        // @internal
        this._dirty = true;
        // @internal
        this._functionMap = new Map();
        // @internal
        this.prevProps = null;
        // @internal
        this.prevState = null;
        // @internal
        this._component = null;
        this.state = {};
        // @internal
        this.connectionFuture = future_1.future();
        // @internal
        this.receiveClickEvent = (event) => {
            const map = this._functionMap;
            if (map) {
                const fn = map.get(event.data.uuid);
                if (fn) {
                    fn(event.data.payload);
                }
            }
        };
    }
    /**
     * Update scene state by copying properties from `state` to `this.state`.
     * @param {object} state A hash of state properties to update with new values
     */
    setState(state) {
        let s = this.state;
        if (!this.prevState)
            this.prevState = Object.assign({}, s);
        Object.assign(s, typeof state === 'function' ? state(s, this.props) : state);
        enqueueRender(this);
    }
    /**
     * Immediately perform a synchronous re-render of the component.
     */
    forceUpdate() {
        renderScriptableScene(this, true);
    }
    /**
     * It makes a subscription to remote events, those events occur in the context of the game and are sent thru the wire
     * protocol.
     *
     * @param event name of the remote event to listen
     * @param handler an async
     */
    subscribeTo(event, handler) {
        // tslint:disable-next-line:no-floating-promises
        this.connectionFuture.then(() => {
            this.eventSubscriber.on(event, x => {
                const ret = handler(x.data);
                if (ret && 'catch' in ret && typeof ret.catch === 'function') {
                    ret.catch(err => this.emit('error', err));
                }
            });
        });
    }
    /**
     * Get a standard ethereum provider
     * Please notice this is highly experimental and might change in the future.
     *
     * method whitelist = [
     *   'eth_sendTransaction',
     *   'eth_getTransactionReceipt',
     *   'eth_estimateGas',
     *   'eth_call',
     *   'eth_getBalance',
     *   'eth_getStorageAt',
     *   'eth_blockNumber',
     *   'eth_getBlockByNumber',
     *   'eth_gasPrice',
     *   'eth_protocolVersion',
     *   'net_version',
     *   'web3_sha3',
     *   'web3_clientVersion',
     *   'eth_getTransactionCount'
     * ]
     */
    async getEthereumProvider() {
        const { EthereumController } = await this.loadAPIs(['EthereumController']);
        return {
            // @internal
            send(message, callback) {
                if (message && callback && callback instanceof Function) {
                    EthereumController.sendAsync(message)
                        .then((x) => callback(null, x))
                        .catch(callback);
                }
                else {
                    throw new Error('Decentraland provider only allows async calls');
                }
            },
            sendAsync(message, callback) {
                EthereumController.sendAsync(message)
                    .then((x) => callback(null, x))
                    .catch(callback);
            }
        };
    }
    // @internal
    async systemDidEnable() {
        this.props = (await this.entityController.getOwnAttributes());
        // we create an event subscriber
        this.eventSubscriber = new decentraland_rpc_1.EventSubscriber(this.entityController);
        this.on('SIGKILL', () => {
            if (this.sceneWillUnmount) {
                this.sceneWillUnmount();
            }
        });
        this.subscribeTo('setAttributes', newProps => {
            this.prevProps = this.props;
            this.props = newProps;
            enqueueRender(this);
        });
        this.connectionFuture.resolve(this);
        renderScriptableScene(this, true);
        this.eventSubscriber.on('uuidEvent', this.receiveClickEvent);
        if (this.sceneDidMount) {
            await this.sceneDidMount();
        }
    }
}
__decorate([
    decentraland_rpc_1.inject('EntityController'),
    __metadata("design:type", Object)
], ScriptableScene.prototype, "entityController", void 0);
exports.ScriptableScene = ScriptableScene;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2NyaXB0YWJsZVNjZW5lLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL1NjcmlwdGFibGVTY2VuZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLHVEQUFrRTtBQUNsRSwyQ0FBdUM7QUFDdkMseUNBQXVDO0FBQ3ZDLDZDQUF5RDtBQUk1QyxRQUFBLEtBQUssR0FBRyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQTtBQUVuRSwwREFBMEQ7QUFFMUQsSUFBSSxLQUFLLEdBQWdDLEVBQUUsQ0FBQTtBQUUzQyxTQUFTLGFBQWEsQ0FBTyxLQUE0QjtJQUN2RCxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRTtRQUNqQixLQUFLLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQTtRQUNuQixJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQzNCLGFBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQTtTQUNoQjtLQUNGO0FBQ0gsQ0FBQztBQUVELFNBQVMsUUFBUTtJQUNmLElBQUksQ0FBOEIsQ0FBQTtJQUNsQyxNQUFNLElBQUksR0FBc0IsS0FBSyxDQUFBO0lBQ3JDLEtBQUssR0FBRyxFQUFFLENBQUE7SUFDVixxREFBcUQ7SUFDckQsT0FBTyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRTtRQUN2QixJQUFJLENBQUMsQ0FBQyxNQUFNO1lBQUUscUJBQXFCLENBQUMsQ0FBQyxDQUFDLENBQUE7S0FDdkM7QUFDSCxDQUFDO0FBRUQsU0FBUyxjQUFjLENBQUMsQ0FBTTtJQUM1QixPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUE7QUFDWixDQUFDO0FBRUQsSUFBSSxrQkFBeUMsQ0FBQTtBQUM3QyxNQUFNLHFCQUFxQixHQUFHLFVBQVUsQ0FBQTtBQUV4Qzs7OztHQUlHO0FBQ0gsU0FBUyxZQUFZLENBQUMsS0FBZ0M7SUFDcEQsa0JBQWtCLEdBQUcsS0FBSyxDQUFDLFlBQVksQ0FBQTtJQUV2QyxJQUFJLENBQUMsa0JBQWtCLEVBQUU7UUFDdkIsa0JBQWtCLEdBQUcsS0FBSyxDQUFDLFlBQVksR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFBO0tBQ3BEO1NBQU07UUFDTCxrQkFBa0IsQ0FBQyxLQUFLLEVBQUUsQ0FBQTtLQUMzQjtJQUVELElBQUksS0FBSyxDQUFDLFVBQVUsRUFBRTtRQUNwQixhQUFhLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFBO0tBQ2hDO0FBQ0gsQ0FBQztBQUVELFNBQVMsYUFBYSxDQUFDLElBQXFCO0lBQzFDLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtRQUNkLEtBQUssSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtZQUN4QixJQUFJLHFCQUFxQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRTtnQkFDakMsSUFBSSxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssVUFBVSxFQUFFO29CQUN2QyxNQUFNLEVBQUUsR0FBUSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFBO29CQUM3QixNQUFNLEVBQUUsR0FBRyxxQkFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFBO29CQUN6QixrQkFBa0IsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFBO29CQUM5QixJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQTtpQkFDbkI7YUFDRjtTQUNGO0tBQ0Y7SUFFRCxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7UUFDakIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQzdDLGFBQWEsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7U0FDaEM7S0FDRjtBQUNILENBQUM7QUFFRCxTQUFnQixlQUFlLENBQUMsSUFBcUI7SUFDbkQsSUFBSSxPQUFPLElBQUksS0FBSyxRQUFRLEVBQUU7UUFDNUIsc0NBQXNDO1FBQ3RDLE9BQU8sQ0FBQyxLQUFLLENBQUMsMENBQTBDLENBQUMsQ0FBQTtRQUN6RCxPQUFPLElBQUksQ0FBQTtLQUNaO0lBRUQsSUFBSSxPQUFRLElBQUksQ0FBQyxHQUFXLEtBQUssVUFBVSxFQUFFO1FBQzNDLE1BQU0sR0FBRyxHQUFJLElBQUksQ0FBQyxHQUF1QixDQUFBO1FBQ3pDLElBQUksR0FBRyxDQUFDLFNBQVMsSUFBSSxHQUFHLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRTtZQUN6QyxNQUFNLElBQUksS0FBSyxDQUFDLHNDQUFzQyxDQUFDLENBQUE7U0FDeEQ7UUFDRCxPQUFPLEdBQUcsbUJBQU0sSUFBSSxDQUFDLEtBQUssSUFBRSxRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVEsSUFBRyxDQUFBO0tBQ3ZEO0lBRUQsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHO1FBQUUsT0FBTyxJQUFJLENBQUE7SUFFbkMsT0FBTztRQUNMLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRztRQUNiLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSztRQUNqQixRQUFRLEVBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsZUFBZSxDQUFDLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBOEI7S0FDbEcsQ0FBQTtBQUNILENBQUM7QUF0QkQsMENBc0JDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQWdCLHFCQUFxQixDQUFlLEtBQW9DLEVBQUUsS0FBZTtJQUN2RyxJQUFJLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFBO0lBQ3ZCLElBQUksS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUE7SUFDdkIsSUFBSSxhQUFhLEdBQUcsS0FBSyxDQUFDLFNBQVMsSUFBSSxLQUFLLENBQUE7SUFDNUMsSUFBSSxhQUFhLEdBQUcsS0FBSyxDQUFDLFNBQVMsSUFBSSxLQUFLLENBQUE7SUFDNUMsSUFBSSxJQUFJLEdBQUcsS0FBSyxDQUFBO0lBQ2hCLE1BQU0sUUFBUSxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFBO0lBRW5DLGNBQWM7SUFDZCxJQUFJLFFBQVEsRUFBRTtRQUNaLEtBQUssQ0FBQyxLQUFLLEdBQUcsYUFBYSxDQUFBO1FBQzNCLEtBQUssQ0FBQyxLQUFLLEdBQUcsYUFBYSxDQUFBO1FBQzNCLElBQUksQ0FBQyxLQUFLLElBQUksS0FBSyxDQUFDLGlCQUFpQixJQUFJLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLEtBQUssS0FBSyxFQUFFO1lBQ3hGLElBQUksR0FBRyxJQUFJLENBQUE7U0FDWjtRQUNELEtBQUssQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFBO1FBQ25CLEtBQUssQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFBO0tBQ3BCO0lBRUQsS0FBSyxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQTtJQUN4QyxLQUFLLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQTtJQUVwQixJQUFJLENBQUMsSUFBSSxFQUFFO1FBQ1QsSUFBSSxjQUFjLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUE7UUFFL0MsSUFBSSxDQUFDLENBQUMsTUFBTSxJQUFJLGNBQWMsSUFBSSxPQUFPLElBQUksY0FBYyxDQUFDLEVBQUU7WUFDNUQsY0FBYyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUE7U0FDakQ7UUFFRCxjQUFjO2FBQ1gsSUFBSSxDQUFDLGVBQWUsQ0FBQzthQUNyQixJQUFJLENBQUMsS0FBSyxFQUFDLFFBQVEsRUFBQyxFQUFFO1lBQ3JCLElBQUksQ0FBQyxRQUFRLEVBQUU7Z0JBQ2IsTUFBTSxJQUFJLEtBQUssQ0FBQyxtREFBbUQsQ0FBQyxDQUFBO2FBQ3JFO1lBRUQsS0FBSyxDQUFDLFVBQVUsR0FBRyxRQUFRLENBQUE7WUFFM0IsNkJBQTZCO1lBQzdCLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQTtZQUVuQixJQUFJLEtBQUssQ0FBQyxjQUFjLEVBQUU7Z0JBQ3hCLE1BQU0sS0FBSyxDQUFDLGNBQWMsQ0FBQyxhQUFhLEVBQUUsYUFBYSxDQUFDLENBQUE7YUFDekQ7WUFFRCxNQUFNLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQTtZQUU1QixJQUFJO2dCQUNGLHlCQUF5QjtnQkFDekIsTUFBTSxLQUFLLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFBO2FBQzlDO1lBQUMsT0FBTyxDQUFDLEVBQUU7Z0JBQ1YsSUFBSSxDQUFDLENBQUMsT0FBTyxLQUFLLHNCQUFTLENBQUMseUJBQXlCLEVBQUU7b0JBQ3JELE1BQU0sS0FBSyxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQTtpQkFDOUM7cUJBQU07b0JBQ0wsTUFBTSxDQUFDLENBQUE7aUJBQ1I7YUFDRjtRQUNILENBQUMsQ0FBQzthQUNELEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUNYLHNDQUFzQztZQUN0QyxPQUFPLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFBO1FBQ3BCLENBQUMsQ0FBQyxDQUFBO0tBQ0w7QUFDSCxDQUFDO0FBL0RELHNEQStEQztBQThCRDs7Ozs7Ozs7Ozs7R0FXRztBQUNILE1BQXNCLGVBQXdDLFNBQVEseUJBQU07SUFBNUU7O1FBT0UsWUFBWTtRQUNaLFdBQU0sR0FBRyxJQUFJLENBQUE7UUFDYixZQUFZO1FBQ1osaUJBQVksR0FBRyxJQUFJLEdBQUcsRUFBb0IsQ0FBQTtRQUMxQyxZQUFZO1FBQ1osY0FBUyxHQUFpQixJQUFJLENBQUE7UUFDOUIsWUFBWTtRQUNaLGNBQVMsR0FBaUIsSUFBSSxDQUFBO1FBQzlCLFlBQVk7UUFDWixlQUFVLEdBQTJCLElBQUksQ0FBQTtRQUV6QyxVQUFLLEdBQVUsRUFBVyxDQUFBO1FBRTFCLFlBQVk7UUFDWixxQkFBZ0IsR0FBRyxlQUFNLEVBQVUsQ0FBQTtRQStGbkMsWUFBWTtRQUNaLHNCQUFpQixHQUFHLENBQUMsS0FBVSxFQUFFLEVBQUU7WUFDakMsTUFBTSxHQUFHLEdBQTBCLElBQUksQ0FBQyxZQUFZLENBQUE7WUFDcEQsSUFBSSxHQUFHLEVBQUU7Z0JBQ1AsTUFBTSxFQUFFLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFBO2dCQUNuQyxJQUFJLEVBQUUsRUFBRTtvQkFDTixFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQTtpQkFDdkI7YUFDRjtRQUNILENBQUMsQ0FBQTtJQStCSCxDQUFDO0lBbklDOzs7T0FHRztJQUNILFFBQVEsQ0FBQyxLQUF3RTtRQUMvRSxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFBO1FBQ2xCLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUztZQUFFLElBQUksQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUE7UUFDMUQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsT0FBTyxLQUFLLEtBQUssVUFBVSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUE7UUFDNUUsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFBO0lBQ3JCLENBQUM7SUFFRDs7T0FFRztJQUNILFdBQVc7UUFDVCxxQkFBcUIsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUE7SUFDbkMsQ0FBQztJQVVEOzs7Ozs7T0FNRztJQUNILFdBQVcsQ0FBd0IsS0FBUSxFQUFFLE9BQW1EO1FBQzlGLGdEQUFnRDtRQUNoRCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRTtZQUM5QixJQUFJLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLEVBQUU7Z0JBQ2pDLE1BQU0sR0FBRyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUE7Z0JBQzNCLElBQUksR0FBRyxJQUFJLE9BQU8sSUFBSSxHQUFHLElBQUksT0FBTyxHQUFHLENBQUMsS0FBSyxLQUFLLFVBQVUsRUFBRTtvQkFDNUQsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUE7aUJBQzFDO1lBQ0gsQ0FBQyxDQUFDLENBQUE7UUFDSixDQUFDLENBQUMsQ0FBQTtJQUNKLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FvQkc7SUFDSCxLQUFLLENBQUMsbUJBQW1CO1FBQ3ZCLE1BQU0sRUFBRSxrQkFBa0IsRUFBRSxHQUFHLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQTtRQUUxRSxPQUFPO1lBQ0wsWUFBWTtZQUNaLElBQUksQ0FBQyxPQUEyQixFQUFFLFFBQXNEO2dCQUN0RixJQUFJLE9BQU8sSUFBSSxRQUFRLElBQUksUUFBUSxZQUFZLFFBQVEsRUFBRTtvQkFDdkQsa0JBQWtCLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQzt5QkFDbEMsSUFBSSxDQUFDLENBQUMsQ0FBTSxFQUFFLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO3lCQUNuQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUE7aUJBQ25CO3FCQUFNO29CQUNMLE1BQU0sSUFBSSxLQUFLLENBQUMsK0NBQStDLENBQUMsQ0FBQTtpQkFDakU7WUFDSCxDQUFDO1lBQ0QsU0FBUyxDQUFDLE9BQTJCLEVBQUUsUUFBcUQ7Z0JBQzFGLGtCQUFrQixDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUM7cUJBQ2xDLElBQUksQ0FBQyxDQUFDLENBQU0sRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztxQkFDbkMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFBO1lBQ3BCLENBQUM7U0FJRixDQUFBO0lBQ0gsQ0FBQztJQWFELFlBQVk7SUFDWixLQUFLLENBQUMsZUFBZTtRQUNuQixJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsTUFBTSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsZ0JBQWdCLEVBQUUsQ0FBVSxDQUFBO1FBRXRFLGdDQUFnQztRQUNoQyxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksa0NBQWUsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQTtRQUVqRSxJQUFJLENBQUMsRUFBRSxDQUFDLFNBQVMsRUFBRSxHQUFHLEVBQUU7WUFDdEIsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7Z0JBQ3pCLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFBO2FBQ3hCO1FBQ0gsQ0FBQyxDQUFDLENBQUE7UUFFRixJQUFJLENBQUMsV0FBVyxDQUFDLGVBQWUsRUFBRSxRQUFRLENBQUMsRUFBRTtZQUMzQyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUE7WUFDM0IsSUFBSSxDQUFDLEtBQUssR0FBRyxRQUFpQixDQUFBO1lBQzlCLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQTtRQUNyQixDQUFDLENBQUMsQ0FBQTtRQUVGLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUE7UUFFbkMscUJBQXFCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFBO1FBRWpDLElBQUksQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQTtRQUU1RCxJQUFJLElBQUksQ0FBQyxhQUFhLEVBQUU7WUFDdEIsTUFBTSxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUE7U0FDM0I7SUFDSCxDQUFDO0NBQ0Y7QUF6SkM7SUFEQyx5QkFBTSxDQUFDLGtCQUFrQixDQUFDOzt5REFDUTtBQUhyQywwQ0E0SkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTY3JpcHQsIGluamVjdCwgRXZlbnRTdWJzY3JpYmVyIH0gZnJvbSAnZGVjZW50cmFsYW5kLXJwYydcbmltcG9ydCB7IGZ1dHVyZSB9IGZyb20gJy4vdXRpbHMvZnV0dXJlJ1xuaW1wb3J0IHsgcHV0SGFuZGxlciB9IGZyb20gJy4vaGFuZGxlcnMnXG5pbXBvcnQgeyBJU2ltcGxpZmllZE5vZGUsIENvbnN0YW50cyB9IGZyb20gJy4vaW50ZXJmYWNlcydcbmltcG9ydCB7IEVudGl0eUNvbnRyb2xsZXIsIFJQQ1NlbmRhYmxlTWVzc2FnZSB9IGZyb20gJy4vYXBpcydcbmltcG9ydCB7IElFdmVudE5hbWVzLCBJRXZlbnRzIH0gZnJvbSAnLi9ldmVudHMnXG5cbmV4cG9ydCBjb25zdCBkZWZlciA9IFByb21pc2UucmVzb2x2ZSgpLnRoZW4uYmluZChQcm9taXNlLnJlc29sdmUoKSlcblxuLyoqIE1hbmFnZWQgcXVldWUgb2YgZGlydHkgY29tcG9uZW50cyB0byBiZSByZS1yZW5kZXJlZCAqL1xuXG5sZXQgaXRlbXM6IFNjcmlwdGFibGVTY2VuZTxhbnksIGFueT5bXSA9IFtdXG5cbmZ1bmN0aW9uIGVucXVldWVSZW5kZXI8RCwgVD4oc2NlbmU6IFNjcmlwdGFibGVTY2VuZTxELCBUPikge1xuICBpZiAoIXNjZW5lLl9kaXJ0eSkge1xuICAgIHNjZW5lLl9kaXJ0eSA9IHRydWVcbiAgICBpZiAoaXRlbXMucHVzaChzY2VuZSkgPT09IDEpIHtcbiAgICAgIGRlZmVyKHJlcmVuZGVyKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXJlbmRlcigpIHtcbiAgbGV0IHA6IFNjcmlwdGFibGVTY2VuZSB8IHVuZGVmaW5lZFxuICBjb25zdCBsaXN0OiBTY3JpcHRhYmxlU2NlbmVbXSA9IGl0ZW1zXG4gIGl0ZW1zID0gW11cbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbmRpdGlvbmFsLWFzc2lnbm1lbnRcbiAgd2hpbGUgKChwID0gbGlzdC5wb3AoKSkpIHtcbiAgICBpZiAocC5fZGlydHkpIHJlbmRlclNjcmlwdGFibGVTY2VuZShwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbHRlck5vbkZhbHN5KCQ6IGFueSk6ICQgaXMgdHJ1ZSB7XG4gIHJldHVybiAhISRcbn1cblxubGV0IGN1cnJlbnRGdW5jdGlvbk1hcDogTWFwPHN0cmluZywgRnVuY3Rpb24+XG5jb25zdCBhdHRyUmVndWxhckV4cHJlc3Npb24gPSAvXm9uW0EtWl0vXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBmaW5kcyByZWN1cnNpdmVseSBhbGwgdGhlIC9vbltBLVpdLi8gYXR0cmlidXRlcyB0aGF0IGFyZSBhbHNvIGFcbiAqIGZ1bmN0aW9uLCB0aGVuIGl0IHJlcGxhY2VzIHRoZSBmdW5jdGlvbiBieSBhIFVVSUQuIEl0IHN0b3JlcyB0aGUgcmVmZXJlbmNlIGluXG4gKiB0aGUgY3VycmVudEZ1bmN0aW9uTWFwXG4gKi9cbmZ1bmN0aW9uIGZpeENhbGxiYWNrcyhzY2VuZTogU2NyaXB0YWJsZVNjZW5lPGFueSwgYW55Pikge1xuICBjdXJyZW50RnVuY3Rpb25NYXAgPSBzY2VuZS5fZnVuY3Rpb25NYXBcblxuICBpZiAoIWN1cnJlbnRGdW5jdGlvbk1hcCkge1xuICAgIGN1cnJlbnRGdW5jdGlvbk1hcCA9IHNjZW5lLl9mdW5jdGlvbk1hcCA9IG5ldyBNYXAoKVxuICB9IGVsc2Uge1xuICAgIGN1cnJlbnRGdW5jdGlvbk1hcC5jbGVhcigpXG4gIH1cblxuICBpZiAoc2NlbmUuX2NvbXBvbmVudCkge1xuICAgIGZpeEF0dHJpYnV0ZXMoc2NlbmUuX2NvbXBvbmVudClcbiAgfVxufVxuXG5mdW5jdGlvbiBmaXhBdHRyaWJ1dGVzKG5vZGU6IElTaW1wbGlmaWVkTm9kZSkge1xuICBpZiAobm9kZS5hdHRycykge1xuICAgIGZvciAobGV0IGkgaW4gbm9kZS5hdHRycykge1xuICAgICAgaWYgKGF0dHJSZWd1bGFyRXhwcmVzc2lvbi50ZXN0KGkpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZS5hdHRyc1tpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNvbnN0IGZuOiBhbnkgPSBub2RlLmF0dHJzW2ldXG4gICAgICAgICAgY29uc3QgaWQgPSBwdXRIYW5kbGVyKGZuKVxuICAgICAgICAgIGN1cnJlbnRGdW5jdGlvbk1hcC5zZXQoaWQsIGZuKVxuICAgICAgICAgIG5vZGUuYXR0cnNbaV0gPSBpZFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZpeEF0dHJpYnV0ZXMobm9kZS5jaGlsZHJlbltpXSlcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlY3Vyc2l2ZVJlbmRlcih0cmVlOiBJU2ltcGxpZmllZE5vZGUpOiBJU2ltcGxpZmllZE5vZGUgfCBudWxsIHtcbiAgaWYgKHR5cGVvZiB0cmVlID09PSAnc3RyaW5nJykge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgY29uc29sZS5lcnJvcignV2FybmluZywgeW91IGFyZSB0cnlpbmcgdG8gcmVuZGVyIGEgdGV4dCcpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGlmICh0eXBlb2YgKHRyZWUudGFnIGFzIGFueSkgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCBob2MgPSAodHJlZS50YWcgYXMgYW55KSBhcyBGdW5jdGlvblxuICAgIGlmIChob2MucHJvdG90eXBlICYmIGhvYy5wcm90b3R5cGUucmVuZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgZnVuY3Rpb24gY29tcG9uZW50cyBhcmUgYWxsb3dlZCcpXG4gICAgfVxuICAgIHJldHVybiBob2MoeyAuLi50cmVlLmF0dHJzLCBjaGlsZHJlbjogdHJlZS5jaGlsZHJlbiB9KVxuICB9XG5cbiAgaWYgKCF0cmVlIHx8ICF0cmVlLnRhZykgcmV0dXJuIG51bGxcblxuICByZXR1cm4ge1xuICAgIHRhZzogdHJlZS50YWcsXG4gICAgYXR0cnM6IHRyZWUuYXR0cnMsXG4gICAgY2hpbGRyZW46ICh0cmVlLmNoaWxkcmVuLm1hcChyZWN1cnNpdmVSZW5kZXIpLmZpbHRlcihmaWx0ZXJOb25GYWxzeSkgYXMgYW55KSBhcyBJU2ltcGxpZmllZE5vZGVbXVxuICB9XG59XG5cbi8qKlxuICogUmVuZGVyIGEgU2NyaXB0YWJsZVNjZW5lLCB0cmlnZ2VyaW5nIG5lY2Vzc2FyeSBsaWZlY3ljbGUgZXZlbnRzIGFuZCB0YWtpbmcgSGlnaC1PcmRlciBTY3JpcHRhYmxlU2NlbmVzIGludG8gYWNjb3VudC5cbiAqIEBwYXJhbSB7U2NyaXB0YWJsZVNjZW5lfSBzY2VuZVxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJTY3JpcHRhYmxlU2NlbmU8UHJvcHMsIFN0YXRlPihzY2VuZTogU2NyaXB0YWJsZVNjZW5lPFByb3BzLCBTdGF0ZT4sIGZvcmNlPzogYm9vbGVhbikge1xuICBsZXQgcHJvcHMgPSBzY2VuZS5wcm9wc1xuICBsZXQgc3RhdGUgPSBzY2VuZS5zdGF0ZVxuICBsZXQgcHJldmlvdXNQcm9wcyA9IHNjZW5lLnByZXZQcm9wcyB8fCBwcm9wc1xuICBsZXQgcHJldmlvdXNTdGF0ZSA9IHNjZW5lLnByZXZTdGF0ZSB8fCBzdGF0ZVxuICBsZXQgc2tpcCA9IGZhbHNlXG4gIGNvbnN0IGlzVXBkYXRlID0gISFzY2VuZS5fY29tcG9uZW50XG5cbiAgLy8gaWYgdXBkYXRpbmdcbiAgaWYgKGlzVXBkYXRlKSB7XG4gICAgc2NlbmUucHJvcHMgPSBwcmV2aW91c1Byb3BzXG4gICAgc2NlbmUuc3RhdGUgPSBwcmV2aW91c1N0YXRlXG4gICAgaWYgKCFmb3JjZSAmJiBzY2VuZS5zaG91bGRTY2VuZVVwZGF0ZSAmJiBzY2VuZS5zaG91bGRTY2VuZVVwZGF0ZShwcm9wcywgc3RhdGUpID09PSBmYWxzZSkge1xuICAgICAgc2tpcCA9IHRydWVcbiAgICB9XG4gICAgc2NlbmUucHJvcHMgPSBwcm9wc1xuICAgIHNjZW5lLnN0YXRlID0gc3RhdGVcbiAgfVxuXG4gIHNjZW5lLnByZXZQcm9wcyA9IHNjZW5lLnByZXZTdGF0ZSA9IG51bGxcbiAgc2NlbmUuX2RpcnR5ID0gZmFsc2VcblxuICBpZiAoIXNraXApIHtcbiAgICBsZXQgcmVuZGVyZXJSZXN1bHQgPSBzY2VuZS5yZW5kZXIocHJvcHMsIHN0YXRlKVxuXG4gICAgaWYgKCEoJ3RoZW4nIGluIHJlbmRlcmVyUmVzdWx0ICYmICdjYXRjaCcgaW4gcmVuZGVyZXJSZXN1bHQpKSB7XG4gICAgICByZW5kZXJlclJlc3VsdCA9IFByb21pc2UucmVzb2x2ZShyZW5kZXJlclJlc3VsdClcbiAgICB9XG5cbiAgICByZW5kZXJlclJlc3VsdFxuICAgICAgLnRoZW4ocmVjdXJzaXZlUmVuZGVyKVxuICAgICAgLnRoZW4oYXN5bmMgcmVuZGVyZWQgPT4ge1xuICAgICAgICBpZiAoIXJlbmRlcmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgYXN5bmMgcmVuZGVyKCkgbWV0aG9kIHlpZWxkZWQgYW4gZW1wdHkgcmVzdWx0JylcbiAgICAgICAgfVxuXG4gICAgICAgIHNjZW5lLl9jb21wb25lbnQgPSByZW5kZXJlZFxuXG4gICAgICAgIC8vIHJlcGxhY2UgZnVuY3Rpb25zIGJ5IHV1aWRzXG4gICAgICAgIGZpeENhbGxiYWNrcyhzY2VuZSlcblxuICAgICAgICBpZiAoc2NlbmUuc2NlbmVEaWRVcGRhdGUpIHtcbiAgICAgICAgICBhd2FpdCBzY2VuZS5zY2VuZURpZFVwZGF0ZShwcmV2aW91c1Byb3BzLCBwcmV2aW91c1N0YXRlKVxuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgc2NlbmUuY29ubmVjdGlvbkZ1dHVyZVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVE9ETyhhZ3VzKTogZGlmZi9wYXRjaFxuICAgICAgICAgIGF3YWl0IHNjZW5lLmVudGl0eUNvbnRyb2xsZXIucmVuZGVyKHJlbmRlcmVkKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGUubWVzc2FnZSA9PT0gQ29uc3RhbnRzLlJlcGxhY2VXaG9sZVRyZWVFeGNlcHRpb24pIHtcbiAgICAgICAgICAgIGF3YWl0IHNjZW5lLmVudGl0eUNvbnRyb2xsZXIucmVuZGVyKHJlbmRlcmVkKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKVxuICAgICAgfSlcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNjcmlwdGFibGVTY2VuZTxQcm9wcywgU3RhdGU+IHtcbiAgcHJvcHM6IFByb3BzXG4gIHN0YXRlOiBTdGF0ZVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGNoYW5nZSBpbiBwcm9wcyBhbmQgc3RhdGUgc2hvdWxkIHRyaWdnZXIgYSByZS1yZW5kZXIuXG4gICAqXG4gICAqIElmIGZhbHNlIGlzIHJldHVybmVkLCBgU2NyaXB0YWJsZVNjZW5lI3JlbmRlcmAsIGFuZCBgc2NlbmVEaWRVcGRhdGVgIHdpbGwgbm90IGJlIGNhbGxlZC5cbiAgICovXG4gIHNob3VsZFNjZW5lVXBkYXRlPyhuZXh0UHJvcHM6IFByb3BzLCBuZXh0U3RhdGU6IFN0YXRlKTogUHJvbWlzZTxib29sZWFuPiB8IGJvb2xlYW5cblxuICAvKipcbiAgICogQ2FsbGVkIGltbWVkaWF0ZWx5IGJlZm9yZSBhIHNjZW5lIGlzIGRlc3Ryb3llZC4gUGVyZm9ybSBhbnkgbmVjZXNzYXJ5IGNsZWFudXAgaW4gdGhpcyBtZXRob2QsIHN1Y2ggYXNcbiAgICogY2FuY2VsbGVkIG5ldHdvcmsgcmVxdWVzdHMsIG9yIGNsZWFuaW5nIHVwIGFueSBlbGVtZW50cyBjcmVhdGVkIGluIGBzY2VuZURpZE1vdW50YC5cbiAgICovXG4gIHNjZW5lV2lsbFVubW91bnQ/KCk6IFByb21pc2U8dm9pZD4gfCB2b2lkXG5cbiAgLyoqXG4gICAqIENhbGxlZCBpbW1lZGlhdGVseSBhZnRlciBhIGNvbXBvbWVudCBpcyBtb3VudGVkLiBTZXR0aW5nIHN0YXRlIGhlcmUgd2lsbCB0cmlnZ2VyIHJlLXJlbmRlcmluZy5cbiAgICovXG4gIHNjZW5lRGlkTW91bnQ/KCk6IFByb21pc2U8dm9pZD4gfCB2b2lkXG5cbiAgLyoqXG4gICAqIENhbGxlZCBpbW1lZGlhdGVseSBhZnRlciB1cGRhdGluZyBvY2N1cnMuIE5vdCBjYWxsZWQgZm9yIHRoZSBpbml0aWFsIHJlbmRlci5cbiAgICovXG4gIHNjZW5lRGlkVXBkYXRlPyhwcmV2UHJvcHM6IFJlYWRvbmx5PFByb3BzPiwgcHJldlN0YXRlOiBSZWFkb25seTxTdGF0ZT4pOiBQcm9taXNlPHZvaWQ+IHwgdm9pZFxufVxuXG4vKipcbiAqIEJhc2UgU2NlbmUgY2xhc3MuXG4gKiBQcm92aWRlcyBgc2V0U3RhdGUoKWAgYW5kIGBmb3JjZVVwZGF0ZSgpYCwgd2hpY2ggdHJpZ2dlciByZW5kZXJpbmcuXG4gKiBAcHVibGljXG4gKlxuICogQGV4YW1wbGVcbiAqIGNsYXNzIE15Rm9vIGV4dGVuZHMgU2NyaXB0YWJsZVNjZW5lIHtcbiAqICAgYXN5bmMgcmVuZGVyKCkge1xuICogICAgIHJldHVybiA8c3BoZXJlIC8+O1xuICogICB9XG4gKiB9XG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTY3JpcHRhYmxlU2NlbmU8UHJvcHMgPSB7fSwgU3RhdGUgPSB7fT4gZXh0ZW5kcyBTY3JpcHQge1xuICAvLyBAaW50ZXJuYWxcbiAgQGluamVjdCgnRW50aXR5Q29udHJvbGxlcicpXG4gIGVudGl0eUNvbnRyb2xsZXIhOiBFbnRpdHlDb250cm9sbGVyXG5cbiAgZXZlbnRTdWJzY3JpYmVyITogRXZlbnRTdWJzY3JpYmVyXG5cbiAgLy8gQGludGVybmFsXG4gIF9kaXJ0eSA9IHRydWVcbiAgLy8gQGludGVybmFsXG4gIF9mdW5jdGlvbk1hcCA9IG5ldyBNYXA8c3RyaW5nLCBGdW5jdGlvbj4oKVxuICAvLyBAaW50ZXJuYWxcbiAgcHJldlByb3BzOiBQcm9wcyB8IG51bGwgPSBudWxsXG4gIC8vIEBpbnRlcm5hbFxuICBwcmV2U3RhdGU6IFN0YXRlIHwgbnVsbCA9IG51bGxcbiAgLy8gQGludGVybmFsXG4gIF9jb21wb25lbnQ6IElTaW1wbGlmaWVkTm9kZSB8IG51bGwgPSBudWxsXG5cbiAgc3RhdGU6IFN0YXRlID0ge30gYXMgU3RhdGVcblxuICAvLyBAaW50ZXJuYWxcbiAgY29ubmVjdGlvbkZ1dHVyZSA9IGZ1dHVyZTxTY3JpcHQ+KClcblxuICBwcm9wcyE6IFByb3BzXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBzY2VuZSBzdGF0ZSBieSBjb3B5aW5nIHByb3BlcnRpZXMgZnJvbSBgc3RhdGVgIHRvIGB0aGlzLnN0YXRlYC5cbiAgICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIEEgaGFzaCBvZiBzdGF0ZSBwcm9wZXJ0aWVzIHRvIHVwZGF0ZSB3aXRoIG5ldyB2YWx1ZXNcbiAgICovXG4gIHNldFN0YXRlKHN0YXRlOiBQYXJ0aWFsPFN0YXRlPiB8ICgoc3RhdGU6IFN0YXRlLCBwcm9wczogUHJvcHMpID0+IFBhcnRpYWw8U3RhdGU+KSk6IHZvaWQge1xuICAgIGxldCBzID0gdGhpcy5zdGF0ZVxuICAgIGlmICghdGhpcy5wcmV2U3RhdGUpIHRoaXMucHJldlN0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgcylcbiAgICBPYmplY3QuYXNzaWduKHMsIHR5cGVvZiBzdGF0ZSA9PT0gJ2Z1bmN0aW9uJyA/IHN0YXRlKHMsIHRoaXMucHJvcHMpIDogc3RhdGUpXG4gICAgZW5xdWV1ZVJlbmRlcih0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIEltbWVkaWF0ZWx5IHBlcmZvcm0gYSBzeW5jaHJvbm91cyByZS1yZW5kZXIgb2YgdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIGZvcmNlVXBkYXRlKCkge1xuICAgIHJlbmRlclNjcmlwdGFibGVTY2VuZSh0aGlzLCB0cnVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdHMgYHByb3BzYCBhbmQgYHN0YXRlYCwgYW5kIHJldHVybnMgYSBuZXcgVmlydHVhbCBET00gdHJlZSB0byBidWlsZC5cbiAgICogVmlydHVhbCBET00gaXMgZ2VuZXJhbGx5IGNvbnN0cnVjdGVkIHZpYSBbSlNYXShodHRwOi8vamFzb25mb3JtYXQuY29tL3d0Zi1pcy1qc3gpLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgICAgUHJvcHMgKGVnOiBKU1ggYXR0cmlidXRlcykgcmVjZWl2ZWQgZnJvbSBwYXJlbnQgZWxlbWVudC9jb21wb25lbnRcbiAgICogQHBhcmFtIHtvYmplY3R9IHN0YXRlICAgIFRoZSBjb21wb25lbnQncyBjdXJyZW50IHN0YXRlXG4gICAqL1xuICBhYnN0cmFjdCBhc3luYyByZW5kZXIocHJvcHM6IFByb3BzLCBzdGF0ZTogU3RhdGUpOiBQcm9taXNlPElTaW1wbGlmaWVkTm9kZT5cblxuICAvKipcbiAgICogSXQgbWFrZXMgYSBzdWJzY3JpcHRpb24gdG8gcmVtb3RlIGV2ZW50cywgdGhvc2UgZXZlbnRzIG9jY3VyIGluIHRoZSBjb250ZXh0IG9mIHRoZSBnYW1lIGFuZCBhcmUgc2VudCB0aHJ1IHRoZSB3aXJlXG4gICAqIHByb3RvY29sLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgbmFtZSBvZiB0aGUgcmVtb3RlIGV2ZW50IHRvIGxpc3RlblxuICAgKiBAcGFyYW0gaGFuZGxlciBhbiBhc3luY1xuICAgKi9cbiAgc3Vic2NyaWJlVG88VCBleHRlbmRzIElFdmVudE5hbWVzPihldmVudDogVCwgaGFuZGxlcjogKGRhdGE6IElFdmVudHNbVF0pID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+KSB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgdGhpcy5jb25uZWN0aW9uRnV0dXJlLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5ldmVudFN1YnNjcmliZXIub24oZXZlbnQsIHggPT4ge1xuICAgICAgICBjb25zdCByZXQgPSBoYW5kbGVyKHguZGF0YSlcbiAgICAgICAgaWYgKHJldCAmJiAnY2F0Y2gnIGluIHJldCAmJiB0eXBlb2YgcmV0LmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0LmNhdGNoKGVyciA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHN0YW5kYXJkIGV0aGVyZXVtIHByb3ZpZGVyXG4gICAqIFBsZWFzZSBub3RpY2UgdGhpcyBpcyBoaWdobHkgZXhwZXJpbWVudGFsIGFuZCBtaWdodCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cbiAgICpcbiAgICogbWV0aG9kIHdoaXRlbGlzdCA9IFtcbiAgICogICAnZXRoX3NlbmRUcmFuc2FjdGlvbicsXG4gICAqICAgJ2V0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHQnLFxuICAgKiAgICdldGhfZXN0aW1hdGVHYXMnLFxuICAgKiAgICdldGhfY2FsbCcsXG4gICAqICAgJ2V0aF9nZXRCYWxhbmNlJyxcbiAgICogICAnZXRoX2dldFN0b3JhZ2VBdCcsXG4gICAqICAgJ2V0aF9ibG9ja051bWJlcicsXG4gICAqICAgJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJyxcbiAgICogICAnZXRoX2dhc1ByaWNlJyxcbiAgICogICAnZXRoX3Byb3RvY29sVmVyc2lvbicsXG4gICAqICAgJ25ldF92ZXJzaW9uJyxcbiAgICogICAnd2ViM19zaGEzJyxcbiAgICogICAnd2ViM19jbGllbnRWZXJzaW9uJyxcbiAgICogICAnZXRoX2dldFRyYW5zYWN0aW9uQ291bnQnXG4gICAqIF1cbiAgICovXG4gIGFzeW5jIGdldEV0aGVyZXVtUHJvdmlkZXIoKSB7XG4gICAgY29uc3QgeyBFdGhlcmV1bUNvbnRyb2xsZXIgfSA9IGF3YWl0IHRoaXMubG9hZEFQSXMoWydFdGhlcmV1bUNvbnRyb2xsZXInXSlcblxuICAgIHJldHVybiB7XG4gICAgICAvLyBAaW50ZXJuYWxcbiAgICAgIHNlbmQobWVzc2FnZTogUlBDU2VuZGFibGVNZXNzYWdlLCBjYWxsYmFjaz86IChlcnJvcjogRXJyb3IgfCBudWxsLCByZXN1bHQ/OiBhbnkpID0+IHZvaWQpOiB2b2lkIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UgJiYgY2FsbGJhY2sgJiYgY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgIEV0aGVyZXVtQ29udHJvbGxlci5zZW5kQXN5bmMobWVzc2FnZSlcbiAgICAgICAgICAgIC50aGVuKCh4OiBhbnkpID0+IGNhbGxiYWNrKG51bGwsIHgpKVxuICAgICAgICAgICAgLmNhdGNoKGNhbGxiYWNrKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjZW50cmFsYW5kIHByb3ZpZGVyIG9ubHkgYWxsb3dzIGFzeW5jIGNhbGxzJylcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNlbmRBc3luYyhtZXNzYWdlOiBSUENTZW5kYWJsZU1lc3NhZ2UsIGNhbGxiYWNrOiAoZXJyb3I6IEVycm9yIHwgbnVsbCwgcmVzdWx0PzogYW55KSA9PiB2b2lkKTogdm9pZCB7XG4gICAgICAgIEV0aGVyZXVtQ29udHJvbGxlci5zZW5kQXN5bmMobWVzc2FnZSlcbiAgICAgICAgICAudGhlbigoeDogYW55KSA9PiBjYWxsYmFjayhudWxsLCB4KSlcbiAgICAgICAgICAuY2F0Y2goY2FsbGJhY2spXG4gICAgICB9XG4gICAgfSBhcyB7XG4gICAgICBzZW5kOiBGdW5jdGlvblxuICAgICAgc2VuZEFzeW5jOiBGdW5jdGlvblxuICAgIH1cbiAgfVxuXG4gIC8vIEBpbnRlcm5hbFxuICByZWNlaXZlQ2xpY2tFdmVudCA9IChldmVudDogYW55KSA9PiB7XG4gICAgY29uc3QgbWFwOiBNYXA8c3RyaW5nLCBGdW5jdGlvbj4gPSB0aGlzLl9mdW5jdGlvbk1hcFxuICAgIGlmIChtYXApIHtcbiAgICAgIGNvbnN0IGZuID0gbWFwLmdldChldmVudC5kYXRhLnV1aWQpXG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgZm4oZXZlbnQuZGF0YS5wYXlsb2FkKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEBpbnRlcm5hbFxuICBhc3luYyBzeXN0ZW1EaWRFbmFibGUoKSB7XG4gICAgdGhpcy5wcm9wcyA9IChhd2FpdCB0aGlzLmVudGl0eUNvbnRyb2xsZXIuZ2V0T3duQXR0cmlidXRlcygpKSBhcyBQcm9wc1xuXG4gICAgLy8gd2UgY3JlYXRlIGFuIGV2ZW50IHN1YnNjcmliZXJcbiAgICB0aGlzLmV2ZW50U3Vic2NyaWJlciA9IG5ldyBFdmVudFN1YnNjcmliZXIodGhpcy5lbnRpdHlDb250cm9sbGVyKVxuXG4gICAgdGhpcy5vbignU0lHS0lMTCcsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnNjZW5lV2lsbFVubW91bnQpIHtcbiAgICAgICAgdGhpcy5zY2VuZVdpbGxVbm1vdW50KClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5zdWJzY3JpYmVUbygnc2V0QXR0cmlidXRlcycsIG5ld1Byb3BzID0+IHtcbiAgICAgIHRoaXMucHJldlByb3BzID0gdGhpcy5wcm9wc1xuICAgICAgdGhpcy5wcm9wcyA9IG5ld1Byb3BzIGFzIFByb3BzXG4gICAgICBlbnF1ZXVlUmVuZGVyKHRoaXMpXG4gICAgfSlcblxuICAgIHRoaXMuY29ubmVjdGlvbkZ1dHVyZS5yZXNvbHZlKHRoaXMpXG5cbiAgICByZW5kZXJTY3JpcHRhYmxlU2NlbmUodGhpcywgdHJ1ZSlcblxuICAgIHRoaXMuZXZlbnRTdWJzY3JpYmVyLm9uKCd1dWlkRXZlbnQnLCB0aGlzLnJlY2VpdmVDbGlja0V2ZW50KVxuXG4gICAgaWYgKHRoaXMuc2NlbmVEaWRNb3VudCkge1xuICAgICAgYXdhaXQgdGhpcy5zY2VuZURpZE1vdW50KClcbiAgICB9XG4gIH1cbn1cbiJdfQ==