"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("./common");
const future_1 = require("../utils/future");
class WebSocketProvider {
    constructor(url, options = {}) {
        this.url = url;
        this.options = options;
        this.isDisposed = false;
        this.responseCallbacks = new Map();
        this.notificationCallbacks = new Set();
        this.debug = false;
        this.lastChunk = '';
        this.connect();
    }
    dispose() {
        this.isDisposed = true;
        // tslint:disable-next-line:no-floating-promises
        this.connection.then($ => $.close());
    }
    /* istanbul ignore next */
    // tslint:disable-next-line:prefer-function-over-method
    send() {
        /* istanbul ignore next */
        throw new Error('Sync requests are deprecated');
    }
    sendAsync(payload, callback) {
        const toSend = [];
        let didFinish;
        if (payload instanceof Array) {
            didFinish = Promise.all(payload.map($ => {
                const defer = future_1.future();
                try {
                    const message = common_1.toRPC($);
                    toSend.push(message);
                    this.responseCallbacks.set(message.id, defer);
                }
                catch (e) {
                    defer.reject(e);
                }
                return defer;
            }));
        }
        else {
            const defer = future_1.future();
            try {
                const message = common_1.toRPC(payload);
                toSend.push(message);
                this.responseCallbacks.set(message.id, defer);
            }
            catch (e) {
                defer.reject(e);
            }
            didFinish = defer;
        }
        didFinish.then($ => callback(null, $), err => callback(err));
        this.connection.then(ws => {
            toSend.forEach($ => {
                const s = JSON.stringify($);
                /* istanbul ignore if */
                // tslint:disable-next-line:no-console
                if (this.debug)
                    console.log('SEND >> ' + s);
                ws.send(s);
            });
        }, err => {
            callback(err);
        });
    }
    /**
     * Will parse the response and make an array out of it.
     * @method _parseResponse
     * @param {String} data
     */
    parseResponse(data) {
        let returnValues = [];
        // DE-CHUNKER
        let dechunkedData = data
            .replace(/\}[\n\r]?\{/g, '}|--|{') // }{
            .replace(/\}\][\n\r]?\[\{/g, '}]|--|[{') // }][{
            .replace(/\}[\n\r]?\[\{/g, '}|--|[{') // }[{
            .replace(/\}\][\n\r]?\{/g, '}]|--|{') // }]{
            .split('|--|');
        dechunkedData.forEach(chunk => {
            let data = chunk;
            // prepend the last chunk
            if (this.lastChunk) {
                data = this.lastChunk + data;
            }
            let result = null;
            try {
                result = JSON.parse(data);
            }
            catch (e) {
                this.lastChunk = data;
                // start timeout to cancel all requests
                clearTimeout(this.lastChunkTimeout);
                this.lastChunkTimeout = setTimeout(() => {
                    this.timeout();
                }, 1000 * 15);
                return;
            }
            // cancel timeout and set chunk to null
            clearTimeout(this.lastChunkTimeout);
            this.lastChunk = null;
            if (result)
                returnValues.push(result);
        });
        return returnValues;
    }
    processMessage(message) {
        if ('id' in message) {
            const id = message.id;
            const defer = this.responseCallbacks.get(id);
            if (!defer) {
                // tslint:disable-next-line:no-console
                console.error('Error: Received a response for an unknown request', message);
                return;
            }
            this.responseCallbacks.delete(id);
            if ('error' in message) {
                defer.reject(Object.assign(new Error(message.error.message || message.error), message.error));
            }
            else if ('result' in message) {
                defer.resolve(message);
            }
        }
        else {
            this.notificationCallbacks.forEach($ => $(null, message));
        }
    }
    /**
     * Timeout all requests when the end/error event is fired
     * @method _timeout
     */
    timeout() {
        if (!this.connection || !this.connection.isPending) {
            this.connection = future_1.future();
        }
        const timeoutError = new Error('Connection timeout');
        this.responseCallbacks.forEach($ => $.reject(timeoutError));
        this.responseCallbacks.clear();
        // reset all requests and callbacks
        if (!this.isDisposed) {
            this.connect();
        }
    }
    connect() {
        if (this.connection && !this.connection.isPending) {
            // tslint:disable-next-line
            this.connection.then($ => $.close());
        }
        if (!this.connection || !this.connection.isPending) {
            this.connection = future_1.future();
        }
        this.lastChunk = '';
        let ctor = this.options.WebSocketConstructor || (typeof WebSocket !== 'undefined' ? WebSocket : void 0);
        if (!ctor) {
            throw new Error('Please provide a WebSocketConstructor');
        }
        const connection = new ctor(this.url, this.options.protocol);
        connection.onopen = () => {
            this.connection.resolve(connection);
        };
        connection.onerror = () => {
            this.timeout();
        };
        connection.onclose = () => {
            this.timeout();
        };
        // LISTEN FOR CONNECTION RESPONSES
        connection.onmessage = e => {
            let data = typeof e.data === 'string' ? e.data : '';
            /* istanbul ignore if */
            // tslint:disable-next-line:no-console
            if (this.debug)
                console.log('RECV << ' + e.data);
            this.parseResponse(data).forEach(result => {
                // get the id which matches the returned id
                if (result instanceof Array) {
                    result.forEach($ => this.processMessage($));
                }
                else {
                    this.processMessage(result);
                }
            });
        };
    }
}
exports.WebSocketProvider = WebSocketProvider;
exports.default = WebSocketProvider;
//# sourceMappingURL=WebSocketProvider.js.map