"use strict";
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file syncing.js
 * @authors:
 *   Fabian Vogelsteller <fabian@ethdev.com>
 * @date 2015
 */
Object.defineProperty(exports, "__esModule", { value: true });
const formatters = require("./utils/formatters");
const utils = require("./utils/utils");
const RequestManager_1 = require("./RequestManager");
let count = 1;
class IsSyncing extends RequestManager_1.Poller {
    constructor(requestManager) {
        super(requestManager);
        this.pollId = 'syncPoll_' + count++;
        this.callbacks = [];
        this.lastSyncState = false;
        this.pollSyncing();
    }
    addCallback(callback) {
        if (callback) {
            this.callbacks.push(callback);
        }
    }
    async stopWatching() {
        this.stopPolling(this.pollId);
        this.callbacks = [];
    }
    /**
     * Adds the callback and sets up the methods, to iterate over the results.
     *
     * @method pollSyncing
     */
    pollSyncing() {
        let onMessage = (error, _sync) => {
            if (error) {
                return this.callbacks.forEach(function (callback) {
                    callback(error, void 0);
                });
            }
            let sync = _sync;
            if (utils.isObject(sync) && sync.startingBlock) {
                sync = formatters.outputSyncingFormatter(sync);
            }
            this.callbacks.forEach(callback => {
                if (this.lastSyncState !== sync) {
                    // call the callback with true first so the app can stop anything, before receiving the sync data
                    if (!this.lastSyncState && utils.isObject(sync))
                        callback(null, true);
                    // call on the next CPU cycle, so the actions of the sync stop can be processes first
                    setTimeout(function () {
                        callback(null, sync);
                    }, 0);
                    this.lastSyncState = sync;
                }
            });
        };
        this.startPolling({
            method: 'eth_syncing',
            params: []
        }, this.pollId, onMessage, this.stopWatching.bind(this));
    }
}
exports.IsSyncing = IsSyncing;
//# sourceMappingURL=IsSyncing.js.map