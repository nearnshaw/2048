"use strict";
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable:variable-name
const jsonRpc = require("./utils/jsonrpc");
const errors = require("./utils/errors");
const future_1 = require("./utils/future");
const eth_1 = require("./methods/eth");
const sleep_1 = require("./utils/sleep");
exports.TRANSACTION_FETCH_DELAY = 2 * 1000;
exports.TRANSACTION_STATUS = Object.freeze({
    pending: 'pending',
    confirmed: 'confirmed',
    failed: 'failed'
});
function inject(target, propertyKey) {
    const method = eth_1.eth[propertyKey];
    /* istanbul ignore if */
    if (!method) {
        throw new Error(`Could not find the method/property named ${propertyKey}`);
    }
    Object.defineProperty(target, propertyKey, {
        value: function () {
            return method.execute.call(method, this, ...arguments);
        }
    });
}
exports.inject = inject;
/**
 * It's responsible for passing messages to providers
 * It's also responsible for polling the ethereum node for incoming messages
 * Default poll timeout is 1 second
 */
class RequestManager {
    constructor(provider) {
        this.provider = provider;
        this.requests = new Map();
        // stub
    }
    /**
     * Should be used to asynchronously send request
     *
     * @method sendAsync
     * @param {object} data
     * @param {Function} callback
     */
    async sendAsync(data) {
        /* istanbul ignore if */
        if (!this.provider) {
            throw errors.InvalidProvider();
        }
        let payload = jsonRpc.toPayload(data.method, data.params);
        const defer = future_1.future();
        defer.finally(() => this.requests.delete(payload.id));
        this.requests.set(payload.id, defer);
        this.provider.sendAsync(payload, function (err, result) {
            if (err) {
                defer.reject(err);
                return;
            }
            /* istanbul ignore if */
            if (!jsonRpc.isValidResponse(result)) {
                defer.reject(errors.InvalidResponse(result));
                return;
            }
            defer.resolve(result.result);
        });
        return defer;
    }
    /**
     * Should be used to set provider of request manager
     *
     * @method setProvider
     * @param {object}
     */
    /* istanbul ignore next */
    setProvider(p) {
        this.provider = p;
    }
    /**
     * Waits until the transaction finishes. Returns if it was successfull.
     * Throws if the transaction fails or if it lacks any of the supplied events
     * @param  {string} txId - Transaction id to watch
     * @param  {Array<string>|string} events - Events to watch. See {@link txUtils#getLogEvents}
     * @return {object} data - Current transaction data. See {@link txUtils#getTransaction}
     */
    async getConfirmedTransaction(txId) {
        const tx = await this.waitForCompletion(txId);
        if (this.isFailure(tx)) {
            throw new Error(`Transaction "${txId}" failed`);
        }
        return tx;
    }
    /**
     * Wait until a transaction finishes by either being mined or failing
     * @param  {string} txId - Transaction id to watch
     * @param  {number} [retriesOnEmpty] - Number of retries when a transaction status returns empty
     * @return {Promise<object>} data - Current transaction data. See {@link txUtils#getTransaction}
     */
    async waitForCompletion(txId, retriesOnEmpty) {
        const isDropped = await this.isTxDropped(txId, retriesOnEmpty);
        if (isDropped) {
            const tx = await this.getTransactionAndReceipt(txId);
            return Object.assign({}, tx, { status: exports.TRANSACTION_STATUS.failed });
        }
        while (true) {
            const tx = await this.getTransactionAndReceipt(txId);
            if (!this.isPending(tx) && tx.receipt) {
                return Object.assign({}, tx, { status: this.isFailure(tx) ? exports.TRANSACTION_STATUS.failed : exports.TRANSACTION_STATUS.confirmed });
            }
            await sleep_1.sleep(exports.TRANSACTION_FETCH_DELAY);
        }
    }
    /*
     * Wait retryAttemps*TRANSACTION_FETCH_DELAY for a transaction status to be in the mempool
     * @param  {string} txId - Transaction id to watch
     * @param  {number} [retryAttemps=15] - Number of retries when a transaction status returns empty
     * @return {Promise<boolean>}
     */
    async isTxDropped(txId, _retryAttemps = 15) {
        let retryAttemps = _retryAttemps;
        while (retryAttemps > 0) {
            const tx = await this.getTransactionAndReceipt(txId);
            if (tx !== null) {
                return false;
            }
            retryAttemps -= 1;
            await sleep_1.sleep(exports.TRANSACTION_FETCH_DELAY);
        }
        return true;
    }
    /**
     * Get the transaction status and receipt
     * @param  {string} txId - Transaction id
     */
    // prettier-ignore
    async getTransactionAndReceipt(txId) {
        const [tx, receipt] = await Promise.all([
            this.eth_getTransactionByHash(txId),
            this.eth_getTransactionReceipt(txId)
        ]);
        return tx ? Object.assign({}, tx, { receipt }) : null;
    }
    /**
     * Expects the result of getTransaction's geth command and returns true if the transaction is still pending.
     * It'll also check for a pending status prop against {@link txUtils#TRANSACTION_STATUS}
     * @param {object} tx - The transaction object
     * @return boolean
     */
    // tslint:disable-next-line:prefer-function-over-method
    isPending(tx) {
        return tx && tx.blockNumber === null;
    }
    /**
     * Expects the result of getTransactionRecepeit's geth command and returns true if the transaction failed.
     * It'll also check for a failed status prop against {@link txUtils#TRANSACTION_STATUS}
     * @param {object} tx - The transaction object
     * @return boolean
     */
    // tslint:disable-next-line:prefer-function-over-method
    isFailure(tx) {
        return tx && (!tx.receipt || tx.receipt.status === 0);
    }
}
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "web3_clientVersion", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "web3_sha3", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "net_version", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "net_peerCount", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "net_listening", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_protocolVersion", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_syncing", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_coinbase", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_mining", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_hashrate", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_gasPrice", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_accounts", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_blockNumber", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getBalance", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getStorageAt", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getTransactionCount", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getBlockTransactionCountByHash", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getBlockTransactionCountByNumber", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getUncleCountByBlockHash", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getUncleCountByBlockNumber", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getCode", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_sign", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_sendTransaction", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_sendRawTransaction", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_call", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_estimateGas", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getBlockByHash", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getBlockByNumber", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getTransactionByHash", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getTransactionByBlockHashAndIndex", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getTransactionByBlockNumberAndIndex", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getTransactionReceipt", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getUncleByBlockHashAndIndex", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getUncleByBlockNumberAndIndex", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getCompilers", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_compileLLL", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_compileSolidity", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_compileSerpent", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_newFilter", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_newBlockFilter", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_newPendingTransactionFilter", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_uninstallFilter", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getFilterChanges", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getFilterLogs", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getLogs", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getWork", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_submitWork", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_submitHashrate", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "shh_post", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "shh_version", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "shh_newIdentity", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "shh_hasIdentity", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "shh_newGroup", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "shh_addToGroup", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "shh_newFilter", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "shh_uninstallFilter", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "shh_getFilterChanges", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "shh_getMessages", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "personal_unlockAccount", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "personal_newAccount", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "personal_listAccounts", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "personal_lockAccount", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "personal_importRawKey", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "personal_sendTransaction", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "personal_sign", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "personal_ecRecover", void 0);
exports.RequestManager = RequestManager;
//# sourceMappingURL=RequestManager.js.map