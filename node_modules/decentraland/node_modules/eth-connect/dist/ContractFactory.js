"use strict";
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file contract.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2014
 */
Object.defineProperty(exports, "__esModule", { value: true });
const utils = require("./utils/utils");
const coder_1 = require("./solidity/coder");
const Contract_1 = require("./Contract");
const future_1 = require("./utils/future");
/**
 * Should be called to check if the contract gets properly deployed on the blockchain.
 *
 * @method checkForContractAddress
 * @param {object} contract
 * @param {Function} callback
 * @returns {Undefined}
 */
async function checkForContractAddress(requestManager, txId) {
    const receiptFuture = future_1.future();
    let count = 0;
    const fetcher = () => {
        count++;
        // stop watching after 50 blocks (timeout)
        if (count > 50) {
            receiptFuture.reject(new Error("Contract transaction couldn't be found after 50 blocks"));
        }
        else {
            requestManager.eth_getTransactionReceipt(txId).then(receipt => {
                if (receipt && receipt.blockHash) {
                    receiptFuture.resolve(receipt);
                }
                else {
                    setTimeout(fetcher, 1000);
                }
            }, 
            /* istanbul ignore next */
            error => receiptFuture.reject(error));
        }
    };
    fetcher();
    const receipt = await receiptFuture;
    const code = await requestManager.eth_getCode(receipt.contractAddress, 'latest');
    if (code.length > 3) {
        return receipt.contractAddress;
    }
    /* istanbul ignore next */
    throw Object.assign(new Error("The contract code couldn't be stored, please check your gas amount."), {
        response: code,
        receipt
    });
}
/**
 * Should be called to encode constructor params
 *
 * @method encodeConstructorParams
 * @param {Array} abi
 * @param {Array} constructor params
 */
function encodeConstructorParams(abi, params) {
    return (abi
        .filter(function (json) {
        return json.type === 'constructor' && json.inputs.length === params.length;
    })
        .map(function (json) {
        return json.inputs.map(function (input) {
            return input.type;
        });
    })
        .map(function (types) {
        return coder_1.coder.encodeParams(types, params);
    })[0] || '');
}
/**
 * Should be called to create new ContractFactory instance
 *
 * @method ContractFactory
 * @param {Array} abi
 */
class ContractFactory {
    constructor(requestManager, abi) {
        this.requestManager = requestManager;
        this.abi = abi;
    }
    async deploy(...args) {
        // parse arguments
        let options;
        let last = args[args.length - 1];
        if (utils.isObject(last) && !utils.isArray(last)) {
            options = args.pop();
        }
        /* istanbul ignore if */
        if (!options) {
            throw new Error('Missing options object');
        }
        /* istanbul ignore if */
        if (!options.data || typeof options.data !== 'string') {
            throw new Error('Invalid options.data');
        }
        if (options.value > 0) {
            let constructorAbi = this.abi.filter(function (json) {
                return json.type === 'constructor' && json.inputs.length === args.length;
            })[0] || {};
            /* istanbul ignore if */
            if (!constructorAbi.payable) {
                throw new Error('Cannot send value to non-payable constructor');
            }
        }
        let bytes = encodeConstructorParams(this.abi, args);
        options.data += bytes;
        if (!options.gas) {
            options.gas = await this.requestManager.eth_estimateGas(options);
        }
        // wait for the contract address and check if the code was deployed
        const hash = await this.requestManager.eth_sendTransaction(options);
        const address = await checkForContractAddress(this.requestManager, hash);
        const contract = await this.at(address);
        contract.transactionHash = hash;
        return contract;
    }
    /**
     * Should be called to get access to existing contract on a blockchain
     *
     * @method at
     * @param {Address} contract address (required)
     * @param {Function} callback {optional)
     * @returns {Contract} returns contract if no callback was passed,
     * otherwise calls callback function (err, contract)
     */
    async at(address) {
        if (!utils.isAddress(address)) {
            throw new TypeError(`Invalid address ${JSON.stringify(address)}`);
        }
        let contract = new Contract_1.Contract(this.requestManager, this.abi, address);
        return contract;
    }
    /**
     * Gets the data, which is data to deploy plus constructor params
     *
     * @method getData
     */
    async getData(...args) {
        let options = { data: undefined };
        const last = args[args.length - 1];
        if (utils.isObject(last) && !utils.isArray(last)) {
            options = args.pop();
        }
        if (!options) {
            throw new Error('Missing options object');
        }
        if (!options.data || typeof options.data !== 'string') {
            throw new Error('Invalid options.data');
        }
        const bytes = encodeConstructorParams(this.abi, args);
        options.data += bytes;
        return options.data;
    }
}
exports.ContractFactory = ContractFactory;
//# sourceMappingURL=ContractFactory.js.map