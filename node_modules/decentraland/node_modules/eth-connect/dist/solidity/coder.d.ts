import { SolidityType } from './type';
/**
 * SolidityCoder prototype should be used to encode/decode solidity params of any type
 */
export declare class SolidityCoder {
    _types: SolidityType[];
    constructor(types: SolidityType[]);
    /**
     * This method should be used to transform type to SolidityType
     *
     * @method _requireType
     * @param {string} type
     * @returns {SolidityType}
     * @throws {Error} throws if no matching type is found
     */
    _requireType(type: string): SolidityType;
    /**
     * Should be used to encode plain param
     *
     * @method encodeParam
     * @param {string} type
     * @param {object} plain param
     * @return {string} encoded plain param
     */
    encodeParam(type: string, param: any): string;
    /**
     * Should be used to encode list of params
     *
     * @method encodeParams
     * @param {Array} types
     * @param {Array} params
     * @return {string} encoded list of params
     */
    encodeParams(types: string[], params: any[]): string;
    encodeMultiWithOffset(types: string[], solidityTypes: SolidityType[], encodeds: any, _dynamicOffset: number): string;
    encodeWithOffset(type: string, solidityType: SolidityType, encoded: any, offset: number): any;
    /**
     * Should be used to decode bytes to plain param
     *
     * @method decodeParam
     * @param {string} type
     * @param {string} bytes
     * @return {object} plain param
     */
    decodeParam(type: string, bytes: string): any;
    /**
     * Should be used to decode list of params
     *
     * @method decodeParam
     * @param {Array} types
     * @param {string} bytes
     * @return {Array} array of plain params
     */
    decodeParams(types: string[], bytes: string): any[];
    getOffsets(types: string[], solidityTypes: SolidityType[]): number[];
    getSolidityTypes(types: string[]): SolidityType[];
}
export declare const coder: SolidityCoder;
