/**
 * SolidityType prototype is used to encode/decode solidity params of certain type
 */
export declare class SolidityType {
    _inputFormatter: any;
    _outputFormatter: any;
    constructor(config: {
        inputFormatter;
        outputFormatter;
    });
    /**
     * Should be used to determine if this SolidityType do match given name
     *
     * @method isType
     * @param {string} name
     * @return {Bool} true if type match this SolidityType, otherwise false
     */
    isType(name: string): void;
    /**
     * Should be used to determine what is the length of static part in given type
     *
     * @method staticPartLength
     * @param {string} name
     * @return {number} length of static part in bytes
     */
    staticPartLength(name: string): number;
    /**
     * Should be used to determine if type is dynamic array
     * eg:
     * "type[]" => true
     * "type[4]" => false
     *
     * @method isDynamicArray
     * @param {string} name
     * @return {bool} true if the type is dynamic array
     */
    isDynamicArray(name: string): boolean;
    /**
     * Should be used to determine if type is static array
     * eg:
     * "type[]" => false
     * "type[4]" => true
     *
     * @method isStaticArray
     * @param {string} name
     * @return {Bool} true if the type is static array
     */
    isStaticArray(name: string): boolean;
    /**
     * Should return length of static array
     * eg.
     * "int[32]" => 32
     * "int256[14]" => 14
     * "int[2][3]" => 3
     * "int" => 1
     * "int[1]" => 1
     * "int[]" => 1
     *
     * @method staticArrayLength
     * @param {string} name
     * @return {number} static array length
     */
    staticArrayLength(name: string): number;
    /**
     * Should return nested type
     * eg.
     * "int[32]" => "int"
     * "int256[14]" => "int256"
     * "int[2][3]" => "int[2]"
     * "int" => "int"
     * "int[]" => "int"
     *
     * @method nestedName
     * @param {string} name
     * @return {string} nested name
     */
    nestedName(name: string): string;
    /**
     * Should return true if type has dynamic size by default
     * such types are "string", "bytes"
     *
     * @method isDynamicType
     * @param {string} name
     * @return {Bool} true if is dynamic, otherwise false
     */
    isDynamicType(_?: string): boolean;
    /**
     * Should return array of nested types
     * eg.
     * "int[2][3][]" => ["[2]", "[3]", "[]"]
     * "int[] => ["[]"]
     * "int" => null
     *
     * @method nestedTypes
     * @param {string} name
     * @return {Array} array of nested types
     */
    nestedTypes(name: string): string[];
    /**
     * Should be used to encode the value
     *
     * @method encode
     * @param {object} value
     * @param {string} name
     * @return {string} encoded value
     */
    encode(value: any, name: string): any;
    /**
     * Should be used to decode value from bytes
     *
     * @method decode
     * @param {string} bytes
     * @param {number} offset in bytes
     * @param {string} name type name
     * @returns {object} decoded value
     */
    decode(bytes: string, offset: number, name: string): any;
}
