"use strict";
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
Object.defineProperty(exports, "__esModule", { value: true });
const formatters = require("./utils/formatters");
const utils = require("./utils/utils");
const config = require("./utils/config");
const future_1 = require("./utils/future");
function safeAsync(fn) {
    return function () {
        // tslint:disable-next-line:no-console
        fn().catch($ => console.error($));
    };
}
/**
 * Converts a given topic to a hex string, but also allows null values.
 *
 * @param {Mixed} value
 * @return {string}
 */
function toTopic(value) {
    if (value === null || typeof value === 'undefined')
        return null;
    const strValue = String(value).toString();
    if (strValue.indexOf('0x') === 0)
        return strValue;
    else
        return utils.fromUtf8(strValue);
}
class AbstractFilter {
    constructor(requestManager) {
        this.requestManager = requestManager;
        this.isStarted = false;
        this.isDisposed = false;
        this.filterId = future_1.future();
        this.callbacks = [];
        this.stopSemaphore = future_1.future();
        // stub
    }
    async watch(callback) {
        if (this.isDisposed)
            throw new Error('The filter was disposed');
        if (callback) {
            this.callbacks.push(callback);
            if (!this.isStarted) {
                await this.start();
            }
        }
    }
    async start() {
        if (this.isDisposed)
            throw new Error('The filter was disposed');
        if (this.isStarted)
            return;
        this.isStarted = true;
        try {
            const id = await this.getNewFilter();
            if (!id) {
                throw new Error('Could not create a filter, response: ' + JSON.stringify(id));
            }
            this.filterId.resolve(id);
        }
        catch (e) {
            throw e;
        }
        this.stopSemaphore = future_1.future();
        await this.poll();
    }
    async stop() {
        if (!this.isStarted)
            return;
        if (this.isDisposed)
            return;
        this.isDisposed = true;
        const filterId = await this.filterId;
        this.isStarted = false;
        if (this.stopSemaphore)
            await this.stopSemaphore;
        const didStop = await this.uninstall();
        if (didStop !== true) {
            throw new Error(`Couldn't stop the eth filter: ${filterId}`);
        }
    }
    /**
     * Adds the callback and sets up the methods, to iterate over the results.
     *
     * @method pollFilter
     */
    async poll() {
        if (this.isStarted) {
            if (this.callbacks.length) {
                const result = await this.getChanges();
                this.callbacks.forEach(cb => {
                    if (this.formatter) {
                        result.forEach($ => {
                            cb(this.formatter($));
                        });
                    }
                    else {
                        result.forEach($ => cb($));
                    }
                });
            }
            this.stopSemaphore.resolve(1);
            if (this.isStarted) {
                this.stopSemaphore = future_1.future();
                setTimeout(safeAsync(() => this.poll()), config.ETH_POLLING_TIMEOUT);
            }
        }
        else {
            this.stopSemaphore.resolve(1);
        }
    }
}
exports.AbstractFilter = AbstractFilter;
class SHHFilter extends AbstractFilter {
    constructor(requestManager, options) {
        super(requestManager);
        this.requestManager = requestManager;
        this.options = options;
        this.options = this.options || { topics: [] };
        this.options.topics = this.options.topics || [];
        this.options.topics = this.options.topics.map(function (topic) {
            return toTopic(topic);
        });
        this.options = {
            topics: this.options.topics,
            to: this.options.to
        };
    }
    async getMessages() {
        const filterId = await this.filterId;
        return this.requestManager.shh_getMessages(filterId);
    }
    async getNewFilter() {
        return this.requestManager.shh_newFilter(this.options);
    }
    async getChanges() {
        const filterId = await this.filterId;
        return this.requestManager.shh_getFilterChanges(filterId);
    }
    async uninstall() {
        const filterId = await this.filterId;
        return this.requestManager.shh_uninstallFilter(filterId);
    }
}
exports.SHHFilter = SHHFilter;
class EthFilter extends AbstractFilter {
    constructor(requestManager, options, formatter = x => x) {
        super(requestManager);
        this.requestManager = requestManager;
        this.options = options;
        this.formatter = formatter;
        this.options = this.options || {};
        this.options.topics = this.options.topics || [];
        this.options.topics = this.options.topics.map(function (topic) {
            return toTopic(topic);
        });
        this.options = {
            topics: this.options.topics,
            address: this.options.address ? this.options.address : undefined,
            fromBlock: typeof this.options.fromBlock === 'number' || typeof this.options.fromBlock === 'string'
                ? formatters.inputBlockNumberFormatter(this.options.fromBlock)
                : 'latest',
            toBlock: typeof this.options.toBlock === 'number' || typeof this.options.toBlock === 'string'
                ? formatters.inputBlockNumberFormatter(this.options.toBlock)
                : 'latest'
        };
    }
    async getLogs() {
        if (!this.isStarted) {
            await this.start();
        }
        const filterId = await this.filterId;
        return this.requestManager.eth_getFilterLogs(filterId);
    }
    async getNewFilter() {
        return this.requestManager.eth_newFilter(this.options);
    }
    async getChanges() {
        const filterId = await this.filterId;
        return this.requestManager.eth_getFilterChanges(filterId);
    }
    async uninstall() {
        const filterId = await this.filterId;
        return this.requestManager.eth_uninstallFilter(filterId);
    }
}
exports.EthFilter = EthFilter;
class EthPendingTransactionFilter extends EthFilter {
    constructor(requestManager) {
        super(requestManager, null, arg => arg);
    }
    async getNewFilter() {
        return this.requestManager.eth_newPendingTransactionFilter();
    }
}
exports.EthPendingTransactionFilter = EthPendingTransactionFilter;
class EthBlockFilter extends EthFilter {
    constructor(requestManager) {
        super(requestManager, null, arg => arg);
    }
    async getNewFilter() {
        return this.requestManager.eth_newBlockFilter();
    }
}
exports.EthBlockFilter = EthBlockFilter;
//# sourceMappingURL=Filter.js.map