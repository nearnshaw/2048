"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const textAttributeParser_1 = require("./utils/textAttributeParser");
const Parser = require('parse5/lib/parser');
// Shorthands
function parse(html, options) {
    const parser = new Parser(options);
    return parser.parse(html);
}
function walk(node, callback) {
    if (callback(node) === false) {
        return false;
    }
    else {
        let childNode;
        let i = 0;
        if (typeof node.childNodes !== 'undefined') {
            i = 0;
            childNode = node.childNodes[i];
        }
        while (childNode !== undefined) {
            if (walk(childNode, callback) === false) {
                return false;
            }
            else {
                childNode = node.childNodes[++i];
            }
        }
    }
}
exports.walk = walk;
function findNode(root, name) {
    let foundNode = null;
    walk(root, function (node) {
        if (node.nodeName === name) {
            foundNode = node;
            return false;
        }
    });
    return foundNode;
}
exports.findNode = findNode;
function simplifyNode(root) {
    return {
        tag: root.nodeName,
        children: root.childNodes && root.childNodes.map($ => simplifyNode($)),
        attrs: root.attrs && root.attrs.reduce((prev, curr) => (Object.assign({}, prev, { [curr.name]: curr.value })), {})
    };
}
exports.simplifyNode = simplifyNode;
function parseAFrame(html) {
    const root = parse(html);
    const scene = findNode(root, 'scene');
    if (!scene) {
        throw new Error('The XML does not contain a <scene> tag');
    }
    // remove `node.tag like #text` recursively
    walk(scene, function (node) {
        node.childNodes = node.childNodes.filter($ => !$.nodeName.startsWith('#'));
    });
    return textAttributeParser_1.processSimplifiedNode(simplifyNode(scene));
}
exports.parseAFrame = parseAFrame;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYS1mcmFtZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9hLWZyYW1lLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQ0EscUVBQW1FO0FBQ25FLE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFBO0FBUTNDLGFBQWE7QUFDYixTQUFTLEtBQUssQ0FBQyxJQUFZLEVBQUUsT0FBYTtJQUN4QyxNQUFNLE1BQU0sR0FBRyxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQTtJQUVsQyxPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUE7QUFDM0IsQ0FBQztBQUVELFNBQWdCLElBQUksQ0FBQyxJQUFXLEVBQUUsUUFBdUM7SUFDdkUsSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssS0FBSyxFQUFFO1FBQzVCLE9BQU8sS0FBSyxDQUFBO0tBQ2I7U0FBTTtRQUNMLElBQUksU0FBUyxDQUFBO1FBQ2IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFBO1FBRVQsSUFBSSxPQUFRLElBQVksQ0FBQyxVQUFVLEtBQUssV0FBVyxFQUFFO1lBQ25ELENBQUMsR0FBRyxDQUFDLENBQUE7WUFDTCxTQUFTLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQTtTQUMvQjtRQUVELE9BQU8sU0FBUyxLQUFLLFNBQVMsRUFBRTtZQUM5QixJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUUsUUFBUSxDQUFDLEtBQUssS0FBSyxFQUFFO2dCQUN2QyxPQUFPLEtBQUssQ0FBQTthQUNiO2lCQUFNO2dCQUNMLFNBQVMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUE7YUFDakM7U0FDRjtLQUNGO0FBQ0gsQ0FBQztBQXBCRCxvQkFvQkM7QUFFRCxTQUFnQixRQUFRLENBQUMsSUFBVyxFQUFFLElBQVk7SUFDaEQsSUFBSSxTQUFTLEdBQWlCLElBQUksQ0FBQTtJQUVsQyxJQUFJLENBQUMsSUFBSSxFQUFFLFVBQVMsSUFBSTtRQUN0QixJQUFJLElBQUksQ0FBQyxRQUFRLEtBQUssSUFBSSxFQUFFO1lBQzFCLFNBQVMsR0FBRyxJQUFJLENBQUE7WUFDaEIsT0FBTyxLQUFLLENBQUE7U0FDYjtJQUNILENBQUMsQ0FBQyxDQUFBO0lBRUYsT0FBTyxTQUFTLENBQUE7QUFDbEIsQ0FBQztBQVhELDRCQVdDO0FBRUQsU0FBZ0IsWUFBWSxDQUFDLElBQVc7SUFDdEMsT0FBTztRQUNMLEdBQUcsRUFBRSxJQUFJLENBQUMsUUFBUTtRQUNsQixRQUFRLEVBQUUsSUFBSSxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN0RSxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLG1CQUFNLElBQUksSUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSyxJQUFHLEVBQUUsRUFBRSxDQUFDO0tBQ25HLENBQUE7QUFDSCxDQUFDO0FBTkQsb0NBTUM7QUFFRCxTQUFnQixXQUFXLENBQUMsSUFBWTtJQUN0QyxNQUFNLElBQUksR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUE7SUFFeEIsTUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQTtJQUVyQyxJQUFJLENBQUMsS0FBSyxFQUFFO1FBQ1YsTUFBTSxJQUFJLEtBQUssQ0FBQyx3Q0FBd0MsQ0FBQyxDQUFBO0tBQzFEO0lBRUQsMkNBQTJDO0lBQzNDLElBQUksQ0FBQyxLQUFLLEVBQUUsVUFBUyxJQUFJO1FBQ3ZCLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUE7SUFDNUUsQ0FBQyxDQUFDLENBQUE7SUFFRixPQUFPLDJDQUFxQixDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFBO0FBQ25ELENBQUM7QUFmRCxrQ0FlQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElTaW1wbGlmaWVkTm9kZSB9IGZyb20gJy4vaW50ZXJmYWNlcydcbmltcG9ydCB7IHByb2Nlc3NTaW1wbGlmaWVkTm9kZSB9IGZyb20gJy4vdXRpbHMvdGV4dEF0dHJpYnV0ZVBhcnNlcidcbmNvbnN0IFBhcnNlciA9IHJlcXVpcmUoJ3BhcnNlNS9saWIvcGFyc2VyJylcblxuZXhwb3J0IGludGVyZmFjZSBJTm9kZSB7XG4gIGNoaWxkTm9kZXM6IElOb2RlW11cbiAgbm9kZU5hbWU6IHN0cmluZ1xuICBhdHRyczogeyBuYW1lOiBzdHJpbmc7IHZhbHVlOiBzdHJpbmcgfVtdXG59XG5cbi8vIFNob3J0aGFuZHNcbmZ1bmN0aW9uIHBhcnNlKGh0bWw6IHN0cmluZywgb3B0aW9ucz86IGFueSkge1xuICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpXG5cbiAgcmV0dXJuIHBhcnNlci5wYXJzZShodG1sKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gd2Fsayhub2RlOiBJTm9kZSwgY2FsbGJhY2s6IChub2RlOiBJTm9kZSkgPT4gdm9pZCB8IGZhbHNlKSB7XG4gIGlmIChjYWxsYmFjayhub2RlKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIHtcbiAgICBsZXQgY2hpbGROb2RlXG4gICAgbGV0IGkgPSAwXG5cbiAgICBpZiAodHlwZW9mIChub2RlIGFzIGFueSkuY2hpbGROb2RlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGkgPSAwXG4gICAgICBjaGlsZE5vZGUgPSBub2RlLmNoaWxkTm9kZXNbaV1cbiAgICB9XG5cbiAgICB3aGlsZSAoY2hpbGROb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh3YWxrKGNoaWxkTm9kZSwgY2FsbGJhY2spID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkTm9kZSA9IG5vZGUuY2hpbGROb2Rlc1srK2ldXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTm9kZShyb290OiBJTm9kZSwgbmFtZTogc3RyaW5nKSB7XG4gIGxldCBmb3VuZE5vZGU6IElOb2RlIHwgbnVsbCA9IG51bGxcblxuICB3YWxrKHJvb3QsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gbmFtZSkge1xuICAgICAgZm91bmROb2RlID0gbm9kZVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBmb3VuZE5vZGVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNpbXBsaWZ5Tm9kZShyb290OiBJTm9kZSk6IElTaW1wbGlmaWVkTm9kZSB7XG4gIHJldHVybiB7XG4gICAgdGFnOiByb290Lm5vZGVOYW1lLFxuICAgIGNoaWxkcmVuOiByb290LmNoaWxkTm9kZXMgJiYgcm9vdC5jaGlsZE5vZGVzLm1hcCgkID0+IHNpbXBsaWZ5Tm9kZSgkKSksXG4gICAgYXR0cnM6IHJvb3QuYXR0cnMgJiYgcm9vdC5hdHRycy5yZWR1Y2UoKHByZXYsIGN1cnIpID0+ICh7IC4uLnByZXYsIFtjdXJyLm5hbWVdOiBjdXJyLnZhbHVlIH0pLCB7fSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VBRnJhbWUoaHRtbDogc3RyaW5nKTogSVNpbXBsaWZpZWROb2RlIHtcbiAgY29uc3Qgcm9vdCA9IHBhcnNlKGh0bWwpXG5cbiAgY29uc3Qgc2NlbmUgPSBmaW5kTm9kZShyb290LCAnc2NlbmUnKVxuXG4gIGlmICghc2NlbmUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBYTUwgZG9lcyBub3QgY29udGFpbiBhIDxzY2VuZT4gdGFnJylcbiAgfVxuXG4gIC8vIHJlbW92ZSBgbm9kZS50YWcgbGlrZSAjdGV4dGAgcmVjdXJzaXZlbHlcbiAgd2FsayhzY2VuZSwgZnVuY3Rpb24obm9kZSkge1xuICAgIG5vZGUuY2hpbGROb2RlcyA9IG5vZGUuY2hpbGROb2Rlcy5maWx0ZXIoJCA9PiAhJC5ub2RlTmFtZS5zdGFydHNXaXRoKCcjJykpXG4gIH0pXG5cbiAgcmV0dXJuIHByb2Nlc3NTaW1wbGlmaWVkTm9kZShzaW1wbGlmeU5vZGUoc2NlbmUpKVxufVxuIl19