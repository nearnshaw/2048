"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils = require("./utils/utils");
const config = require("./utils/config");
const errors = require("./utils/errors");
const jsonrpc_1 = require("./utils/jsonrpc");
const future_1 = require("./utils/future");
class Poller {
    constructor(requestManager) {
        this.requestManager = requestManager;
        this.polls = {};
        this.timeout = null;
        // stub
    }
    /**
     * Should be used to start polling
     *
     * @method startPolling
     * @param {object} data
     * @param {number} pollId
     * @param {Function} callback
     * @param {Function} uninstall
     *
     * @todo cleanup number of params
     */
    startPolling(data, pollId, callback, uninstall) {
        this.polls[pollId] = {
            data: data,
            id: pollId,
            callback: callback,
            uninstall: uninstall
        };
        // start polling
        if (!this.timeout) {
            this.poll();
        }
    }
    /**
     * Should be used to stop polling for filter with given id
     *
     * @method stopPolling
     * @param {number} pollId
     */
    stopPolling(pollId) {
        delete this.polls[pollId];
        // stop polling
        if (Object.keys(this.polls).length === 0 && this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = null;
        }
    }
    /**
     * Should be called to reset the polling mechanism of the request manager
     *
     * @method reset
     */
    reset(keepIsSyncing = false) {
        /*jshint maxcomplexity:5 */
        for (let key in this.polls) {
            // remove all polls, except sync polls,
            // they need to be removed manually by calling syncing.stopWatching()
            if (!keepIsSyncing || key.indexOf('syncPoll_') === -1) {
                this.polls[key].uninstall();
                delete this.polls[key];
            }
        }
        // stop polling
        if (Object.keys(this.polls).length === 0 && this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = null;
        }
    }
    /**
     * Should be called to poll for changes on filter with given id
     *
     * @method poll
     */
    poll() {
        this.timeout = setTimeout(this.poll.bind(this), config.ETH_POLLING_TIMEOUT);
        if (Object.keys(this.polls).length === 0) {
            return;
        }
        if (!this.requestManager.provider) {
            // tslint:disable-next-line:no-console
            console.error(errors.InvalidProvider());
            return;
        }
        let pollsData = [];
        for (let key in this.polls) {
            pollsData.push(this.polls[key]);
        }
        if (pollsData.length === 0) {
            return;
        }
        let payload = jsonrpc_1.toBatchPayload(pollsData.map($ => $.data));
        // map the request id to they poll id
        payload.forEach((payload, ix) => {
            const defer = future_1.future();
            defer
                .then(r => {
                pollsData[ix].callback(null, r);
            })
                .catch(e => {
                pollsData[ix].callback(e, void 0);
            });
            defer.finally(() => this.requestManager.requests.delete(payload.id));
            this.requestManager.requests.set(payload.id, defer);
        });
        this.requestManager.provider.sendAsync(payload, (error, results) => {
            if (error) {
                // tslint:disable-next-line:no-console
                console.error(error);
                return;
            }
            if (!utils.isArray(results)) {
                const error = errors.InvalidResponse(results);
                // tslint:disable-next-line:no-console
                console.error(error);
                throw error;
            }
            results.forEach(result => {
                const valid = jsonrpc_1.isValidResponse(result);
                const defer = this.requestManager.requests.get(result.id);
                if (!valid) {
                    defer.reject(errors.InvalidResponse(result));
                }
                else {
                    defer.resolve(result.result);
                }
            });
        });
    }
}
exports.Poller = Poller;
//# sourceMappingURL=Poller.js.map