"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = require("decentraland-rpc/lib/common/core/EventDispatcher");
/**
 * MessageBusClient provides an easy way to send and reveive peer to peer
 * messages thru the communications interface of Decentraland.
 *
 * The usage is simple, it implements a pub-sub pattern that shares messages
 * using the connection that already exists between peers.
 *
 * @example inside your ScriptableScene
 * ```ts
 *   let messageBusClient = await MessageBusClient.acquireEstateChannel(this)
 *   messageBusClient.on('a message name', (message) => {...})
 *   messageBusClient.emit('a message name', message)
 * ```
 */
class MessageBusClient extends EventDispatcher_1.EventDispatcher {
    constructor(api, id, busClientId) {
        super();
        this.api = api;
        this.id = id;
        this.busClientId = busClientId;
        api[`on${this.id}`]((message) => {
            if (this.busClientId !== message.sender) {
                super.emit(message.event, ...message.args);
            }
        });
    }
    static async acquireEstateChannel(system) {
        const busId = Math.random().toString(36);
        const { MessageBus } = await system.loadAPIs(['MessageBus']);
        const bus = await MessageBus.getEstateChannel();
        return new MessageBusClient(MessageBus, bus.id, busId);
    }
    emit(event, ...args) {
        this.api[this.id]({
            event,
            args,
            sender: this.busClientId
        });
        super.emit(event, ...args);
    }
}
exports.MessageBusClient = MessageBusClient;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWVzc2FnZUJ1cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9NZXNzYWdlQnVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsc0ZBQWtGO0FBU2xGOzs7Ozs7Ozs7Ozs7O0dBYUc7QUFDSCxNQUFhLGdCQUEwQixTQUFRLGlDQUFrQjtJQUMvRCxZQUE4QixHQUFRLEVBQVksRUFBVSxFQUFZLFdBQW1CO1FBQ3pGLEtBQUssRUFBRSxDQUFBO1FBRHFCLFFBQUcsR0FBSCxHQUFHLENBQUs7UUFBWSxPQUFFLEdBQUYsRUFBRSxDQUFRO1FBQVksZ0JBQVcsR0FBWCxXQUFXLENBQVE7UUFFekYsR0FBRyxDQUFDLEtBQUssSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxPQUFpQixFQUFFLEVBQUU7WUFDeEMsSUFBSSxJQUFJLENBQUMsV0FBVyxLQUFLLE9BQU8sQ0FBQyxNQUFNLEVBQUU7Z0JBQ3ZDLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQTthQUMzQztRQUNILENBQUMsQ0FBQyxDQUFBO0lBQ0osQ0FBQztJQUVELE1BQU0sQ0FBQyxLQUFLLENBQUMsb0JBQW9CLENBQUMsTUFBdUI7UUFDdkQsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQTtRQUN4QyxNQUFNLEVBQUUsVUFBVSxFQUFFLEdBQUcsTUFBTSxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQTtRQUU1RCxNQUFNLEdBQUcsR0FBRyxNQUFNLFVBQVUsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFBO1FBRS9DLE9BQU8sSUFBSSxnQkFBZ0IsQ0FBQyxVQUFVLEVBQUUsR0FBRyxDQUFDLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQTtJQUN4RCxDQUFDO0lBRUQsSUFBSSxDQUFDLEtBQWEsRUFBRSxHQUFHLElBQVc7UUFDaEMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDaEIsS0FBSztZQUNMLElBQUk7WUFDSixNQUFNLEVBQUUsSUFBSSxDQUFDLFdBQVc7U0FDYixDQUFDLENBQUE7UUFDZCxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFBO0lBQzVCLENBQUM7Q0FDRjtBQTNCRCw0Q0EyQkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudERpc3BhdGNoZXIgfSBmcm9tICdkZWNlbnRyYWxhbmQtcnBjL2xpYi9jb21tb24vY29yZS9FdmVudERpc3BhdGNoZXInXG5pbXBvcnQgeyBTY3JpcHRhYmxlU2NlbmUgfSBmcm9tICcuJ1xuXG5leHBvcnQgaW50ZXJmYWNlIElNZXNzYWdlIHtcbiAgZXZlbnQ6IHN0cmluZ1xuICBhcmdzOiBhbnlbXVxuICBzZW5kZXI6IHN0cmluZ1xufVxuXG4vKipcbiAqIE1lc3NhZ2VCdXNDbGllbnQgcHJvdmlkZXMgYW4gZWFzeSB3YXkgdG8gc2VuZCBhbmQgcmV2ZWl2ZSBwZWVyIHRvIHBlZXJcbiAqIG1lc3NhZ2VzIHRocnUgdGhlIGNvbW11bmljYXRpb25zIGludGVyZmFjZSBvZiBEZWNlbnRyYWxhbmQuXG4gKlxuICogVGhlIHVzYWdlIGlzIHNpbXBsZSwgaXQgaW1wbGVtZW50cyBhIHB1Yi1zdWIgcGF0dGVybiB0aGF0IHNoYXJlcyBtZXNzYWdlc1xuICogdXNpbmcgdGhlIGNvbm5lY3Rpb24gdGhhdCBhbHJlYWR5IGV4aXN0cyBiZXR3ZWVuIHBlZXJzLlxuICpcbiAqIEBleGFtcGxlIGluc2lkZSB5b3VyIFNjcmlwdGFibGVTY2VuZVxuICogYGBgdHNcbiAqICAgbGV0IG1lc3NhZ2VCdXNDbGllbnQgPSBhd2FpdCBNZXNzYWdlQnVzQ2xpZW50LmFjcXVpcmVFc3RhdGVDaGFubmVsKHRoaXMpXG4gKiAgIG1lc3NhZ2VCdXNDbGllbnQub24oJ2EgbWVzc2FnZSBuYW1lJywgKG1lc3NhZ2UpID0+IHsuLi59KVxuICogICBtZXNzYWdlQnVzQ2xpZW50LmVtaXQoJ2EgbWVzc2FnZSBuYW1lJywgbWVzc2FnZSlcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgTWVzc2FnZUJ1c0NsaWVudDxUID0gYW55PiBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlcjxUPiB7XG4gIHByaXZhdGUgY29uc3RydWN0b3IocHJvdGVjdGVkIGFwaTogYW55LCBwcm90ZWN0ZWQgaWQ6IHN0cmluZywgcHJvdGVjdGVkIGJ1c0NsaWVudElkOiBzdHJpbmcpIHtcbiAgICBzdXBlcigpXG4gICAgYXBpW2BvbiR7dGhpcy5pZH1gXSgobWVzc2FnZTogSU1lc3NhZ2UpID0+IHtcbiAgICAgIGlmICh0aGlzLmJ1c0NsaWVudElkICE9PSBtZXNzYWdlLnNlbmRlcikge1xuICAgICAgICBzdXBlci5lbWl0KG1lc3NhZ2UuZXZlbnQsIC4uLm1lc3NhZ2UuYXJncylcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGFjcXVpcmVFc3RhdGVDaGFubmVsKHN5c3RlbTogU2NyaXB0YWJsZVNjZW5lKSB7XG4gICAgY29uc3QgYnVzSWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KVxuICAgIGNvbnN0IHsgTWVzc2FnZUJ1cyB9ID0gYXdhaXQgc3lzdGVtLmxvYWRBUElzKFsnTWVzc2FnZUJ1cyddKVxuXG4gICAgY29uc3QgYnVzID0gYXdhaXQgTWVzc2FnZUJ1cy5nZXRFc3RhdGVDaGFubmVsKClcblxuICAgIHJldHVybiBuZXcgTWVzc2FnZUJ1c0NsaWVudChNZXNzYWdlQnVzLCBidXMuaWQsIGJ1c0lkKVxuICB9XG5cbiAgZW1pdChldmVudDogc3RyaW5nLCAuLi5hcmdzOiBhbnlbXSkge1xuICAgIHRoaXMuYXBpW3RoaXMuaWRdKHtcbiAgICAgIGV2ZW50LFxuICAgICAgYXJncyxcbiAgICAgIHNlbmRlcjogdGhpcy5idXNDbGllbnRJZFxuICAgIH0gYXMgSU1lc3NhZ2UpXG4gICAgc3VwZXIuZW1pdChldmVudCwgLi4uYXJncylcbiAgfVxufVxuIl19